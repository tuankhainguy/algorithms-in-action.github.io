(this.webpackJsonpaia=this.webpackJsonpaia||[]).push([[0],{159:function(e,t,n){e.exports={themeDark:"#242424",themeNormal:"#393939",themeLight:"#505050",colorFont:"#cecece",colorShadow:"rgba(0,0,0,.2)",colorOverlay:"rgba(255,255,255,.1)",colorAlert:"#f3bd58",colorSelected:"#067aff",colorPatched:"#c51162",colorHighlight:"#29d",colorActive:"#00e676",colorBlue:"#067aff",colorRed:"#d21010",colorPurple:"#c735da",colorGreen:"#4bb454",colorYellow:"#b3b605",colorLightGreen:"#2ec752",lineHeight:"32px",fontSizeNormal:"12px",fontSizeLarge:"14px",renderer:"Renderer_renderer__fIED7",title:"Renderer_title__3Xv9R"}},169:function(e,t,n){},18:function(e,t,n){},20:function(e,t,n){e.exports={themeDark:"#242424",themeNormal:"#393939",themeLight:"#505050",colorFont:"#cecece",colorShadow:"rgba(0,0,0,.2)",colorOverlay:"rgba(255,255,255,.1)",colorAlert:"#f3bd58",colorSelected:"#067aff",colorPatched:"#c51162",colorHighlight:"#29d",colorActive:"#00e676",colorBlue:"#067aff",colorRed:"#d21010",colorPurple:"#c735da",colorGreen:"#4bb454",colorYellow:"#b3b605",colorLightGreen:"#2ec752",lineHeight:"32px",fontSizeNormal:"12px",fontSizeLarge:"14px",array_2d:"TwoArray2DRenderer_array_2d__2agTz",row:"TwoArray2DRenderer_row__1FAyL",col:"TwoArray2DRenderer_col__Tw3SQ",value:"TwoArray2DRenderer_value__2r4O1",selected:"TwoArray2DRenderer_selected__VjvIF",patched:"TwoArray2DRenderer_patched__1OD7i",sorted:"TwoArray2DRenderer_sorted__1Q2cG",index:"TwoArray2DRenderer_index__3B46O"}},201:function(e,t,n){e.exports={themeDark:"#242424",themeNormal:"#393939",themeLight:"#505050",colorFont:"#cecece",colorShadow:"rgba(0,0,0,.2)",colorOverlay:"rgba(255,255,255,.1)",colorAlert:"#f3bd58",colorSelected:"#067aff",colorPatched:"#c51162",colorHighlight:"#29d",colorActive:"#00e676",colorBlue:"#067aff",colorRed:"#d21010",colorPurple:"#c735da",colorGreen:"#4bb454",colorYellow:"#b3b605",colorLightGreen:"#2ec752",lineHeight:"32px",fontSizeNormal:"12px",fontSizeLarge:"14px",ellipsis:"Ellipsis_ellipsis__2Z8yx"}},219:function(e,t,n){},22:function(e,t,n){e.exports={themeDark:"#242424",themeNormal:"#393939",themeLight:"#505050",colorFont:"#cecece",colorShadow:"rgba(0,0,0,.2)",colorOverlay:"rgba(255,255,255,.1)",colorAlert:"#f3bd58",colorSelected:"#067aff",colorPatched:"#c51162",colorHighlight:"#29d",colorActive:"#00e676",colorBlue:"#067aff",colorRed:"#d21010",colorPurple:"#c735da",colorGreen:"#4bb454",colorYellow:"#b3b605",colorLightGreen:"#2ec752",lineHeight:"32px",fontSizeNormal:"12px",fontSizeLarge:"14px",graph:"GraphRenderer_graph__2Wjfx",node:"GraphRenderer_node__1cbvk",circle:"GraphRenderer_circle__3yoe6",rect:"GraphRenderer_rect__5Su8J",id:"GraphRenderer_id__OkcX_",weight:"GraphRenderer_weight__29S_I",Result:"GraphRenderer_Result__3Kud-",selected:"GraphRenderer_selected__Zt0ij",visited:"GraphRenderer_visited__1tXH4",edge:"GraphRenderer_edge__2pz7s",line:"GraphRenderer_line__23oEY",directed:"GraphRenderer_directed__18zUT",arrow:"GraphRenderer_arrow__3TvMB"}},220:function(e,t,n){},229:function(e,t,n){},234:function(e,t,n){},236:function(e,t,n){},237:function(e,t,n){},25:function(e,t,n){e.exports={themeDark:"#242424",themeNormal:"#393939",themeLight:"#505050",colorFont:"#cecece",colorShadow:"rgba(0,0,0,.2)",colorOverlay:"rgba(255,255,255,.1)",colorAlert:"#f3bd58",colorSelected:"#067aff",colorPatched:"#c51162",colorHighlight:"#29d",colorActive:"#00e676",colorBlue:"#067aff",colorRed:"#d21010",colorPurple:"#c735da",colorGreen:"#4bb454",colorYellow:"#b3b605",colorLightGreen:"#2ec752",lineHeight:"32px",fontSizeNormal:"12px",fontSizeLarge:"14px",array_1d:"Array1DRenderer_array_1d__1yUCn",bottom_caption:"Array1DRenderer_bottom_caption__2F2ve",captionmsort_arr_td:"Array1DRenderer_captionmsort_arr_td__rXJdR",row:"Array1DRenderer_row__FrKGm",col:"Array1DRenderer_col__3M3Xp",value:"Array1DRenderer_value__1fXfi",variable:"Array1DRenderer_variable__NM9Lg",selected:"Array1DRenderer_selected__1BZ0T",selected1:"Array1DRenderer_selected1__2ghA0",selected2:"Array1DRenderer_selected2__3Yxs8",selected3:"Array1DRenderer_selected3__38371",selected4:"Array1DRenderer_selected4__3AL4c",selected5:"Array1DRenderer_selected5__3CTN_",patched:"Array1DRenderer_patched__YLnc8",sorted:"Array1DRenderer_sorted__2FGQE",index:"Array1DRenderer_index__UMfwt",variables:"Array1DRenderer_variables__IlHNp",faded:"Array1DRenderer_faded__1VkTV",stack:"Array1DRenderer_stack__2OcRA",stackElement:"Array1DRenderer_stackElement__2uuDF",stackSubElement:"Array1DRenderer_stackSubElement__F9hEv"}},330:function(e,t,n){},331:function(e,t,n){},332:function(e,t,n){},333:function(e,t,n){},334:function(e,t,n){},336:function(e,t,n){"use strict";n.r(t);var a=n(1),r=n.n(a),i=n(129),s=n.n(i),o=n(109),l=n(26),d=(n(219),n(220),n.p+"static/media/logo.3fc6bd69.svg"),c=n(0);var h,u=function(e){let{onSetting:t}=e;const n=Object(l.f)();return Object(c.jsxs)("div",{className:"header",children:[Object(c.jsxs)("button",{className:"headerTitle",type:"button",onClick:()=>{n.push("/")},children:[Object(c.jsx)("img",{src:d,alt:"logo"}),Object(c.jsx)("h1",{children:"Algorithms in Action"})]}),Object(c.jsxs)("div",{className:"navButton",children:[Object(c.jsx)("button",{type:"button",onClick:()=>{n.push("/about")},children:"About"}),Object(c.jsx)("button",{type:"button",onClick:t,children:"Settings"})]})]})};function p(){return p=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e},p.apply(this,arguments)}function g(e,t){let{title:n,titleId:r,...i}=e;return a.createElement("svg",p({width:16,height:16,viewBox:"0 0 16 16",fill:"none",xmlns:"http://www.w3.org/2000/svg",ref:t,"aria-labelledby":r},i),n?a.createElement("title",{id:r},n):null,h||(h=a.createElement("circle",{cx:8,cy:8,r:8,fill:"#C4C4C4"})))}const m=a.forwardRef(g);var f;n.p;function b(){return b=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e},b.apply(this,arguments)}function y(e,t){let{title:n,titleId:r,...i}=e;return a.createElement("svg",b({id:"svg",xmlns:"http://www.w3.org/2000/svg",xmlnsXlink:"http://www.w3.org/1999/xlink",width:20,height:40,viewBox:"0, 0, 40,40",ref:t,"aria-labelledby":r},i),n?a.createElement("title",{id:r},n):null,f||(f=a.createElement("polygon",{points:"20,0 20,40 0,20",stroke:"none",fill:"#b0acac",fillRule:"evenodd"})))}const A=a.forwardRef(y);n.p;var x=n.p+"static/media/HSExp.0f5a8e78.md",v=n.p+"static/media/BSTExp.6361796a.md",j=n.p+"static/media/QSExp.21194923.md",w=n.p+"static/media/msort_arr_td.145985cd.md",E=n.p+"static/media/msort_lista_td.47714636.md",k=n.p+"static/media/PRIM_oldExp.5f7835c1.md",N=n.p+"static/media/PRIMExp.c718ab3d.md",O=n.p+"static/media/KRUSKALExp.e968cbbd.md",I=n.p+"static/media/TCExp.a2345a1d.md",C=n.p+"static/media/BFSSExp.59f0e4e6.md",S=n.p+"static/media/QSM3Exp.abb6cec5.md",M=n.p+"static/media/HSSExp.e0c0025e.md",B=n.p+"static/media/UFExp.4e12391c.md",T=n.p+"static/media/TTFExp.1bb9ea16.md",R=n.p+"static/media/DIJKExp.0be9daff.md",L=n.p+"static/media/ASTExp.df3b37e4.md",D=n.p+"static/media/BFSExp.49ba85dc.md",P=n.p+"static/media/DFSExp.5bd9fb33.md",F=n.p+"static/media/DFSrecExp.9999e085.md",H=n.p+"static/media/HashingExp.e447e5af.md",_=n(196),G=n.n(_);var V=function(e){let{logWarning:t,logTag:n,logMsg:a}=e;return Object(c.jsxs)("div",{className:"logContainer",children:[Object(c.jsx)("span",{className:"logTag","data-testid":"logTag",style:t?{color:"#FB3640"}:{color:"#52AA5E"},children:n}),Object(c.jsx)("span",{className:"logText",children:a})]})};const z=e=>e.match(/^[0-9]+(,[0-9]+)*$/g),Q=e=>e.match(/^[a-z\s]+$/g),U=e=>e.match(/^\d+$/g),W=e=>{for(let t=0;t<e.length;t++){for(let n=0;n<t;n++)if(e[t][n]!==e[n][t])return!1;if(0!==e[t][t])return!1}return!0};function q(e,t){return e=Math.ceil(e),t=Math.floor(t),Math.floor(Math.random()*(t-e+1))+e}const X=(e,t,n)=>{const a=[];for(let r=0;r<e;r+=1)a.push(q(t,n));return a},Y=(e,t,n)=>{const a=new Set;for(;a.size<e;)a.add(q(t,n));return Array.from(a)},K=(e,t)=>function e(t,n,a,r){if(n<=t)return[];const i=Math.floor((n-t)/2+t),s=e(t,i-r,a,r),o=e(i+r,n,-1,r);return 1===a?s.concat(o).concat([i]):[i].concat(s).concat(o)}(e,t,1,2),Z=e=>Object(c.jsx)(V,{logWarning:!1,logTag:"",logMsg:""}),J=function(e,t){arguments.length>2&&void 0!==arguments[2]||"It seems the ".concat(e," algorithm does not accept this data.");return Object(c.jsx)(V,{logWarning:!0,logTag:"Oops...",logMsg:"".concat(t||"")})},$=e=>{const t=[];for(let n=0;n<e;n+=1)t.push({Header:n+1,accessor:"col".concat(n)});return t},ee=(e,t,n,a,r)=>{const i=[];for(let o=0;o<e;o+=1){let s=[],l=0,d=0;do{d++,s=[],l=0;for(let d=0;d<e;d+=1){let e=0;d<o&&a?e=i[d][o]:o==d?e=a?0:1:(d==o+1||Math.random()<.75**(3*Math.abs(o-d)-6))&&(e=r?1:q(t,n)),e>0&&l++,s.push(e)}}while(d<40&&(0===l||l>4)&&e>1);i.push(s)}let s=[];for(let o=0;o<e;o+=1){const t={};for(let n=0;n<e;n+=1)t["col".concat(n)]="".concat(i[o][n]);s.push(t)}return s},te=(e,t,n,a)=>Math.ceil(Math.sqrt(Math.pow(e-n,2)+Math.pow(t-a,2))),ne=(e,t,n,a)=>Math.abs(e-n)+Math.abs(t-a),ae=e=>{class t{constructor(e){this.value=e,this.left=null,this.right=null}}const n=e=>{if(0===e.length)return null;const a=Math.floor(e.length/2),r=new t(e[a]);return r.left=n(e.slice(0,a)),r.right=n(e.slice(a+1)),r};return(e=>{const t=[],n=new G.a;for(n.push(e);!n.isEmpty();){const e=n.shift();null!==e&&(t.push(e.value),n.push(e.left),n.push(e.right))}return t})(n(e))};var re=n(85);n(229);var ie,se,oe,le,de,ce,he,ue,pe,ge,me,fe,be,ye,Ae,xe,ve=function(e){const{icon:t,type:n,disabled:a,onClick:r,children:i}=e;return Object(c.jsx)("button",{type:"button",className:a?"btnDisabled ".concat(n):"btnActive ".concat(n),disabled:a,onClick:r,...e,children:t||i})};n(18);function je(){return je=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e},je.apply(this,arguments)}function we(e,t){let{title:n,titleId:r,...i}=e;return a.createElement("svg",je({id:"Capa_1",xmlns:"http://www.w3.org/2000/svg",xmlnsXlink:"http://www.w3.org/1999/xlink",x:"0px",y:"0px",viewBox:"0 0 489.533 489.533",style:{enableBackground:"new 0 0 489.533 489.533"},xmlSpace:"preserve",ref:t,"aria-labelledby":r},i),n?a.createElement("title",{id:r},n):null,ie||(ie=a.createElement("g",null,a.createElement("path",{d:"M268.175,488.161c98.2-11,176.9-89.5,188.1-187.7c14.7-128.4-85.1-237.7-210.2-239.1v-57.6c0-3.2-4-4.9-6.7-2.9 l-118.6,87.1c-2,1.5-2,4.4,0,5.9l118.6,87.1c2.7,2,6.7,0.2,6.7-2.9v-57.5c87.9,1.4,158.3,76.2,152.3,165.6 c-5.1,76.9-67.8,139.3-144.7,144.2c-81.5,5.2-150.8-53-163.2-130c-2.3-14.3-14.8-24.7-29.2-24.7c-17.9,0-31.9,15.9-29.1,33.6 C49.575,418.961,150.875,501.261,268.175,488.161z"}))),se||(se=a.createElement("g",null)),oe||(oe=a.createElement("g",null)),le||(le=a.createElement("g",null)),de||(de=a.createElement("g",null)),ce||(ce=a.createElement("g",null)),he||(he=a.createElement("g",null)),ue||(ue=a.createElement("g",null)),pe||(pe=a.createElement("g",null)),ge||(ge=a.createElement("g",null)),me||(me=a.createElement("g",null)),fe||(fe=a.createElement("g",null)),be||(be=a.createElement("g",null)),ye||(ye=a.createElement("g",null)),Ae||(Ae=a.createElement("g",null)),xe||(xe=a.createElement("g",null)))}const Ee=a.forwardRef(we);n.p;const ke=()=>{const e=document.getElementById("coverShowInstructions");null!==e&&(e.style.display="none")};var Ne=()=>{const e=document.getElementById("coverShowInstructions");null!==e&&(e.style.display="block")};const Oe=["mousedown","click","mouseup"];var Ie=function(e){const{formClassName:t,name:n,buttonName:r,value:i,onChange:s,handleSubmit:o,children:l,disabled:d}=e,{algorithm:h}=Object(a.useContext)(Pl);return Object(a.useEffect)((()=>{!function(e){Oe.forEach((t=>e.dispatchEvent(new MouseEvent(t,{view:window,bubbles:!0,cancelable:!0,buttons:1}))))}(document.querySelector('button[id="startBtnGrp"]'))}),[]),Object(c.jsx)("form",{className:t,onSubmit:o,children:Object(c.jsxs)("div",{className:"outerInput",children:[Object(c.jsx)("label",{className:"inputText",children:Object(c.jsx)("input",{name:n,type:"text",value:i,onChange:s})}),Object(c.jsxs)("div",{className:"btnGrp",children:[l,Object(c.jsx)(ve,{className:d?"blueWordBtnDisabled":"blueWordBtn",onClick:()=>{"Quicksort"===h.name&&(sessionStorage.setItem("isPivot",!1),sessionStorage.setItem("quicksortPlay",!1)),ke()},id:"startBtnGrp",type:"submit",disabled:d,children:r})]})]})})};var Ce,Se=function(e){const{algorithm:t,dispatch:n}=Object(a.useContext)(Pl),r=t.hasOwnProperty("visualisers")&&t.playing,[i,s]=Object(a.useState)(e);return{algorithm:t,dispatch:n,disabled:r,paramVal:i,setParamVal:s}};var Me=function(e){let{name:t,buttonName:n,mode:a,DEFAULT_VAL:r,SET_VAL:i,REFRESH_FUNCTION:s,ALGORITHM_NAME:o,EXAMPLE:l,formClassName:d,handleSubmit:h,setMessage:u}=e;const{dispatch:p,disabled:g}=Se(r);return Object(c.jsx)(Ie,{formClassName:d,name:o,buttonName:n,value:r,disabled:g,onChange:e=>{i(e.target.value.split(","))},handleSubmit:h&&"function"===typeof h?h:e=>{e.preventDefault();const n=e.target[0].value.replace(/\s+/g,"");if(z(n)){const e=n.split(Ce||(Ce=Object(re.a)([","]))).map((e=>+e));p(Bl.RUN_ALGORITHM,{name:t,mode:a,nodes:e})}else u(J(o,l))},children:Object(c.jsx)(ve,{icon:Object(c.jsx)(Ee,{}),className:g?"greyRoundBtnDisabled":"greyRoundBtn",id:o,disabled:g,onClick:()=>{let e=X(r.length,1,100);void 0!==s&&(e=s()),u(null),i(e)}})})};const Be=X(10,1,100);var Te=function(){const[e,t]=Object(a.useState)(null),[n,r]=Object(a.useState)(Be);return Object(c.jsxs)(c.Fragment,{children:[Object(c.jsx)("div",{className:"form",children:Object(c.jsx)(Me,{name:"heapSort",buttonName:"Sort",mode:"sort",formClassName:"formLeft",DEFAULT_VAL:n,SET_VAL:r,ALGORITHM_NAME:"Heap Sort",EXAMPLE:"Please follow the example provided: 0,1,2,3,4",setMessage:t})}),e]})},Re=n(389),Le=n(385),De=n(396);var Pe=function(e){let{name:t,buttonName:n,mode:a,DEFAULT_VAL:r,ALGORITHM_NAME:i,EXAMPLE:s,formClassName:o,handleSubmit:l,setMessage:d}=e;const{dispatch:h,disabled:u,paramVal:p,setParamVal:g}=Se(r);return Object(c.jsx)(Ie,{formClassName:o,name:i,buttonName:n,value:p,disabled:u,onChange:e=>g(e.target.value),handleSubmit:l&&"function"===typeof l?l:e=>{e.preventDefault();const n=e.target[0].value;if(U(n)){const e=parseInt(n,10);g(e),"transitiveClosure"!==t&&"prim"!==t&&h(Bl.RUN_ALGORITHM,{name:t,mode:a,target:e}),d(Z())}else d(J(i,s))}})};const Fe=X(10,1,100),He="search",_e="Please follow the example provided: 16",Ge={random:!1,sorted:!1,balanced:!1},Ve=Object(De.a)({root:{color:"#2289ff","&$checked":{color:"#027aff"}},checked:{}})((e=>Object(c.jsx)(Le.a,{...e})));var ze=function(){const{algorithm:e,dispatch:t}=Object(a.useContext)(Pl),[n,r]=Object(a.useState)(null),[i,s]=Object(a.useState)(Fe),[o,l]=Object(a.useState)({random:!0,sorted:!1,balanced:!1}),d=e=>{switch(e.target.name){case"random":s((e=>{for(let t=e.length-1;t>0;t--){const n=Math.floor(Math.random()*(t+1)),a=e[t];e[t]=e[n],e[n]=a}return e})(i));break;case"sorted":s([...i].sort(((e,t)=>e-t)));break;case"balanced":s(ae([...i].sort(((e,t)=>e-t))))}l({...Ge,[e.target.name]:!0})};return Object(a.useEffect)((()=>{document.getElementById("startBtnGrp").click()}),[o]),Object(c.jsxs)(c.Fragment,{children:[Object(c.jsxs)("div",{className:"form",children:[Object(c.jsx)(Me,{name:"binarySearchTree",buttonName:"Insert",mode:"insertion",formClassName:"formLeft",DEFAULT_VAL:o.balanced?ae([...i].sort(((e,t)=>e-t))):o.sorted?[...i].sort(((e,t)=>e-t)):i,SET_VAL:s,ALGORITHM_NAME:"insertion",EXAMPLE:"Please follow the example provided: 0,1,2,3,4",setMessage:r}),Object(c.jsx)(Pe,{name:"binarySearchTree",buttonName:"Search",mode:"search",formClassName:"formRight",DEFAULT_VAL:"2",ALGORITHM_NAME:He,EXAMPLE:_e,handleSubmit:n=>{n.preventDefault();const a=n.target[0].value;if(U(a)){const n=parseInt(a,10);if(e.hasOwnProperty("visualisers")&&!e.visualisers.graph.instance.isEmpty()){const a=e.chunker.visualisers;t(Bl.RUN_ALGORITHM,{name:"binarySearchTree",mode:"search",visualiser:a,target:n}),r(Z())}else r(J(He,void 0,"Please fully build the tree before running a search."))}else r(J(He,_e))},setMessage:r})]}),Object(c.jsx)("span",{className:"generalText",children:"Choose type of tree: \xa0\xa0"}),Object(c.jsx)(Re.a,{control:Object(c.jsx)(Ve,{checked:o.random,onChange:d,name:"random"}),label:"Random",className:"checkbox"}),Object(c.jsx)(Re.a,{control:Object(c.jsx)(Ve,{checked:o.sorted,onChange:d,name:"sorted"}),label:"Sorted",className:"checkbox"}),Object(c.jsx)(Re.a,{control:Object(c.jsx)(Ve,{checked:o.balanced,onChange:d,name:"balanced"}),label:"Balanced",className:"checkbox"}),n]})};const Qe=X.bind(null,12,1,50),Ue=Qe(),We={random:!1,sortedAsc:!1,bestCase:!1,sortedDesc:!1},qe=Object(De.a)({root:{color:"#2289ff","&$checked":{color:"#027aff"}},checked:{}})((e=>Object(c.jsx)(Le.a,{...e})));var Xe=function(){const[e,t]=Object(a.useState)(null),[n,r]=Object(a.useState)(Ue),[i,s]=Object(a.useState)({random:!0,sortedAsc:!1,bestCase:!1,sortedDesc:!1}),o=e=>{switch(e.target.name){case"sortedAsc":r([...n].sort((function(e,t){return+e-+t})));break;case"sortedDesc":r([...n].sort((function(e,t){return+t-+e})));break;case"random":r(Qe());break;case"bestCase":r(K(Math.floor(10*Math.random()),25+Math.floor(25*Math.random())))}s({...We,[e.target.name]:!0})};return Object(a.useEffect)((()=>{document.getElementById("startBtnGrp").click()}),[i]),Object(c.jsxs)(c.Fragment,{children:[Object(c.jsx)("div",{className:"form",children:Object(c.jsx)(Me,{name:"quickSort",buttonName:"Reset",mode:"sort",formClassName:"formLeft",DEFAULT_VAL:n,SET_VAL:r,REFRESH_FUNCTION:i.sortedAsc?()=>Qe().sort((function(e,t){return+e-+t})):i.sortedDesc?()=>Qe().sort((function(e,t){return+t-+e})):i.bestCase?()=>K(Math.floor(10*Math.random()),25+Math.floor(25*Math.random())):void 0,ALGORITHM_NAME:"Quick Sort",EXAMPLE:"Please follow the example provided: 0,1,2,3,4",setMessage:t})}),Object(c.jsx)("span",{className:"generalText",children:"Choose input format: \xa0\xa0"}),Object(c.jsx)(Re.a,{control:Object(c.jsx)(qe,{checked:i.random,onChange:o,name:"random"}),label:"Random",className:"checkbox"}),Object(c.jsx)(Re.a,{control:Object(c.jsx)(qe,{checked:i.sortedAsc,onChange:o,name:"sortedAsc"}),label:"Sorted (ascending)",className:"checkbox"}),Object(c.jsx)(Re.a,{control:Object(c.jsx)(qe,{checked:i.sortedDesc,onChange:o,name:"sortedDesc"}),label:"Sorted (descending)",className:"checkbox"}),Object(c.jsx)(Re.a,{control:Object(c.jsx)(qe,{checked:i.bestCase,onChange:o,name:"bestCase"}),label:"Ideal",className:"checkbox"}),e]})};const Ye=X.bind(null,12,1,50),Ke=Ye(),Ze={random:!1,sortedAsc:!1,sortedDesc:!1},Je=Object(De.a)({root:{color:"#2289ff","&$checked":{color:"#027aff"}},checked:{}})((e=>Object(c.jsx)(Le.a,{...e})));var $e=function(){const[e,t]=Object(a.useState)(null),[n,r]=Object(a.useState)(Ke),[i,s]=Object(a.useState)({random:!0,sortedAsc:!1,sortedDesc:!1}),o=e=>{switch(e.target.name){case"sortedAsc":r([...n].sort((function(e,t){return+e-+t})));break;case"sortedDesc":r([...n].sort((function(e,t){return+t-+e})));break;case"random":r(Ye());break;case"bestCase":r(K(Math.floor(10*Math.random()),25+Math.floor(25*Math.random())))}s({...Ze,[e.target.name]:!0})};return Object(a.useEffect)((()=>{document.getElementById("startBtnGrp").click()}),[i]),Object(c.jsxs)(c.Fragment,{children:[Object(c.jsx)("div",{className:"form",children:Object(c.jsx)(Me,{name:"msort_arr_td",buttonName:"Reset",mode:"sort",formClassName:"formLeft",DEFAULT_VAL:n,SET_VAL:r,REFRESH_FUNCTION:i.sortedAsc?()=>Ye().sort((function(e,t){return+e-+t})):i.sortedDesc?()=>Ye().sort((function(e,t){return+t-+e})):i.bestCase?()=>K(Math.floor(10*Math.random()),25+Math.floor(25*Math.random())):void 0,ALGORITHM_NAME:"Merge Sort",EXAMPLE:"Please follow the example provided: 0,1,2,3,4",setMessage:t})}),Object(c.jsx)("span",{className:"generalText",children:"Choose input format: \xa0\xa0"}),Object(c.jsx)(Re.a,{control:Object(c.jsx)(Je,{checked:i.random,onChange:o,name:"random"}),label:"Random",className:"checkbox"}),Object(c.jsx)(Re.a,{control:Object(c.jsx)(Je,{checked:i.sortedAsc,onChange:o,name:"sortedAsc"}),label:"Sorted (ascending)",className:"checkbox"}),Object(c.jsx)(Re.a,{control:Object(c.jsx)(Je,{checked:i.sortedDesc,onChange:o,name:"sortedDesc"}),label:"Sorted (descending)",className:"checkbox"}),e]})};const et=X.bind(null,12,1,50),tt=et(),nt={random:!1,sortedAsc:!1,sortedDesc:!1},at=Object(De.a)({root:{color:"#2289ff","&$checked":{color:"#027aff"}},checked:{}})((e=>Object(c.jsx)(Le.a,{...e})));var rt=function(){const[e,t]=Object(a.useState)(null),[n,r]=Object(a.useState)(tt),[i,s]=Object(a.useState)({random:!0,sortedAsc:!1,sortedDesc:!1}),o=e=>{switch(e.target.name){case"sortedAsc":r([...n].sort((function(e,t){return+e-+t})));break;case"sortedDesc":r([...n].sort((function(e,t){return+t-+e})));break;case"random":r(et());break;case"bestCase":r(K(Math.floor(10*Math.random()),25+Math.floor(25*Math.random())))}s({...nt,[e.target.name]:!0})};return Object(a.useEffect)((()=>{document.getElementById("startBtnGrp").click()}),[i]),Object(c.jsxs)(c.Fragment,{children:[Object(c.jsx)("div",{className:"form",children:Object(c.jsx)(Me,{name:"msort_lista_td",buttonName:"Reset",mode:"sort",formClassName:"formLeft",DEFAULT_VAL:n,SET_VAL:r,REFRESH_FUNCTION:i.sortedAsc?()=>et().sort((function(e,t){return+e-+t})):i.sortedDesc?()=>et().sort((function(e,t){return+t-+e})):i.bestCase?()=>K(Math.floor(10*Math.random()),25+Math.floor(25*Math.random())):void 0,ALGORITHM_NAME:"Merge Sort (lists)",EXAMPLE:"Please follow the example provided: 0,1,2,3,4",setMessage:t})}),Object(c.jsx)("span",{className:"generalText",children:"Choose input format: \xa0\xa0"}),Object(c.jsx)(Re.a,{control:Object(c.jsx)(at,{checked:i.random,onChange:o,name:"random"}),label:"Random",className:"checkbox"}),Object(c.jsx)(Re.a,{control:Object(c.jsx)(at,{checked:i.sortedAsc,onChange:o,name:"sortedAsc"}),label:"Sorted (ascending)",className:"checkbox"}),Object(c.jsx)(Re.a,{control:Object(c.jsx)(at,{checked:i.sortedDesc,onChange:o,name:"sortedDesc"}),label:"Sorted (descending)",className:"checkbox"}),e]})},it=n(200);const st={Cell:e=>{let{value:t,row:{index:n},column:{id:r},updateData:i,algo:s}=e;const[o,l]=Object(a.useState)(t||0);return Object(a.useEffect)((()=>{l(t||0)}),[t]),Object(c.jsx)("input",{value:o,onChange:e=>{let t=e.target.value;(/^\d+$/.test(t)||""===t)&&(t=String(parseInt(t,10)||0),"transitiveClosure"!==s&&"BFS"!==s&&"DFS"!==s||(parseInt(t)>1&&(t="1"),parseInt(t)<0&&(t="0"),n===parseInt(r[3])&&(t="1")),"transitiveClosure"!=s&&n===parseInt(r[3])&&(t="0"),""===t&&(t="0"),l(t),i(n,r,t))},onBlur:()=>{}})}};var ot=function(e){let{columns:t,data:n,updateData:a,algo:r}=e;const{getTableProps:i,getTableBodyProps:s,headerGroups:o,prepareRow:l,rows:d}=Object(it.useTable)({columns:t,data:n,defaultColumn:st,updateData:a,algo:r});let h=0;return Object(c.jsx)("div",{className:"table",children:Object(c.jsxs)("table",{...i(),children:[Object(c.jsx)("thead",{children:o.map((e=>Object(c.jsxs)("tr",{...e.getHeaderGroupProps(),children:[Object(c.jsx)("th",{children:"Node"}),e.headers.map((e=>Object(c.jsx)("th",{...e.getHeaderProps(),children:e.render("Header")})))]})))}),Object(c.jsx)("tbody",{...s(),children:d.map((e=>(l(e),Object(c.jsxs)("tr",{...e.getRowProps(),children:[Object(c.jsx)("th",{...void(h+=1),children:h}),e.cells.map((e=>Object(c.jsx)("td",{...e.getCellProps(),children:e.render("Cell")})))]}))))})]})})};n(234);n.p;n.p;var lt=n(93);let dt=["Random"];const ct=[6],ht=["1-1"],ut=["1-2"],pt="Please follow example: 1-1,3-4,4-1,6-6 giving the X-Y coordinates for each of the nodes in the graph.",gt="Please follow example: 1-2,1-3,2-3,3-2-6,3-4-7 giving NodeA-NodeB-Weight for each in the graph; -Weight is optional and defaults to 1.";const mt=(e,t,n,a)=>{const r=e.replace(/\s+/g,"");if(yt(r,2,2)){const e=r.split(",").map((e=>e.trim().split("-"))),t=e.length;let n=[];for(let a=0;a<e.length;a++){const t=e[a];n.push({col0:t[0],col1:t[1]})}return[n,t]}return a(J(n,pt)),[null,t]},ft=(e,t,n,a,r,i)=>{const s=e.replace(/\s+/g,"");if(yt(s,2,3)){let e=s.split(",").map((e=>e.trim().split("-")));e.length;let r=[];for(let i=0;i<t;i+=1){const s={};for(let r=0;r<t;r+=1)s["col".concat(r)]=At(e,i+1,r+1,n,a);r.push(s)}return r}return r(J(i,gt)),null};var bt=function(e){let{defaultSize:t,defaultStart:n,defaultEnd:r,defaultHeur:i,graphEgs:s,min:o,max:l,name:d,symmetric:h,mode:u,setMessage:p,ALGORITHM_NAME:g,EXAMPLE:m,EXAMPLE2:f,unweighted:b}=e,y=1+s.length,A=xt(s),x=vt(s),v=jt(s),j=wt(s);const[w,E]=Object(a.useState)(s[0].size),[k,N]=Object(a.useState)(0),[O,I]=Object(a.useState)(0),C=Object(a.useMemo)((()=>(()=>{const e=[];return e.push({Header:"X",accessor:"col".concat(0)}),e.push({Header:"Y",accessor:"col".concat(1)}),e})()),[w]),S=Object(a.useMemo)((()=>$(w)),[w]),{dispatch:M}=Se(),[B,T]=Object(a.useState)((()=>mt(s[0].coords,s[0].size,g,p)[0])),[R,L]=Object(a.useState)(B),[D,P]=Object(a.useState)((()=>ft(s[0].edges,s[0].size,b,h,p,g))),[F,H]=Object(a.useState)(D),[_,G]=Object(a.useState)(s[0].coords),[V,z]=Object(a.useState)(s[0].edges),[Q,X]=Object(a.useState)(n),[Y,K]=Object(a.useState)(Et(r)),[Z,ae]=Object(a.useState)(null===r?[]:r),[re,ie]=Object(a.useState)(1);Object(a.useEffect)((()=>{ge()}),[w,Q,Z,B,D,k,O]);const se=(e,t)=>{if(ie(e=(e+1)%y),0===t&&(t=A[e]),E(t),t<Q&&X(t),Z.some((e=>e>t))){let e=Z.filter((e=>e<=t));0===e.length&&"A* Algorithm"===g&&(e=[t]),K(Et(e)),ae(e)}if(0===e){const e=ee(t,1,10,h,b),n=((e,t,n)=>{let a=[],r=0,i=0,s=0,o=0;for(let l=0;l<e;l+=1){const d={},c=.9;let h=q(Math.floor(t+c*(n-t)*l/e),Math.ceil(n-c*(n-t)*(e-1-l)/e));d.col0="".concat(h);let u=0,p=0;do{u=q(t,n/3),p++}while(p<20&&(te(h,u,r,i)<5||te(h,u,s,o)<5));d.col1="".concat(u),s=r,o=i,r=h,i=u,a.push(d)}return a})(t,o,l);T(n),G(ue(n)),P(e),z(pe(e,t))}else{G(x[e]),z(v[e]);let[n,a]=mt(x[e],t,g,p);null!==n&&T(n),P(ft(v[e],t,b,h,p,g))}},oe=e=>{if(!(e<1)){if(e<Q&&X(e),Z.some((t=>t>e))){let t=Z.filter((t=>t<=e));0===t.length&&"A* Algorithm"===g&&(t=[e]),K(Et(t)),ae(t)}p(null),se(-1,e)}},le=e=>{e<1||e>w||(p(null),X(e))},de=e=>{0===(e=(e+w+1)%(w+1))&&"A* Algorithm"===g&&(e=w),p(null),ae([e])},ce=(e,t,n)=>{console.log(["moveNode",e,t,n]);const a=B.map(((a,r)=>r===e?{...B[e],col0:t.toString(),col1:n.toString()}:a));T(a),G(ue(a))},he=()=>{const e=[];return B.forEach((t=>{const n=[];for(const[e,a]of Object.entries(t)){if(!U(a))return void p(J(g,m));{const e=parseInt(a,10);n.push(e)}}e.push(n)})),e},ue=e=>{let t="";return e.forEach((e=>{t+=e.col0+"-"+e.col1+","})),t=t.substring(0,t.length-1),t},pe=(e,t)=>{let n="";for(var a=0;a<t;a++)for(const[t,r]of Object.entries(e[a]))if("0"!==r){const e=parseInt(t.substring(3,t.length,10));a==e||h&&e<a||(n+=(a+1).toString()+"-"+(e+1).toString(),"1"!==r&&(n+="-"+r),n+=",")}return n=n.substring(0,n.length-1),n},ge=()=>{ke(),p(null);const e=he(),t=(()=>{const e=[];D.forEach((t=>{const n=[];for(const[e,a]of Object.entries(t)){if(!U(a))return void p(J(g,m));{const e=parseInt(a,10);n.push(e)}}e.push(n)}));const t=he();if(t.length!==e.length||t.length!==e[0].length||2!==t[0].length)return[];const n=[];for(let a=0;a<t.length;a++){const r=[];for(let n=0;n<t.length;n++){let i=0;0!==e[a][n]&&(i=0===k?te(t[n][0],t[n][1],t[a][0],t[a][1]):1===k?ne(t[n][0],t[n][1],t[a][0],t[a][1]):e[a][n]),r.push(i)}n.push(r)}return n.length!==w||n[0].length!==w?[]:"prim"===d&&!1===W(n)?(p(J(g,f)),[]):n})();0!==t.length?M(Bl.RUN_ALGORITHM,{name:d,mode:u,size:w,startNode:Q,endNodes:Z,heuristicFn:me,coordsMatrix:e,edgeValueMatrix:t,moveNode:ce}):p(J(g,m))},me=(e,t,n,a)=>0===O?te(e,t,n,a):ne(e,t,n,a);let fe="";null!==r&&(fe=Object(c.jsxs)("div",{className:"sLineButtonContainer",children:[Object(c.jsx)("button",{className:"endBtn",onClick:()=>de(Z[0]-1),children:"\u2212"}),Object(c.jsxs)("span",{className:"size",children:["End: ",Z[0]]}),Object(c.jsx)("button",{className:"sizeBtn",onClick:()=>de(Z[0]+1),children:"+"})]}));let be="";b||(be=Object(c.jsxs)("button",{className:"algorithmBtn",onClick:()=>{return e=k,p(null),void N((e+1)%3);var e},children:["Weights: ",["Euclidean","Manhattan","As input"][k]]}));let ye="";return null!==i&&(ye=Object(c.jsxs)("button",{className:"algorithmBtn",onClick:()=>{return e=O,p(null),void I((e+1)%2);var e},children:["Heuristic: ",["Euclidean","Manhattan"][O]]})),Object(c.jsxs)(c.Fragment,{children:[Object(c.jsx)("div",{className:"matrixButtonContainer",children:Object(c.jsxs)("div",{className:"sLineButtonContainer",children:[Object(c.jsxs)("div",{className:"form",children:[Object(c.jsx)("button",{className:"graphChoiceBtn",onClick:()=>se(re,0),children:j[re]}),Object(c.jsxs)("div",{className:"sLineButtonContainer",children:[Object(c.jsx)("button",{className:"sizeBtn",onClick:()=>oe(w-1),children:"\u2212"}),Object(c.jsxs)("span",{className:"size",children:["Size: ",w]}),Object(c.jsx)("button",{className:"sizeBtn",onClick:()=>oe(w+1),children:"+"})]}),be,ye,Object(c.jsxs)("div",{className:"sLineButtonContainer",children:[Object(c.jsx)("button",{className:"startBtn",onClick:()=>le(Q-1),children:"\u2212"}),Object(c.jsxs)("span",{className:"size",children:["Start: ",Q]}),Object(c.jsx)("button",{className:"sizeBtn",onClick:()=>le(Q+1),children:"+"})]}),fe]}),"",Object(c.jsx)("div",{className:"disabled",children:Object(c.jsx)(Me,{name:"graphCoords",buttonName:"Set\xa0X-Y\xa0Coordinates",formClassName:"formLeft",mode:"search",handleSubmit:e=>{e.preventDefault(),p(null);const[t,n]=mt(e.target[0].value,w,g,p);if(null!==t&&T(t),E(n),n<Q&&X(n),Z.some((e=>e>n))){let e=Z.filter((e=>e<=n));0===e.length&&"A* Algorithm"===g&&(e=[n]),K(Et(e)),ae(e)}let a=V;"string"!==typeof V&&(a=V.join()),n!==w&&P(ft(a,n,b,h,p,g))},DEFAULT_VAL:_,SET_VAL:G,REFRESH_FUNCTION:()=>"1,1",ALGORITHM_NAME:g,EXAMPLE:pt,setMessage:p})}),Object(c.jsx)("div",{className:"disabled",children:Object(c.jsx)(Me,{name:"graphEdges",buttonName:"Set\xa0Edges/Weights",formClassName:"formLeft",mode:"search",handleSubmit:e=>{e.preventDefault(),p(null),P(ft(e.target[0].value,w,b,h,p,g))},DEFAULT_VAL:V,SET_VAL:z,REFRESH_FUNCTION:()=>"1-2",ALGORITHM_NAME:g,EXAMPLE:gt,setMessage:p})})]})}),Object(c.jsxs)("div",{className:"matrixContainer",children:[Object(c.jsxs)("div",{className:"coord",children:[Object(c.jsx)("text",{className:"titles",children:" Coordinates (X,Y) "}),Object(c.jsx)(ot,{columns:C,data:B,updateData:(e,t,n)=>{const a=B.map(((a,r)=>r===e?{...B[e],[t]:n}:a));T(a),G(ue(a))},algo:d})]}),Object(c.jsxs)("div",{className:"edge",children:[Object(c.jsx)("text",{className:"titles",children:" Edges (0,1)"}),Object(c.jsx)(ot,{columns:S,data:D,updateData:(e,t,n)=>{let a=-1,r="colXYZZY";h&&(a=parseInt(t.substring(3,t.length,10)),r="col"+e);const i=D.map(((i,s)=>s===e?{...D[e],[t]:n}:s===a?{...D[a],[r]:n}:i));P(i),z(pe(i,w))},algo:d})]})]})]})};function yt(e,t,n){if(!e)return!1;if(!/^[0-9,-\s]+$/.test(e))return!1;const a=e.split(",").map((e=>e.trim()));for(let r=0;r<a.length;r++){const e=a[r].split("-");if(e.length<t||e.length>n)return!1;if(e.some((e=>isNaN(e))))return!1}return!0}function At(e,t,n,a,r){for(var i=0;i<e.length;i++){const s=e[i][0],o=e[i][1];let l=2==e[i].length?"1":e[i][2];if(a&&l>0&&(l="1"),t==s&&n==o)return l;if(r&&t==o&&n==s)return l}return"0"}const xt=e=>{let t=[...ct];const n=e.length;for(let a=0;a<n;a++){const n=e[a];t.push(n.size)}return t},vt=e=>{let t=[...ht];const n=e.length;for(let a=0;a<n;a++){const n=e[a];t.push(n.coords)}return t},jt=e=>{let t=[...ut];const n=e.length;for(let a=0;a<n;a++){const n=e[a];t.push(n.edges)}return t},wt=e=>{let t=[...dt];const n=e.length;for(let a=0;a<n;a++){const n=e[a];t.push(n.name)}return t},Et=e=>{if(null===e)return"";let t="";return e.forEach((e=>{t+=e+","})),t=t.substring(0,t.length-1),t},kt=[{name:"Graph 1",size:14,coords:"4-3,2-7,7-11,9-3,12-6,13-2,12-16,17-2,20-4,34-4,26-9,30-6,34-10,38-5",edges:"1-2-3,1-4-6,2-3-4,3-4-2,3-5-4,4-5-3,5-6-2,5-7-10,6-8-5,7-11-10,8-9-6,9-10-3,10-12-8,11-12-5,12-13-3,13-14-4"},{name:"Graph 2",size:17,coords:"2-13,6-6,7-11,9-15,12-2,15-6,16-12,19-5,25-7,23-16,28-14,29-10,35-13,36-6,40-15, 39-2,42-10",edges:"1-2-10,1-4-4,2-3-6,3-4-10,3-5-5,4-7-3,5-6-7,6-7-8,7-8-2,7-9,8-9-3,9-10-5,9-11-7, 10-11-7,11-13-4,12-13-8,12-14-6,13-14-7,13-15-7,14-16-6,15-16-2,15-17-5,16-17-2"}];var Nt=function(){const[e,t]=Object(a.useState)(null);return Object(c.jsxs)(c.Fragment,{children:[Object(c.jsx)(bt,{name:"prim_old",mode:"find",defaultSize:5,defaultStart:5,defaultEnd:null,defaultHeur:null,min:1,max:49,graphEgs:kt,symmetric:!0,ALGORITHM_NAME:"Prim's (simpler code)",EXAMPLE:"Please enter positive edge weights (or 0 for no edge)",EXAMPLE2:"Please enter the symmetrical value in matrix",setMessage:t}),e]})};const Ot=[{name:"Graph 1",size:14,coords:"4-3,2-7,7-11,9-3,12-6,13-2,12-16,17-2,20-4,34-4,26-9,30-6,34-10,38-5",edges:"1-2-3,1-4-6,2-3-4,3-4-2,3-5-4,4-5-3,5-6-2,5-7-10,6-8-5,7-11-10,8-9-6,9-10-3,10-12-8,11-12-5,12-13-3,13-14-4"},{name:"Graph 2",size:17,coords:"2-13,6-6,7-11,9-15,12-2,15-6,16-12,19-5,25-7,23-16,28-14,29-10,35-13,36-6,40-15, 39-2,42-10",edges:"1-2-10,1-4-4,2-3-6,3-4-10,3-5-5,4-7-3,5-6-7,6-7-8,7-8-2,7-9,8-9-3,9-10-5,9-11-7, 10-11-7,11-13-4,12-13-8,12-14-6,13-14-7,13-15-7,14-16-6,15-16-2,15-17-5,16-17-2"}];var It=function(){const[e,t]=Object(a.useState)(null);return Object(c.jsxs)(c.Fragment,{children:[Object(c.jsx)(bt,{name:"prim",mode:"find",defaultSize:5,defaultStart:5,defaultEnd:null,defaultHeur:null,min:1,max:49,graphEgs:Ot,symmetric:!0,ALGORITHM_NAME:"New Prim's",EXAMPLE:"Please enter positive edge weights (or 0 for no edge)",EXAMPLE2:"Please enter the symmetrical value in matrix",setMessage:t}),e]})};const Ct=[{name:"Graph 1",size:14,coords:"4-3,2-7,7-11,9-3,12-6,13-2,12-16,17-2,20-4,34-4,26-9,30-6,34-10,38-5",edges:"1-2-3,1-4-6,2-3-4,3-4-2,3-5-4,4-5-3,5-6-2,5-7-10,6-8-5,7-11-10,8-9-6,9-10-3,10-12-8,11-12-5,12-13-3,13-14-4"},{name:"Graph 2",size:17,coords:"2-13,6-6,7-11,9-15,12-2,15-6,16-12,19-5,25-7,23-16,28-14,29-10,35-13,36-6,40-15, 39-2,42-10",edges:"1-2-10,1-4-4,2-3-6,3-4-10,3-5-5,4-7-3,5-6-7,6-7-8,7-8-2,7-9,8-9-3,9-10-5,9-11-7, 10-11-7,11-13-4,12-13-8,12-14-6,13-14-7,13-15-7,14-16-6,15-16-2,15-17-5,16-17-2"}];var St=function(){const[e,t]=Object(a.useState)(null);return Object(c.jsxs)(c.Fragment,{children:[Object(c.jsx)(bt,{name:"kruskal",mode:"find",defaultSize:5,defaultStart:null,defaultEnd:null,defaultHeur:null,min:1,max:49,graphEgs:Ct,symmetric:!0,ALGORITHM_NAME:"Kruskal's",EXAMPLE:"Please enter positive edge weights (or 0 for no edge)",EXAMPLE2:"Please enter the symmetrical value in matrix",setMessage:t}),e]})};n(236);const Mt=["mousedown","click","mouseup"];var Bt=function(e){let{defaultSize:t,min:n,max:r,name:i,symmetric:s,mode:o,setMessage:l,ALGORITHM_NAME:d,EXAMPLE:h,EXAMPLE2:u,unweighted:p}=e;const[g,m]=Object(a.useState)(t),[f,b]=Object(a.useState)(t),[y,A]=Object(a.useState)(1),x=Object(a.useMemo)((()=>$(g)),[g]),{dispatch:v}=Se(),[j,w]=Object(a.useState)((()=>ee(g,n,r,s,p))),[E,k]=Object(a.useState)(j),[N,O]=Object(a.useState)("Restart");Object(a.useEffect)((()=>{const e=ee(g,n,r,s,p);w(e),k(e)}),[g,n,r,s,p]),Object(a.useEffect)((()=>{!function(e){Mt.forEach((t=>e.dispatchEvent(new MouseEvent(t,{view:window,bubbles:!0,cancelable:!0,buttons:1}))))}(document.querySelector('button[id="startBtnGrp"]'))}),[]);const I=e=>{e>=1&&e<=10&&(l(null),m(e),f>e&&b(e),y>e&&A(e))};Object(a.useEffect)((()=>{C()}),[j]);const C=()=>{ke(),l(null);const e=(()=>{const e=[];return j.forEach((t=>{const n=[];for(const[e,a]of Object.entries(t)){if(!U(a))return void l(J(d,h));{const e=parseInt(a,10);n.push(e)}}e.push(n)})),e.length!==g||e[0].length!==g?[]:"primOld"!==i&&"primNew"!==i||!1!==W(e)?e:(l(J(d,u)),[])})();0!==e.length?v(Bl.RUN_ALGORITHM,{name:i,mode:o,size:g,matrix:e,endNode:f,startNode:y}):l(J(d,h))};return Object(a.useEffect)((()=>{C()}),[y]),Object(a.useEffect)((()=>{C()}),[f]),Object(c.jsxs)("div",{className:"matrixContainer",children:[Object(c.jsxs)("div",{className:"matrixButtonContainer",children:[("BFS"===i||"DFS"===i||"dijkstra"===i||"aStar"===i)&&Object(c.jsxs)("div",{className:"startNodeInputContainer",children:[Object(c.jsx)("label",{htmlFor:"startNodeCounter",className:"startNodeLabel",children:"Start Node: "}),Object(c.jsx)("button",{onClick:()=>{y>1&&A((e=>e-1))},disabled:y<=1,className:"arrowBtn pointerCursor ".concat(y<=1?"disabledBtn":""),children:"-"}),Object(c.jsxs)("span",{id:"startNodeCounter",className:"startNodeValue",children:[" ",y," "]}),Object(c.jsx)("button",{onClick:()=>{y<g&&A((e=>e+1))},disabled:y>=g,className:"arrowBtn pointerCursor ".concat(y>=g?"disabledBtn":""),children:"+"})]}),("BFS"===i||"DFS"===i||"aStar"===i||"dijkstra"===i)&&Object(c.jsxs)("div",{className:"endNodeInputContainer",children:[Object(c.jsx)("label",{htmlFor:"endNodeCounter",className:"endNodeLabel",children:"End Node: "}),Object(c.jsx)("button",{onClick:()=>{f>1&&b((e=>e-1))},disabled:f<=1,className:"arrowBtn pointerCursor ".concat(f<=1?"disabledBtn":""),children:"-"}),Object(c.jsxs)("span",{id:"endNodeCounter",className:"endNodeValue",children:[" ",f," "]}),Object(c.jsx)("button",{onClick:()=>{f<g&&b((e=>e+1))},disabled:f>=g,className:"arrowBtn pointerCursor ".concat(f>=g?"disabledBtn":""),children:"+"})]}),Object(c.jsx)("button",{className:"matrixBtn ".concat(10==g?"disabledText":""),onClick:()=>I(g+1),children:"Increase Graph Size"}),Object(c.jsx)("button",{className:"matrixBtn ".concat(1==g?"disabledText":""),onClick:()=>I(g-1),children:"Decrease Graph Size"}),Object(c.jsx)("button",{className:"matrixBtn",onClick:()=>{l(null),w(E)},children:"Revert"}),Object(c.jsx)("button",{className:"matrixBtn",onClick:C,id:"startBtnGrp",children:N})]}),Object(c.jsx)(ot,{columns:x,data:j,updateData:(e,t,n)=>{if(j[e]&&j[e][t]===n)return;const a=JSON.parse(JSON.stringify(j));if(a[e]&&(a[e][t]=n),"transitiveClosure"!==i){const r="col".concat(e),i=parseInt(t.replace("col",""),10);a[i]&&(a[i][r]=n)}w(a)},algo:i})]})};var Tt=function(){const[e,t]=Object(a.useState)(null);return Object(c.jsxs)(c.Fragment,{children:[Object(c.jsx)(Bt,{name:"transitiveClosure",mode:"tc",defaultSize:4,min:0,max:1,ALGORITHM_NAME:"Transitive Closure",EXAMPLE:"Please follow the example provided: 0,1",setMessage:t}),e]})};const Rt=["mousedown","click","mouseup"];var Lt=function(e){const{formClassName:t,buttonName:n,string:r,stringOnChange:i,pattern:s,patternOnChange:o,handleSubmit:l,disabled:d}=e,{algorithm:h}=Object(a.useContext)(Pl);return Object(a.useEffect)((()=>{!function(e){Rt.forEach((t=>e.dispatchEvent(new MouseEvent(t,{view:window,bubbles:!0,cancelable:!0,buttons:1}))))}(document.querySelector('button[id="startBtnGrp"]'))}),[]),Object(c.jsx)("form",{className:t,onSubmit:l,children:Object(c.jsxs)("div",{className:"outerInput",children:[Object(c.jsxs)("label",{className:"inputText",children:[Object(c.jsx)("div",{className:"stringContainer",children:"String"}),Object(c.jsx)("div",{className:"inputContainer",children:Object(c.jsx)("input",{type:"text",value:r,onChange:i})})]}),Object(c.jsxs)("label",{className:"inputText",children:[Object(c.jsx)("div",{className:"stringContainer",children:"Pattern"}),Object(c.jsx)("div",{className:"inputContainer",children:Object(c.jsx)("input",{type:"text",value:s,onChange:o})})]}),Object(c.jsx)("div",{className:"btnGrp",children:Object(c.jsx)(ve,{className:d?"blueWordBtnDisabled":"blueWordBtn",onClick:()=>{"Quicksort"===h.name&&(sessionStorage.setItem("isPivot",!1),sessionStorage.setItem("quicksortPlay",!1)),ke()},id:"startBtnGrp",type:"submit",disabled:d,children:n})})]})})};var Dt=function(e){let{name:t,buttonName:n,mode:a,DEFAULT_STRING:r,SET_STRING:i,DEFAULT_PATTERN:s,SET_PATTERN:o,ALGORITHM_NAME:l,EXAMPLE:d,formClassName:h,handleSubmit:u,setMessage:p}=e;const{dispatch:g,disabled:m}=Se([r,s]);return Object(c.jsx)(Lt,{formClassName:h,name:l,buttonName:n,string:r,pattern:s,disabled:m,stringInputName:"String",patternInputName:"Pattern",stringOnChange:e=>{i(e.target.value)},patternOnChange:e=>{o(e.target.value)},handleSubmit:u&&"function"===typeof u?u:e=>{e.preventDefault();const n=e.target[0].value,r=e.target[1].value;Q(n)&&Q(r)?(g(Bl.RUN_ALGORITHM,{name:t,mode:a,nodes:[n,r]}),p(Z())):p(J(l,d))}})};var Pt=function(){const[e,t]=Object(a.useState)(null),[n,r]=Object(a.useState)("dcaccdddabddac"),[i,s]=Object(a.useState)("ddac");return Object(c.jsxs)(c.Fragment,{children:[Object(c.jsx)("div",{className:"form",children:Object(c.jsx)(Dt,{name:"bruteForceStringSearch",buttonName:"SEARCH",mode:"search",formClassName:"formLeft",DEFAULT_STRING:n,DEFAULT_PATTERN:i,SET_STRING:r,SET_PATTERN:s,ALGORITHM_NAME:"Brute force String Search",EXAMPLE:"Enter lower case alphabetic character or space.",setMessage:t})}),Object(c.jsx)("text",{className:"message",children:e})]})};const Ft=X.bind(null,12,1,50),Ht=Ft(),_t={random:!1,sortedAsc:!1,bestCase:!1,sortedDesc:!1},Gt=Object(De.a)({root:{color:"#2289ff","&$checked":{color:"#027aff"}},checked:{}})((e=>Object(c.jsx)(Le.a,{...e})));var Vt=function(){const[e,t]=Object(a.useState)(null),[n,r]=Object(a.useState)(Ht),[i,s]=Object(a.useState)({random:!0,sortedAsc:!1,bestCase:!1,sortedDesc:!1}),o=e=>{switch(e.target.name){case"sortedAsc":r([...n].sort((function(e,t){return+e-+t})));break;case"sortedDesc":r([...n].sort((function(e,t){return+t-+e})));break;case"random":r(Ft());break;case"bestCase":r(K(Math.floor(10*Math.random()),25+Math.floor(25*Math.random())))}s({..._t,[e.target.name]:!0})};return Object(a.useEffect)((()=>{document.getElementById("startBtnGrp").click()}),[i]),Object(c.jsxs)(c.Fragment,{children:[Object(c.jsx)("div",{className:"form",children:Object(c.jsx)(Me,{name:"quickSortM3",buttonName:"Reset",mode:"sort",formClassName:"formLeft",DEFAULT_VAL:n,SET_VAL:r,REFRESH_FUNCTION:i.sortedAsc?()=>Ft().sort((function(e,t){return+e-+t})):i.sortedDesc?()=>Ft().sort((function(e,t){return+t-+e})):i.bestCase?()=>K(Math.floor(10*Math.random()),25+Math.floor(25*Math.random())):void 0,ALGORITHM_NAME:"Quick Sort Median of Three",EXAMPLE:"Please follow the example provided: 0,1,2,3,4",setMessage:t})}),Object(c.jsx)("span",{className:"generalText",children:"Choose input format: \xa0\xa0"}),Object(c.jsx)(Re.a,{control:Object(c.jsx)(Gt,{checked:i.random,onChange:o,name:"random"}),label:"Random",className:"checkbox"}),Object(c.jsx)(Re.a,{control:Object(c.jsx)(Gt,{checked:i.sortedAsc,onChange:o,name:"sortedAsc"}),label:"Sorted (ascending)",className:"checkbox"}),Object(c.jsx)(Re.a,{control:Object(c.jsx)(Gt,{checked:i.sortedDesc,onChange:o,name:"sortedDesc"}),label:"Sorted (descending)",className:"checkbox"}),e]})};var zt=function(){const[e,t]=Object(a.useState)(null),[n,r]=Object(a.useState)("dcaccdddabddac"),[i,s]=Object(a.useState)("ddac");return Object(c.jsxs)(c.Fragment,{children:[Object(c.jsx)("div",{className:"form",children:Object(c.jsx)(Dt,{name:"horspoolStringSearch",buttonName:"Search",mode:"search",formClassName:"formLeft",DEFAULT_STRING:n,DEFAULT_PATTERN:i,SET_STRING:r,SET_PATTERN:s,ALGORITHM_NAME:"Horspool String Search",EXAMPLE:"Enter lower case alphabetic character or space.",setMessage:t})}),e]})};const Qt=["1","2","3","4","5","6","7","8","9","10"],Ut=["1-2","3-4","2-4","1-5","6-8","3-6"],Wt="Union Find",qt="Please follow the example provided: 2. The single digit should be between 1 and 10.",Xt="Please follow the example provided: 5-7,8-5,9-8,3-9,5-2. All digits should be between 1 and 10, '-' should be used to separate the two digits, and ',' should be used to separate each union operation.",Yt=Object(De.a)({root:{color:"#2289ff","&$checked":{color:"#027aff"}},checked:{}})((e=>Object(c.jsx)(Le.a,{...e})));var Kt=function(){const[e,t]=Object(a.useState)(null),{algorithm:n,dispatch:r}=Object(a.useContext)(Pl),[i,s]=Object(a.useState)(Ut),[o,l]=Object(a.useState)(!0),d=()=>{l((e=>!e))};return Object(a.useEffect)((()=>{document.getElementById("startBtnGrp").click()}),[o]),Object(c.jsxs)(c.Fragment,{children:[Object(c.jsxs)("div",{className:"form",children:[Object(c.jsx)(Me,{name:"unionFind",buttonName:"Union",mode:"union",formClassName:"formLeft",DEFAULT_VAL:i,SET_VAL:s,handleSubmit:e=>{e.preventDefault();const n=e.target[0].value.replace(/\s+/g,"");if(function(e){if(!e)return!1;if(!/^[0-9,-\s]+$/.test(e))return!1;const t=e.split(",").map((e=>e.trim()));for(let n=0;n<t.length;n++){const e=t[n].split("-");if(2!==e.length)return!1;if(e.some((e=>isNaN(e)||!Qt.includes(e))))return!1}return!0}(n)){const e={arg1:n.split(",").map((e=>e.trim().split("-").map(Number))),arg2:o};r(Bl.RUN_ALGORITHM,{name:"unionFind",mode:"union",target:e}),t(Z())}else t(J(Wt,Xt))},REFRESH_FUNCTION:()=>Ut,ALGORITHM_NAME:"Union",EXAMPLE:Xt,setMessage:t}),Object(c.jsx)(Pe,{name:"unionFind",buttonName:"Find",mode:"find",formClassName:"formRight",DEFAULT_VAL:"2",ALGORITHM_NAME:"Find",EXAMPLE:qt,handleSubmit:e=>{e.preventDefault();const a=e.target[0].value;if(!isNaN(a)&&Qt.includes(a)){const e={arg1:parseInt(a,10),arg2:o},i=n.chunker.visualisers;r(Bl.RUN_ALGORITHM,{name:"unionFind",mode:"find",visualiser:i,target:e}),t(Z())}else t(J(Wt,qt))},setMessage:t})]}),Object(c.jsx)("span",{className:"generalText",children:"Path compression: \xa0\xa0"}),Object(c.jsx)(Re.a,{control:Object(c.jsx)(Yt,{checked:!0===o,onChange:d,name:"on"}),label:"On",className:"checkbox"}),Object(c.jsx)(Re.a,{control:Object(c.jsx)(Yt,{checked:!1===o,onChange:d,name:"off"}),label:"Off",className:"checkbox"}),e]})};const Zt="2-3-4 Trees",Jt=Y(12,1,100),$t="Please follow the example provided: 1,2,3,4. Values should also be unique.",en="Please follow the example provided: 16.";var tn=function(){const{algorithm:e,dispatch:t}=Object(a.useContext)(Pl),[n,r]=Object(a.useState)(null),[i,s]=Object(a.useState)(Jt);return Object(c.jsxs)(c.Fragment,{children:[Object(c.jsxs)("div",{className:"form",children:[Object(c.jsx)(Me,{name:"TTFTree",buttonName:"Insert",mode:"insertion",formClassName:"formLeft",DEFAULT_VAL:i,handleSubmit:e=>{e.preventDefault();const n=e.target[0].value;if(function(e){const t=e.split(","),n=new Set(t);return t.length===n.size&&t.every((e=>U(e)))}(n)){let e=n.split(",").map(Number);t(Bl.RUN_ALGORITHM,{name:"TTFTree",mode:"insertion",nodes:e}),r(Z())}else r(J(Zt,$t))},SET_VAL:s,REFRESH_FUNCTION:()=>Y(12,1,100),ALGORITHM_NAME:"Insertion",EXAMPLE:$t,setMessage:r}),Object(c.jsx)(Pe,{name:"TTFTree",buttonName:"Search",mode:"search",formClassName:"formRight",handleSubmit:n=>{n.preventDefault();const a=n.target[0].value;if(U(a)){const n=parseInt(a,10);if(Object.prototype.hasOwnProperty.call(e,"visualisers")&&!e.visualisers.tree.instance.isEmpty()){const a=e.chunker.visualisers;t(Bl.RUN_ALGORITHM,{name:"TTFTree",mode:"search",visualiser:a,target:n}),r(Z())}else r(J(Zt,"Please build a tree before running search."))}else r(J(Zt,en))},DEFAULT_VAL:"2",ALGORITHM_NAME:"Search",EXAMPLE:en,setMessage:r})]}),n]})};const nn=[0],an=[{name:"Graph 1",size:14,coords:"4-3,2-7,7-11,9-3,12-6,13-2,12-16,17-2,20-4,34-4,26-9,30-6,34-10,38-5",edges:"1-2-3,1-4-6,2-3-4,3-4-2,3-5-4,4-5-3,5-6-2,5-7-10,6-8-5,7-11-10,8-9-6,9-10-3,10-12-8,11-12-5,12-13-3,13-14-4"},{name:"Graph 2",size:17,coords:"2-13,6-6,7-11,9-15,12-2,15-6,16-12,19-5,25-7,23-16,28-14,29-10,35-13,36-6,40-15, 39-2,42-10",edges:"1-2-10,1-4-4,2-3-6,3-4-10,3-5-5,4-7-3,5-6-7,6-7-8,7-8-2,7-9,8-9-3,9-10-5,9-11-7, 10-11-7,11-13-4,12-13-8,12-14-6,13-14-7,13-15-7,14-16-6,15-16-2,15-17-5,16-17-2"}];var rn=function(){const[e,t]=Object(a.useState)(null);return Object(c.jsxs)(c.Fragment,{children:[Object(c.jsx)(bt,{name:"dijkstra",mode:"find",defaultSize:5,defaultStart:5,defaultEnd:nn,defaultHeur:null,graphEgs:an,min:1,max:49,symmetric:!0,ALGORITHM_NAME:"Dijkstra's",EXAMPLE:"Please provided positive numbers: 0,1",EXAMPLE2:"Please enter the symmetrical value in matrix",setMessage:t}),e]})};const sn=[12],on=[{name:"Graph 1",size:14,coords:"4-3,2-7,7-11,9-3,12-6,13-2,12-16,17-2,20-4,34-4,26-9,30-6,34-10,38-5",edges:"1-2-3,1-4-6,2-3-4,3-4-2,3-5-4,4-5-3,5-6-2,5-7-10,6-8-5,7-11-10,8-9-6,9-10-3,10-12-8,11-12-5,12-13-3,13-14-4"},{name:"Graph 2",size:17,coords:"2-13,6-6,7-11,9-15,12-2,15-6,16-12,19-5,25-7,23-16,28-14,29-10,35-13,36-6,40-15, 39-2,42-10",edges:"1-2-10,1-4-4,2-3-6,3-4-10,3-5-5,4-7-3,5-6-7,6-7-8,7-8-2,7-9,8-9-3,9-10-5,9-11-7, 10-11-7,11-13-4,12-13-8,12-14-6,13-14-7,13-15-7,14-16-6,15-16-2,15-17-5,16-17-2"}];var ln=function(){const[e,t]=Object(a.useState)(null);return Object(c.jsxs)(c.Fragment,{children:[Object(c.jsx)(bt,{name:"aStar",mode:"find",defaultSize:14,defaultStart:5,defaultEnd:sn,heuristic:0,min:1,max:49,symmetric:!0,graphEgs:on,ALGORITHM_NAME:"A* Algorithm",EXAMPLE:"Please provided positive numbers: 0,1",EXAMPLE2:"Please enter the symmetrical value in matrix",setMessage:t}),e]})};const dn=[0],cn=[{name:"Graph 1",size:14,coords:"4-3,2-7,7-11,9-3,12-6,13-2,12-16,17-2,20-4,34-4,26-9,30-6,34-10,38-5",edges:"1-2-3,1-4-6,2-3-4,3-4-2,3-5-4,4-5-3,5-6-2,5-7-10,6-8-5,7-11-10,8-9-6,9-10-3,10-12-8,11-12-5,12-13-3,13-14-4"},{name:"Graph 2",size:17,coords:"2-13,6-6,7-11,9-15,12-2,15-6,16-12,19-5,25-7,23-16,28-14,29-10,35-13,36-6,40-15, 39-2,42-10",edges:"1-2-10,1-4-4,2-3-6,3-4-10,3-5-5,4-7-3,5-6-7,6-7-8,7-8-2,7-9,8-9-3,9-10-5,9-11-7, 10-11-7,11-13-4,12-13-8,12-14-6,13-14-7,13-15-7,14-16-6,15-16-2,15-17-5,16-17-2"}];var hn=function(){const[e,t]=Object(a.useState)(null);return Object(c.jsxs)(c.Fragment,{children:[Object(c.jsx)(bt,{name:"BFS",mode:"find",defaultSize:5,defaultStart:5,defaultEnd:dn,defaultHeur:null,min:1,max:49,symmetric:!0,graphEgs:cn,ALGORITHM_NAME:"BFS's",EXAMPLE:"Please provided positive numbers: 0,1",EXAMPLE2:"Please enter the symmetrical value in matrix",setMessage:t,unweighted:!0}),e]})};const un=[0],pn=[{name:"Graph 1",size:14,coords:"4-3,2-7,7-11,9-3,12-6,13-2,12-16,17-2,20-4,34-4,26-9,30-6,34-10,38-5",edges:"1-2-3,1-4-6,2-3-4,3-4-2,3-5-4,4-5-3,5-6-2,5-7-10,6-8-5,7-11-10,8-9-6,9-10-3,10-12-8,11-12-5,12-13-3,13-14-4"},{name:"Graph 2",size:17,coords:"2-13,6-6,7-11,9-15,12-2,15-6,16-12,19-5,25-7,23-16,28-14,29-10,35-13,36-6,40-15, 39-2,42-10",edges:"1-2-10,1-4-4,2-3-6,3-4-10,3-5-5,4-7-3,5-6-7,6-7-8,7-8-2,7-9,8-9-3,9-10-5,9-11-7, 10-11-7,11-13-4,12-13-8,12-14-6,13-14-7,13-15-7,14-16-6,15-16-2,15-17-5,16-17-2"}];var gn=function(){const[e,t]=Object(a.useState)(null);return Object(c.jsxs)(c.Fragment,{children:[Object(c.jsx)(bt,{name:"DFS",mode:"find",defaultSize:5,defaultStart:5,defaultHeur:null,defaultEnd:un,min:1,max:49,graphEgs:pn,symmetric:!0,ALGORITHM_NAME:"DFS's",EXAMPLE:"Please provided positive numbers: 0,1",EXAMPLE2:"Please enter the symmetrical value in matrix",setMessage:t,unweighted:!0}),e]})};const mn=[0],fn=[{name:"Graph 1",size:14,coords:"4-3,2-7,7-11,9-3,12-6,13-2,12-16,17-2,20-4,34-4,26-9,30-6,34-10,38-5",edges:"1-2-3,1-4-6,2-3-4,3-4-2,3-5-4,4-5-3,5-6-2,5-7-10,6-8-5,7-11-10,8-9-6,9-10-3,10-12-8,11-12-5,12-13-3,13-14-4"},{name:"Graph 2",size:17,coords:"2-13,6-6,7-11,9-15,12-2,15-6,16-12,19-5,25-7,23-16,28-14,29-10,35-13,36-6,40-15, 39-2,42-10",edges:"1-2-10,1-4-4,2-3-6,3-4-10,3-5-5,4-7-3,5-6-7,6-7-8,7-8-2,7-9,8-9-3,9-10-5,9-11-7, 10-11-7,11-13-4,12-13-8,12-14-6,13-14-7,13-15-7,14-16-6,15-16-2,15-17-5,16-17-2"}];var bn=function(){const[e,t]=Object(a.useState)(null);return Object(c.jsxs)(c.Fragment,{children:[Object(c.jsx)(bt,{name:"DFSrec",mode:"find",defaultSize:5,defaultStart:5,defaultHeur:null,defaultEnd:mn,min:1,max:49,graphEgs:fn,symmetric:!0,ALGORITHM_NAME:"DFSrec's",EXAMPLE:"Please provided positive numbers: 0,1",EXAMPLE2:"Please enter the symmetrical value in matrix",setMessage:t,unweighted:!0}),e]})};const yn=11,An=3457,xn=1429,vn=3,jn=23,wn=11,En=97,kn=1,Nn=2,On=3,In={Key:0,Value:1,Key2:2,Value2:3};function Cn(e,t,n,a){let r=n*An%a;return e.add(t,((e,t)=>{e.graph.updateNode(In.Value,t)}),[r]),r}function Sn(e,t,n,a,r,i){let s;switch(r){case"HashingLP":s=1;break;case"HashingDH":s=function(e,t,n,a){let r=n*xn%(a==yn?vn:jn)+1;return e.add(t,((e,t)=>{e.graph.updateNode(In.Value2,t)}),[r]),r}(e,t,n,a)}return"Insert"==i?e.add(t,((e,t)=>{let n=e.array.getKth();e.array.showKth([n,t])}),[s]):"Search"==i&&e.add(t,((e,t)=>{e.array.showKth(["N/A",t])}),[s]),s}const Mn="Hashing (linear probing)",Bn=Y(10,1,50),Tn={smallTable:!1,largeTable:!1},Rn=Object(De.a)({root:{color:"#2289ff","&$checked":{color:"#027aff"}},checked:{}})((e=>Object(c.jsx)(Le.a,{...e}))),Ln="Please enter only positive integers";var Dn=function(){const[e,t]=Object(a.useState)(null),{algorithm:n,dispatch:r}=Object(a.useContext)(Pl),[i,s]=Object(a.useState)(Bn),[o,l]=Object(a.useState)(2),[d,h]=Object(a.useState)({smallTable:!0,largeTable:!1}),u=e=>{h({...Tn,[e.target.name]:!0})};return Object(a.useEffect)((()=>{document.getElementById("startBtnGrp").click()}),[d]),Object(c.jsxs)(c.Fragment,{children:[Object(c.jsxs)("div",{className:"form",children:[Object(c.jsx)(Me,{name:"Hashing",buttonName:"INSERT",mode:"insertion",formClassName:"formLeft",DEFAULT_VAL:i,SET_VAL:s,REFRESH_FUNCTION:d.smallTable?()=>Y(10,1,50):d.largeTable?()=>Y(96,1,100):void 0,ALGORITHM_NAME:"Hashing Insertion",EXAMPLE:"PLACE HOLDER ERROR MESSAGE",handleSubmit:e=>{e.preventDefault();const n=e.target[0].value;if(z(n)){let e=n.split(",").map(Number),a=d.smallTable?wn:En;e.length<a?(r(Bl.RUN_ALGORITHM,{name:"HashingLP",mode:"insertion",hashSize:a,values:e}),t(Z())):t(J(Mn,"Please enter the right number of digits"))}else t(J(Mn,Ln))},setMessage:t}),Object(c.jsx)(Pe,{name:"Hashing",buttonName:"SEARCH",mode:"search",formClassName:"formRight",DEFAULT_VAL:2,SET_VAL:l,ALGORITHM_NAME:"Hashing Search",handleSubmit:e=>{e.preventDefault();const a=e.target[0].value;let i=d.smallTable?wn:En;const s=n.chunker.visualisers;if(U(a)){const e=parseInt(a);r(Bl.RUN_ALGORITHM,{name:"HashingLP",mode:"search",hashSize:i,visualisers:s,target:e}),t(Z())}else t(J(Mn,Ln))},setMessage:t})]}),Object(c.jsx)(Re.a,{control:Object(c.jsx)(Rn,{checked:d.smallTable,onChange:u,name:"smallTable"}),label:"Small Table",className:"checkbox"}),Object(c.jsx)(Re.a,{control:Object(c.jsx)(Rn,{checked:d.largeTable,onChange:u,name:"largeTable"}),label:"Large Table",className:"checkbox"}),e]})};const Pn="Hashing (double hashing)",Fn=Y(10,1,50),Hn={smallTable:!1,largeTable:!1},_n=Object(De.a)({root:{color:"#2289ff","&$checked":{color:"#027aff"}},checked:{}})((e=>Object(c.jsx)(Le.a,{...e}))),Gn="Please enter only positive integers";var Vn=function(){const[e,t]=Object(a.useState)(null),{algorithm:n,dispatch:r}=Object(a.useContext)(Pl),[i,s]=Object(a.useState)(Fn),[o,l]=Object(a.useState)(2),[d,h]=Object(a.useState)({smallTable:!0,largeTable:!1}),u=e=>{h({...Hn,[e.target.name]:!0})};return Object(a.useEffect)((()=>{document.getElementById("startBtnGrp").click()}),[d]),Object(c.jsxs)(c.Fragment,{children:[Object(c.jsxs)("div",{className:"form",children:[Object(c.jsx)(Me,{name:"Hashing",buttonName:"INSERT",mode:"insertion",formClassName:"formLeft",DEFAULT_VAL:i,SET_VAL:s,REFRESH_FUNCTION:d.smallTable?()=>Y(10,1,50):d.largeTable?()=>Y(96,1,100):void 0,ALGORITHM_NAME:"Hashing Insertion",EXAMPLE:"PLACE HOLDER ERROR MESSAGE",handleSubmit:e=>{e.preventDefault();const n=e.target[0].value;if(z(n)){let e=n.split(",").map(Number),a=d.smallTable?wn:En;e.length<a?(r(Bl.RUN_ALGORITHM,{name:"HashingDH",mode:"insertion",hashSize:a,values:e}),t(Z())):t(J(Pn,"Please enter the right number of digits"))}else t(J(Pn,Gn))},setMessage:t}),Object(c.jsx)(Pe,{name:"Hashing",buttonName:"SEARCH",mode:"search",formClassName:"formRight",DEFAULT_VAL:2,SET_VAL:l,ALGORITHM_NAME:"Hashing Search",handleSubmit:e=>{e.preventDefault();const a=e.target[0].value;let i=d.smallTable?wn:En;const s=n.chunker.visualisers;if(U(a)){const e=parseInt(a);r(Bl.RUN_ALGORITHM,{name:"HashingDH",mode:"search",hashSize:i,visualisers:s,target:e}),t(Z())}else t(J(Pn,Gn))},setMessage:t})]}),Object(c.jsx)(Re.a,{control:Object(c.jsx)(_n,{checked:d.smallTable,onChange:u,name:"smallTable"}),label:"Small Table",className:"checkbox"}),Object(c.jsx)(Re.a,{control:Object(c.jsx)(_n,{checked:d.largeTable,onChange:u,name:"largeTable"}),label:"Large Table",className:"checkbox"}),e]})},zn=n.p+"static/media/HSInfo.339acb96.md",Qn=n.p+"static/media/BSTInfo.7ba11aae.md",Un=n.p+"static/media/QSInfo.a60ad72f.md",Wn=n.p+"static/media/msort_arr_td.e468681e.md",qn=n.p+"static/media/msort_lista_td.fbd6e0c9.md",Xn=n.p+"static/media/PRIM_oldInfo.51d714f4.md",Yn=n.p+"static/media/PRIMInfo.51d714f4.md",Kn=n.p+"static/media/KRUSKALInfo.dbe98158.md",Zn=n.p+"static/media/TCInfo.6eb03334.md",Jn=n.p+"static/media/BFSSInfo.ef247f84.md",$n=n.p+"static/media/QSM3Info.6007072b.md",ea=n.p+"static/media/HSSInfo.a1baa892.md",ta=n.p+"static/media/UFInfo.77b519a0.md",na=n.p+"static/media/TTFInfo.73e7fe82.md",aa=n.p+"static/media/DIJKInfo.5ca8b667.md",ra=n.p+"static/media/ASTInfo.ea9dc8cf.md",ia=n.p+"static/media/BFSInfo.0e12f400.md",sa=n.p+"static/media/DFSInfo.0ffe8c57.md",oa=n.p+"static/media/DFSrecInfo.4bf65796.md",la=n.p+"static/media/HashingInfoLP.15249ac9.md",da=n.p+"static/media/HashingInfoDH.a3582738.md",ca={initVisualisers(e){let{visualiser:t}=e;return t.graph.instance.clear(),{graph:{instance:t.graph.instance,order:0}}},run(e,t){let{visualiser:n,target:a}=t;const r=n.graph.instance.getTree(),i=a;let s=n.graph.instance.getRoot(),o=null;e.add(8),e.add(1,((e,t,n)=>e.graph.visit(t,n)),[s,o]);let l=r;for(o=s;l;){if(e.add(2),s===i)return e.add(2,((e,t,n)=>e.graph.leave(t,n)),[s,o]),e.add(3,((e,t,n)=>e.graph.select(t,n)),[s,o]),"success";if(e.add(4),i<s){if(void 0===r[s].left)break;o=s,s=r[s].left,l=r[s],e.add(5,((e,t,n)=>e.graph.visit(t,n)),[s,o])}else{if(void 0===r[s].right)break;o=s,s=r[s].right,l=r[s],e.add(6,((e,t,n)=>e.graph.visit(t,n)),[s,o])}}return e.add(7),e.add(7,(e=>e.graph.setText("RESULT NOT FOUND"))),"fail"}},ha=n(159),ua=n.n(ha);const pa=function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return t.filter((e=>e)).join(" ")},ga=(e,t)=>{const n=e.x-t.x,a=e.y-t.y;return Math.sqrt(n*n+a*a)};var ma=n(201),fa=n.n(ma);class ba extends r.a.Component{render(){const{className:e,children:t}=this.props;return Object(c.jsx)("span",{className:pa(fa.a.ellipsis,e),children:t})}}var ya=ba;class Aa extends r.a.Component{constructor(e){super(e),this.handleMouseDown=this.handleMouseDown.bind(this),this.handleMouseMove=this.handleMouseMove.bind(this),this.handleMouseUp=this.handleMouseUp.bind(this),this.handleWheel=this.handleWheel.bind(this),this._handleMouseDown=this.handleMouseDown,this._handleWheel=this.handleWheel,this.togglePan(!1),this.toggleZoom(!1),this.lastX=null,this.lastY=null,this.centerX=0,this.centerY=0,this.zoom=1,this.zoomFactor=1.001,this.zoomMax=20,this.zoomMin=.005}componentDidUpdate(e,t,n){}togglePan(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:!this.handleMouseDown;this.handleMouseDown=e?this._handleMouseDown:void 0}toggleZoom(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:!this.handleWheel;this.handleWheel=e?this._handleWheel:void 0}handleMouseDown(e){const{clientX:t,clientY:n}=e;this.lastX=t,this.lastY=n,document.addEventListener("mousemove",this.handleMouseMove),document.addEventListener("mouseup",this.handleMouseUp)}handleMouseMove(e){const{clientX:t,clientY:n}=e,a=t-this.lastX,r=n-this.lastY;this.centerX-=a,this.centerY-=r,this.refresh(),this.lastX=t,this.lastY=n}handleMouseUp(e){document.removeEventListener("mousemove",this.handleMouseMove),document.removeEventListener("mouseup",this.handleMouseUp)}handleWheel(e){const{deltaY:t}=e;this.zoom*=Math.pow(this.zoomFactor,t),this.zoom=Math.min(this.zoomMax,Math.max(this.zoomMin,this.zoom)),this.refresh()}toString(e){switch(typeof e){case"number":return[Number.POSITIVE_INFINITY,Number.MAX_SAFE_INTEGER,2147483647].includes(e)?"\u221e":[Number.NEGATIVE_INFINITY,Number.MIN_SAFE_INTEGER,-2147483648].includes(e)?"-\u221e":Number.isInteger(e)?e.toString():e.toFixed(3);case"boolean":return e?"T":"F";default:return e}}refresh(){this.forceUpdate()}renderData(){return null}render(){const{className:e,title:t}=this.props;return Object(c.jsxs)("div",{className:pa(ua.a.renderer,e),onMouseDown:this.handleMouseDown,onWheel:this.handleWheel,children:[Object(c.jsx)(ya,{className:ua.a.title,children:t}),this.renderData()]})}}var xa=Aa;var va,ja,wa=class{constructor(e,t,n,a){this.key=e,this.getObject=t,this.title=n,void 0!==a&&(this.arrayItemMagnitudes=a.arrayItemMagnitudes,this.largestValue=a.largestValue),this.init(),this.reset()}getRendererClass(){return xa}init(){}render(){const e=this.getRendererClass();return Object(c.jsx)(e,{title:this.title,data:this},this.key)}set(){}reset(){this.set()}},Ea=n(383),ka=n(9),Na=n.n(ka);n(237);function Oa(){return Oa=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e},Oa.apply(this,arguments)}function Ia(e,t){let{title:n,titleId:r,...i}=e;return a.createElement("svg",Oa({height:"517pt",viewBox:"0 -45 517.33333 517",width:"517pt",xmlns:"http://www.w3.org/2000/svg",ref:t,"aria-labelledby":r},i),n?a.createElement("title",{id:r},n):null,va||(va=a.createElement("path",{d:"m240 384.167969h-21.332031v-341.335938h128v21.335938c0 11.796875 9.535156 21.332031 21.332031 21.332031s21.332031-9.535156 21.332031-21.332031v-42.667969c0-11.796875-9.535156-21.332031-21.332031-21.332031h-346.667969c-11.796875 0-21.332031 9.535156-21.332031 21.332031v42.667969c0 11.796875 9.535156 21.332031 21.332031 21.332031s21.335938-9.535156 21.335938-21.332031v-21.335938h133.332031v341.335938h-21.332031c-11.796875 0-21.335938 9.535156-21.335938 21.332031s9.539063 21.332031 21.335938 21.332031h85.332031c11.796875 0 21.332031-9.535156 21.332031-21.332031s-9.535156-21.332031-21.332031-21.332031zm0 0"})),ja||(ja=a.createElement("path",{d:"m496 192.167969h-170.667969c-11.796875 0-21.332031 9.535156-21.332031 21.332031v37.332031c0 11.796875 9.535156 21.335938 21.332031 21.335938s21.335938-9.539063 21.335938-21.335938v-16h42.664062v149.335938h-10.664062c-11.796875 0-21.335938 9.535156-21.335938 21.332031s9.539063 21.332031 21.335938 21.332031h64c11.796875 0 21.332031-9.535156 21.332031-21.332031s-9.535156-21.332031-21.332031-21.332031h-10.667969v-149.335938h42.667969v10.667969c0 11.796875 9.535156 21.332031 21.332031 21.332031s21.332031-9.535156 21.332031-21.332031v-32c0-11.796875-9.535156-21.332031-21.332031-21.332031zm0 0"})))}const Ca=a.forwardRef(Ia);n.p;function Sa(e){return"object"===typeof Node?e instanceof Node:e&&"object"===typeof e&&"number"===typeof e.nodeType&&"string"===typeof e.nodeName}function Ma(e){return"object"===typeof HTMLElement?e instanceof HTMLElement:e&&"object"===typeof e&&null!==e&&1===e.nodeType&&"string"===typeof e.nodeName}function Ba(e,t){const n=document.getElementById(e);if(Ma(n)||Sa(n)){const e=window.getComputedStyle(n,null).getPropertyValue("font-size"),a=parseFloat(e);n.style.fontSize="".concat(a+t,"px")}}function Ta(e,t){const n=document.getElementById(e);(Ma(n)||Sa(n))&&(n.style.fontSize="".concat(t,"px"))}const Ra="algo-theme",La="default",Da="green",Pa="red",Fa=[{id:La,primary:"positive1",secondary:"negative1",third:"hint1",fourth:"back-up1"},{id:Da,primary:"positive2",secondary:"negative2",third:"hint2",fourth:"back-up2"},{id:Pa,primary:"cyan",secondary:"purple",third:"green",fourth:"yellow"}],Ha="data-theme",_a="light",Ga="dark",Va=[{id:_a,primary:"white",secondary:"white",third:"white",fourth:"white"},{id:Ga,primary:"black",secondary:"black",third:"black",fourth:"black"}];function za(e,t,n){const a={value:t,expiry:(new Date).getTime()+n};localStorage.setItem(e,JSON.stringify(a))}function Qa(e){const t=localStorage.getItem(e);if(!t)return null;const n=JSON.parse(t);return(new Date).getTime()>n.expiry?(localStorage.removeItem(e),null):n.value}const Ua=864e5;function Wa(e){e===_a?(za(Ha,_a,Ua),document.documentElement.setAttribute(Ha,_a)):e===Ga&&(za(Ha,Ga,Ua),document.documentElement.setAttribute(Ha,Ga))}function qa(){return window.matchMedia&&window.matchMedia("(prefers-color-scheme: ".concat(Ga,")")).matches?Ga:_a}function Xa(e){e===La?(za(Ra,La,Ua),document.documentElement.setAttribute(Ra,La)):e===Da?(za(Ra,Da,Ua),document.documentElement.setAttribute(Ra,Da)):e===Pa&&(za(Ra,Pa,Ua),document.documentElement.setAttribute(Ra,Pa))}var Ya=function(e){let{onFontIncrease:t,onSetting:n,colorMode:a,handleColorModeChange:r,systemColor:i,handleSystemColorChange:s}=e;return Object(c.jsxs)("div",{className:"settingsContainer",children:[Object(c.jsxs)("div",{className:"setContainer",children:[Object(c.jsx)("div",{className:"label",children:"Font Size"}),Object(c.jsxs)("div",{className:"fontSize",children:[Object(c.jsx)("button",{type:"button",className:"fontBtn small",onClick:()=>{t(-1)},children:Object(c.jsx)(Ca,{})}),Object(c.jsx)("button",{type:"button",className:"fontBtn big",onClick:()=>{t(1)},children:Object(c.jsx)(Ca,{})})]})]}),Object(c.jsxs)("div",{className:"setContainer",children:[Object(c.jsx)("div",{className:"label",children:"Data Structures"}),Object(c.jsx)("div",{className:"algoCol",children:Fa.map((e=>{let{primary:t,secondary:n,third:i,fourth:s,id:o}=e;return Object(c.jsx)("button",{id:o,type:"button",className:a===o?"colorBtn active":"colorBtn",onClick:e=>r(e.target.id),children:Object(c.jsxs)("table",{border:"0",children:[Object(c.jsxs)("tr",{children:[Object(c.jsx)("th",{id:o,className:"top-left ".concat(t)}),Object(c.jsx)("th",{id:o,className:"top-right ".concat(n)})]}),Object(c.jsxs)("tr",{children:[Object(c.jsx)("td",{id:o,className:"bottom-left ".concat(i)}),Object(c.jsx)("td",{id:o,className:"bottom-right ".concat(s)})]})]})},o)}))})]}),Object(c.jsxs)("div",{className:"setContainer",children:[Object(c.jsx)("div",{className:"label",children:"System"}),Object(c.jsx)("div",{className:"algoCol",children:Va.map((e=>{let{primary:t,secondary:n,id:a}=e;return Object(c.jsxs)("button",{id:a,type:"button",className:i===a?"colorBtn active":"colorBtn",onClick:e=>s(e.target.id),children:[Object(c.jsx)("span",{id:a,className:"left ".concat(t),children:" "}),Object(c.jsx)("span",{id:a,className:"right ".concat(n),children:" "})]},a)}))})]}),Object(c.jsx)("div",{className:"settingFooter",children:Object(c.jsx)("button",{className:"saveBtn",type:"button",onClick:n,children:"Return"})})]})};let Ka;function Za(){switch(arguments.length>0&&void 0!==arguments[0]?arguments[0]:0){case 1:Ka=Na.a.graphgreen;break;case 2:Ka=Na.a.graphblue;break;default:Ka=Na.a.graph}return Ka}function Ja(e,t,n,a){const r=-(n-e)/(a-t);let i,s,o=t>a?1:-1;return Math.abs(t-a)/Math.abs(e-n)<.5?(o=e>n?1:-1,i=(n+e)/2,s=(t+a)/2+30*o):(i=(n+e)/2+30*o,s=r*(i-(e+n)/2)+(t+a)/2),{cx:i,cy:s}}var $a=class extends xa{constructor(e){super(e),"Graph view"===this.props.title&&(this.centerX=650,this.centerY=-200),this.zoom=.85,this.elementRef=r.a.createRef(),this.selectedNode=null,this.togglePan(!0),this.toggleZoom(!0)}handleMouseDown(e){super.handleMouseDown(e);const t=this.computeCoords(e),{nodes:n,dimensions:a}=this.props.data,{nodeRadius:r}=a;this.selectedNode=n.find((e=>ga(t,e)<=r))}handleMouseMove(e){if(this.selectedNode&&"Transitive Closure"===this.props.title){const{x:t,y:n}=this.computeCoords(e),a=this.props.data.findNode(this.selectedNode.id);a.x=t,a.y=n,this.refresh()}else if(this.selectedNode&&this.props.data.moveNode){const{x:t,y:n}=this.computeCoords(e),a=this.props.data.findNode(this.selectedNode.id),r=30,i=Math.round(t/r),s=-Math.round(n/r);i>0&&s>0&&(this.props.data.moveNode(a.id,i,s),a.x=t,a.y=n,this.refresh())}else this.selectedNode?this.refresh():super.handleMouseMove(e)}computeCoords(e){const t=this.elementRef.current,n=t.createSVGPoint();n.x=e.clientX,n.y=e.clientY;const{x:a,y:r}=n.matrixTransform(t.getScreenCTM().inverse());return{x:a,y:r}}computeMax(e){const t=[],n=[];for(const a of e){const{x:e,y:r}=a;t.push(e),n.push(r)}return{x:Math.max.apply(null,t.map(Math.abs)),y:Math.max.apply(null,n.map(Math.abs))}}computeScales(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:30,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:15,i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;const s=[],o=n.x-r/2,l=n.x+r/2,d=n.y-r/2,c=n.y+r/2;for(let h=i;h<=(t-e)/a;h+=i)s.push({label:"x",x1:e+h*a,x2:e+h*a,y1:d,y2:c,num:h}),s.push({label:"y",x1:o,x2:l,y1:-(e+h)*a,y2:-(e+h)*a,num:h});return s}computeArrows(e,t,n,a){var r,i;return"x"===e?(r={x1:t.x,y1:t.y,x2:t.x-n,y2:t.y-a/2},i={x1:t.x,y1:t.y,x2:t.x-n,y2:t.y+a/2}):"y"===e?(r={x1:t.x,y1:-t.y,x2:t.x-a/2,y2:-t.y+n},i={x1:t.x,y1:-t.y,x2:t.x+a/2,y2:-t.y+n}):(r={},i={}),[r,i]}calculateAxisScale(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:30;const n=Math.max(e.x,e.y)/t;for(let a=1;a<10;++a){const e=10*a;if(n<e)return e*t}return 100*t}calculateIncrement(e){const t=e/=arguments.length>1&&void 0!==arguments[1]?arguments[1]:30;if(t<=20)return 1;if(t<=50)return 5;return 10}calculateLabelSizeMultiplier(e){const t=e/=arguments.length>1&&void 0!==arguments[1]?arguments[1]:30;for(let n=1;n<10;++n)if(t<=10*n){return 1+.2*(n-1)}}renderAxis(e){const t={x:0,y:0},n=this.calculateAxisScale(e),a=this.calculateIncrement(n),r=(this.calculateLabelSizeMultiplier(n),this.computeScales(0,n,t,void 0,void 0,a)),i=n+20,s=this.computeArrows("x",{x:i,y:t.y},18,18),o=this.computeArrows("y",{x:t.x,y:i},18,18),l=i+20,d=i+20,h={x:t.x-12,y:t.y+16};return"Graph view"!==this.props.title?Object(c.jsx)("g",{}):Object(c.jsxs)("g",{children:[Object(c.jsx)("line",{x1:0,y1:t.y,x2:i,y2:t.y,className:Na.a.axis}),Object(c.jsx)("line",{x1:t.x,y1:0,x2:t.x,y2:-i,className:Na.a.axis}),s.map((e=>Object(c.jsx)("line",{x1:e.x1,y1:e.y1,x2:e.x2,y2:e.y2,className:Na.a.axis}))),o.map((e=>Object(c.jsx)("line",{x1:e.x1,y1:e.y1,x2:e.x2,y2:e.y2,className:Na.a.axis}))),Object(c.jsx)("text",{x:l,y:t.y+5,textAnchor:"middle",className:Na.a.axisLabel,children:"x"}),Object(c.jsx)("text",{x:t.x,y:-d,textAnchor:"middle",className:Na.a.axisLabel,children:"y"}),Object(c.jsx)("text",{x:h.x,y:h.y,textAnchor:"middle",className:Na.a.axisLabel,children:"0"}),r.map((e=>"x"===e.label?Object(c.jsxs)("g",{children:[Object(c.jsx)("line",{x1:e.x1,y1:e.y1,x2:e.x2,y2:e.y2,className:Na.a.axis}),Object(c.jsxs)("text",{x:e.x1,y:h.y+30,textAnchor:"middle",className:Na.a.axisLabel,children:[" ",e.num," "]})]}):"y"===e.label?Object(c.jsxs)("g",{children:[Object(c.jsx)("line",{x1:e.x1,y1:e.y1,x2:e.x2,y2:e.y2,className:Na.a.axis}),Object(c.jsxs)("text",{x:h.x-25,y:e.y1+6,textAnchor:"middle",className:Na.a.axisLabel,children:[" ",e.num," "]})]}):void 0))]})}renderData(){const{nodes:e,edges:t,isDirected:n,isWeighted:a,dimensions:r,text:i}=this.props.data,{baseWidth:s,baseHeight:o,nodeRadius:l,arrowGap:d,nodeWeightGap:h,edgeWeightGap:u}=r,p=[(this.centerX-s/2)/this.zoom,(this.centerY-o/2)/this.zoom,s/this.zoom,o/this.zoom],g=e[0];let m=0,f=0;return g&&(m=g.x,f=g.y),Object(c.jsxs)("svg",{className:Za(0),viewBox:p,ref:this.elementRef,children:[Object(c.jsxs)("defs",{children:[Object(c.jsx)("marker",{id:"markerArrow",markerWidth:"6",markerHeight:"6",refX:"3",refY:"3",orient:"auto",children:Object(c.jsx)("path",{d:"M0,0 L0,6 L6,3 L0,0",className:Na.a.arrow})}),Object(c.jsx)("marker",{id:"markerArrowSelected",markerWidth:"6",markerHeight:"6",refX:"3",refY:"3",orient:"auto",children:Object(c.jsx)("path",{d:"M0,0 L0,6 L6,3 L0,0",className:pa(Na.a.arrow,Na.a.selected)})}),Object(c.jsx)("marker",{id:"markerArrowVisited",markerWidth:"6",markerHeight:"6",refX:"3",refY:"3",orient:"auto",children:Object(c.jsx)("path",{d:"M0,0 L0,6 L6,3 L0,0",className:pa(Na.a.arrow,Na.a.visited)})}),Object(c.jsx)("marker",{id:"markerArrowVisited1",markerWidth:"6",markerHeight:"6",refX:"3",refY:"3",orient:"auto",children:Object(c.jsx)("path",{d:"M0,0 L0,6 L6,3 L0,0",className:pa(Na.a.arrow,Na.a.visited1)})}),Object(c.jsx)("marker",{id:"markerArrowVisited2",markerWidth:"6",markerHeight:"6",refX:"3",refY:"3",orient:"auto",children:Object(c.jsx)("path",{d:"M0,0 L0,6 L6,3 L0,0",className:pa(Na.a.arrow,Na.a.visited2)})}),Object(c.jsx)("marker",{id:"markerArrowVisited3",markerWidth:"6",markerHeight:"6",refX:"3",refY:"3",orient:"auto",children:Object(c.jsx)("path",{d:"M0,0 L0,6 L6,3 L0,0",className:pa(Na.a.arrow,Na.a.visited3)})}),Object(c.jsx)("marker",{id:"markerArrowVisited4",markerWidth:"6",markerHeight:"6",refX:"3",refY:"3",orient:"auto",children:Object(c.jsx)("path",{d:"M0,0 L0,6 L6,3 L0,0",className:pa(Na.a.arrow,Na.a.visited4)})})]}),this.renderAxis(this.computeMax(e)),t.sort(((e,t)=>e.visitedCount-t.visitedCount+e.visitedCount1-t.visitedCount1)).map((e=>{const{source:t,target:r,weight:i,visitedCount:s,selectedCount:o,visitedCount0:h,visitedCount1:p,visitedCount2:g,visitedCount3:m,visitedCount4:f}=e,b=this.props.data.findNode(t),y=this.props.data.findNode(r);if(!b||!y)return;const{x:A,y:x}=b;let{x:v,y:j}=y;const w=(A+v)/2,E=(x+j)/2,k=v-A,N=j-x;if(n){const e=Math.sqrt(k*k+N*N);0!==e&&(v=A+k/e*(e-l-d),j=x+N/e*(e-l-d))}let O=null;if(this.props.data.isInterConnected(t,r)){const{cx:e,cy:t}=Ja(A,x,v,j);O="M".concat(A,",").concat(x," Q").concat(e,",").concat(t,",").concat(v,",").concat(j)}else O="M".concat(A,",").concat(x," L").concat(v,",").concat(j);return Object(c.jsxs)("g",{className:pa(Na.a.edge,y.sorted&&Na.a.sorted,o&&Na.a.selected,!o&&s&&Na.a.visited,h&&Na.a.visited,p&&Na.a.visited1,g&&Na.a.visited2,m&&Na.a.visited3,f&&Na.a.visited4),children:[Object(c.jsx)("path",{d:O,className:pa(Na.a.line,n&&Na.a.directed)}),a&&Object(c.jsx)("g",{transform:"translate(".concat(w,",").concat(E,")"),children:Object(c.jsx)("text",{className:Na.a.weight,transform:"rotate(0)",y:-u,children:this.toString(i)})})]},"".concat(t,"-").concat(r))})),e.map((e=>{const{x:t,y:n,weight:r,visitedCount0:i,visitedCount:s,visitedCount1:o,visitedCount2:d,visitedCount3:u,visitedCount4:p,selectedCount:g,value:m,key:f,style:b,sorted:y,isPointer:A,pointerText:x}=e,v=1===g,j=1===i,w=1===s,E=1===o,k=1===d,N=1===u,O=1===p;return Object(c.jsxs)(Ea.a.g,{animate:{x:t,y:n},initial:!1,transition:{duration:1},className:pa(Na.a.node,v&&Na.a.selected,y&&Na.a.sorted,j&&Na.a.visited0,w&&Na.a.visited,E&&Na.a.visited1,k&&Na.a.visited2,N&&Na.a.visited3,O&&Na.a.visited4),children:[Object(c.jsx)("circle",{className:pa(Na.a.circle,b&&b.backgroundStyle),r:l}),Object(c.jsx)("text",{className:pa(Na.a.id,b&&b.textStyle),children:m}),a&&Object(c.jsx)("text",{className:Na.a.weight,x:l+h,children:this.toString(r)}),A&&Object(c.jsx)("text",{className:Na.a.weight,x:l+h,children:this.toString(x)})]},f)})),Object(c.jsx)("text",{style:{fill:"#ff0000"},textAnchor:"middle",x:m,y:f-20,children:i})]})}};var er=class extends wa{getRendererClass(){return $a}init(){super.init(),this.dimensions={baseWidth:480,baseHeight:480,padding:32,defaultNodeRadius:33,nodeRadius:33,arrowGap:4,nodeWeightGap:4,edgeWeightGap:4},this.isDirected=!0,this.isWeighted=!1,this.callLayout={method:this.layoutCircle,args:[]},this.text=null,this.logTracer=null,this.istc=!1}calculateMaximumCoordinate(e){let t=0;for(let n=0;n<e.length;n++)e[n][0]>t?t=e[n][0]:e[n][1]>t&&(t=e[n][1]);return t}setNodeRadius(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];0===e.length&&(this.dimensions.nodeRadius=this.dimensions.defaultNodeRadius);const t=this.calculateMaximumCoordinate(e);for(let n=0;n<=10;++n)if(t<10*(n+1)){return}}set(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[];this.scaledCoords=n,this.setNodeRadius(n),n.length>0&&(this.callLayout=null),this.nodes=[],this.edges=[];for(let a=0;a<e.length;a++){const r=t[a]?t[a]:a;if(0===n.length)this.addNode(a,r);else{const e=30,t=n[a][0]*e,i=-n[a][1]*e;this.addNode(a,r,void 0,void 0,void 0,t,i)}for(let t=0;t<e.length;t++){const n=e[a][t];n&&this.addEdge(a,t,this.isWeighted?n:null)}}this.layout(),super.set()}clear(){this.edges.forEach((e=>{e.visitedCount=0,e.selectedCount=0})),this.nodes.forEach((e=>{e.visitedCount=0,e.selectedCount=0})),this.text=null}isEmpty(){return 0===this.nodes.length&&0===this.edges.length}getTree(){const e={},t=(e,t,n)=>{t<n?e[t].right=n:t>n&&(e[t].left=n)};return this.edges.forEach((n=>{e.hasOwnProperty(n.source)||(e[n.source]={}),t(e,n.source,n.target),e.hasOwnProperty(n.target)||(e[n.target]={})})),this.nodes.forEach((t=>{e.hasOwnProperty(t.id)||(e[t.id]={})})),e}getRoot(){if(0===this.edges.length&&1===this.nodes.length)return this.nodes[0].id;const e=this.edges.map((e=>e.source)),t=this.edges.map((e=>e.target));return[...new Set([...e,...t])].find((e=>!t.includes(e)))}setHeap(e){this.nodes=[],this.edges=[];for(let t=1;t<=e.length;t++)this.addNode(t,e[t-1]),2*t<=e.length&&this.addEdge(t,2*t),2*t+1<=e.length&&this.addEdge(t,2*t+1);this.layoutTree(1),this.directed(!1),this.layout(),super.set()}swapNodes(e,t){const n=this.findNode(e),a={value:n.value,key:n.key,visitedCount:n.visitedCount,selectedCount:n.selectedCount},r=this.findNode(t);n.value=r.value,n.key=r.key,n.visitedCount=r.visitedCount,n.selectedCount=r.selectedCount,r.value=a.value,r.key=a.key,r.visitedCount=a.visitedCount,r.selectedCount=a.selectedCount,this.layoutTree(this.root)}directed(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];this.isDirected=e}weighted(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];this.isWeighted=e}moveNodeFn(e){this.moveNode=e}addNode(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:void 0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"circle",a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"blue",r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,s=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0,o=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,l=arguments.length>8&&void 0!==arguments[8]?arguments[8]:0,d=arguments.length>9&&void 0!==arguments[9]?arguments[9]:0,c=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0,h=arguments.length>11&&void 0!==arguments[11]?arguments[11]:"";if(this.findNode(e))return;t=void 0===t?e:t;const u=e;this.nodes.push({id:e,value:t,shape:n,color:a,weight:r,x:i,y:s,visitedCount:o,selectedCount:l,key:u,visitedCount1:d,isPointer:c,pointerText:h}),this.layout()}addResult(e,t){this.findNode(t).Result=e}addStringLen(e,t){this.findNode(t).StingLen=e}addPatternLen(e,t){this.findNode(t).PatternLen=e}updateNode(e,t,n,a,r,i,s){const o=this.findNode(e),l={value:t,weight:n,x:a,y:r,visitedCount:i,selectedCount:s};Object.keys(l).forEach((e=>{void 0===l[e]&&delete l[e]})),Object.assign(o,l)}removeNode(e){const t=this.findNode(e);if(!t)return;const n=this.nodes.indexOf(t);this.nodes.splice(n,1),this.layout()}addEdge(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;this.findEdge(e,t)||(this.edges.push({source:e,target:t,weight:n,visitedCount:a,selectedCount:r,visitedCount1:i}),this.layout())}updateEdge(e,t,n,a,r){const i=this.findEdge(e,t),s={weight:n,visitedCount:a,selectedCount:r};Object.keys(s).forEach((e=>{void 0===s[e]&&delete s[e]})),Object.assign(i,s)}removeEdge(e,t){const n=this.findEdge(e,t);if(!n)return;const a=this.edges.indexOf(n);this.edges.splice(a,1),this.layout()}findValue(e){return this.findNode(e).value}findNode(e){return this.nodes.find((t=>t.id===e))}findEdge(e,t){return(arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.isDirected)?this.edges.find((n=>n.source===e&&n.target===t)):this.edges.find((n=>n.source===e&&n.target===t||n.source===t&&n.target===e))}findLinkedEdges(e){return(arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.isDirected)?this.edges.filter((t=>t.source===e)):this.edges.filter((t=>t.source===e||t.target===e))}findLinkedNodeIds(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.isDirected;return this.findLinkedEdges(e,t).map((t=>t.source===e?t.target:t.source))}findLinkedNodes(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.isDirected;return this.findLinkedNodeIds(e,t).map((e=>this.findNode(e)))}getRect(){const{baseWidth:e,baseHeight:t,padding:n}=this.dimensions,a=-e/2+n,r=-t/2+n,i=e/2-n,s=t/2-n;return{left:a,top:r,right:i,bottom:s,width:i-a,height:s-r}}layout(){if(null===this.callLayout)return;const{method:e,args:t}=this.callLayout;e.apply(this,t)}layoutCircle(){this.callLayout={method:this.layoutCircle,args:arguments};const e=this.getRect(),t=2*Math.PI/this.nodes.length;let n=-Math.PI/2;for(const a of this.nodes){const r=Math.cos(n)*e.width/2,i=Math.sin(n)*e.height/2;a.x=r,a.y=i,n+=t}}shift(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1?arguments[1]:void 0;const n=t[0],a=t[1];let r=0;let i=-1;for(let s=0;s<n.length;s++){const e=this.findNode(r);e.shape="box",e.x=25*(s-n.length/2),0===s&&(i=e.x),e.y=15,r++}for(let s=0;s<a.length;s++){const t=this.findNode(r);t.shape="box",t.x=i+25*(s+e),t.y=-15,r++}}layoutBFSS(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1?arguments[1]:void 0;this.callLayout={method:this.layoutBFSS,args:arguments};const n=t[0],a=t[1];let r=0;let i=-1;for(let s=0;s<n.length;s++){const e=this.findNode(r);e.shape="square",e.x=25*(s-n.length/2),0===s&&(i=e.x),e.y=15,r++}for(let s=0;s<a.length;s++){const t=this.findNode(r);t.shape="square",t.x=i+(25*s+25*e),t.y=-15,r++}}layoutTree(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];this.root=e,this.callLayout={method:this.layoutTree,args:arguments};const n=this.getRect();if(1===this.nodes.length){const[e]=this.nodes;return e.x=(n.left+n.right)/2,void(e.y=(n.top+n.bottom)/2)}let a=0;const r={};let i={};const s=(e,t)=>{i[e]=!0,r[e]=0,a<t&&(a=t);const n=this.findLinkedNodeIds(e,!1);for(const a of n)i[a]||(r[e]+=s(a,t+1));return 0===r[e]&&(r[e]=1),r[e]};s(e,0),i={};const o=this.dimensions.baseWidth/this.nodes.length,l=(this.dimensions.baseHeight-100)/a,d=(e,n,a,s,c)=>{i[e.id]=!0,e.x=s,e.y=c;const h=this.findLinkedNodes(e.id,!1);t&&h.sort(((e,t)=>e.id-t.id));for(const t of h){if(i[t.id])continue;let h=s,u=c;t.id===2*e.id&&(h-=r[e.id]*o),t.id===2*e.id+1&&(h+=r[e.id]*o),u+=l,d(t,n,a+1,h,u),n+=r[t.id]}},c=this.findNode(e);d(c,0,0,0,n.top)}layoutBST(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];this.root=e,this.callLayout={method:this.layoutBST,args:arguments};const n=this.getRect(),a=(n.left+n.right)/2,r=(n.top+n.bottom)/2;if(1===this.nodes.length){const[e]=this.nodes;return e.x=a,void(e.y=r)}let i=0;const s={};let o={};const l=(e,t)=>{o[e]=!0,s[e]=t,i<t&&(i=t);const n=this.findLinkedNodeIds(e,!1);for(const a of n)o[a]||l(a,t+1)};l(e,0);const d=n.width-150,c=n.height/i;o={};const h=(e,a,r)=>{o[e.id]=!0,e.x=n.left+a*d+120,e.y=n.top+r*c;const i=this.findLinkedNodes(e.id,!1);t&&i.sort(((e,t)=>e.id-t.id));for(const t of i)o[t.id]||(t.id>e.id?(e.id,this.root,h(t,a+1/(r*r+1),r+1)):t.id<e.id&&(e.id<this.root?h(t,a-1/(r*r+1),r+1):h(t,a-1/(2*r+1),r+1)))},u=this.findNode(e);h(u,0,0)}layoutRandom(){this.callLayout={method:this.layoutRandom,args:arguments};const e=this.getRect(),t=[];for(const n of this.nodes){do{n.x=e.left+Math.random()*e.width,n.y=e.top+Math.random()*e.height}while(t.find((e=>ga(n,e)<48)));t.push(n)}}visit0(e,t,n){this.visitOrLeave0(!0,e,t,n)}visit(e,t,n){this.visitOrLeave(!0,e,t,n)}leave(e,t,n){this.visitOrLeave(!1,e,t,n)}allLeave(e,t,n){for(let a=0;a<t.length;a+=1)this.visitOrLeave(!1,e,t[a],n)}visitOrLeave0(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,a=arguments.length>3?arguments[3]:void 0;const r=this.findEdge(n,t),i=this.findNode(t);a&&(i.weight=a),this.istc?(i.visitedCount0=e?1:0,r&&(r.visitedCount0=e?1:0)):(i.visitedCount0+=e?1:-1,r&&(r.visitedCount0+=e?1:-1)),this.logTracer&&this.logTracer.println(e?(n||"")+" -> "+t:(n||"")+" <- "+t)}visitOrLeave(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,a=arguments.length>3?arguments[3]:void 0;const r=this.findEdge(n,t),i=this.findNode(t);a&&(i.weight=a),this.istc?(i.visitedCount=e?1:0,r&&(r.visitedCount=e?1:0)):(i.visitedCount+=e?1:-1,r&&(r.visitedCount+=e?1:-1)),this.logTracer&&this.logTracer.println(e?(n||"")+" -> "+t:(n||"")+" <- "+t)}select(e,t){this.selectOrDeselect(!0,e,t)}styledSelect(e,t,n){this.styledSelectOrDeselect(e,!0,t,n)}styledDeselect(e,t,n){this.styledSelectOrDeselect(e,!1,t,n)}deselect(e,t){this.selectOrDeselect(!1,e,t)}visit1(e,t,n,a){this.visitOrLeave1(!0,e,t,a,n)}leave0(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,a=arguments.length>3?arguments[3]:void 0;this.visitOrLeave0(!1,e,t,a,n)}leave1(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,a=arguments.length>3?arguments[3]:void 0;this.visitOrLeave1(!1,e,t,a,n)}visitOrLeave1(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1;const i=this.findEdge(n,t),s=this.findNode(t);a&&(s.weight=a);const o=this.findNode(n);1===r?(i&&(i.visitedCount1=e?1:0),s.visitedCount1=e?1:0,o&&(o.visitedCount1=e?1:0)):2===r&&(i&&(i.visitedCount2=e?1:0),s.visitedCount2=e?1:0,o&&(o.visitedCount2=e?1:0)),this.logTracer&&this.logTracer.println(e?(n||"")+" -> "+t:(n||"")+" <- "+t)}setPointerNode(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;const r=this.findNode(e);r.isPointer=1,r.pointerText.includes(t)||(r.pointerText=r.pointerText.concat(" ",t));const i=this.findNode(n);i&&(i.isPointer=1,i.pointerText.includes(a)||(i.pointerText=i.pointerText.concat(" ",a)))}unsetPointerNode(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;const r=this.findNode(e);r.pointerText=r.pointerText.replace(t,"");const i=this.findNode(n);i&&(i.pointerText=i.pointerText.replace(a,""))}selectOrDeselect(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;const a=this.findEdge(n,t);a&&(a.selectedCount+=e?1:-1);this.findNode(t).selectedCount+=e?1:-1,this.logTracer&&this.logTracer.println(e?(n||"")+" => "+t:(n||"")+" <= "+t)}sorted(e){this.findNode(e).sorted=!0}styledSelectOrDeselect(e,t,n,a){this.selectOrDeselect(t,n,a);this.findNode(n).style=e}resetSelect(e,t){const n=this.findEdge(t,e);n&&(n.selectedCount=0);this.findNode(e).selectedCount=0}isInterConnected(e,t){return this.edges.find((n=>n.source===e&&n.target===t))&&this.edges.find((n=>n.source===t&&n.target===e))}log(e){this.logTracer=e?this.getObject(e):null}setText(e){this.text=e,this.text.push({text:e})}setIstc(){this.istc=!0}colorEdge(e,t,n){const a=this.findEdge(e,t);a&&(1===n?a.visitedCount1=1:2===n?a.visitedCount2=1:3===n?a.visitedCount3=1:4===n&&(a.visitedCount4=1))}removeEdgeColor(e,t){const n=this.findEdge(e,t);n&&(n.visitedCount1=0,n.visitedCount2=0,n.visitedCount3=0,n.visitedCount4=0)}colorNode(e,t){const n=this.findNode(e);n&&(1===t?n.visitedCount1=1:2===t?n.visitedCount2=1:3===t?n.visitedCount3=1:4===t&&(n.visitedCount4=1))}removeNodeColor(e){const t=this.findNode(e);t&&(t.visitedCount1=0,t.visitedCount2=0,t.visitedCount3=0,t.visitedCount4=0)}},tr=n(391),nr=n(5),ar=n.n(nr);let rr;function ir(){switch(arguments.length>0&&void 0!==arguments[0]?arguments[0]:0){case 1:rr=ar.a.array_2d_green;break;case 2:rr=ar.a.array_2d_blue;break;default:rr=ar.a.array_2d}return rr}const sr=e=>{const[t,n]=(()=>{const e=Object(a.useRef)(null);return[()=>e.current.scrollIntoView({behavior:"smooth",block:"center"}),e]})();return Object(a.useEffect)(t,[]),Object(c.jsx)(Ea.a.p,{layoutId:e.value,className:ar.a.variable,ref:n,children:e.value},e.value)};var or=class extends xa{constructor(e){super(e),this.togglePan(!0),this.toggleZoom(!0)}renderData(){const{data:e,algo:t,kth:n,listOfNumbers:a,motionOn:i,hideArrayAtIdx:s,splitArray:o}=this.props.data;let l=this.centerX,d=this.centerY,h=this.zoom;let u,p=[];function g(e,n,a,o){return Object(c.jsxs)("tbody",{children:["unionFind"===t&&Object(c.jsx)(tr.a,{children:Object(c.jsx)("tr",{children:e[0].map(((e,t)=>Object(c.jsx)("td",{children:Object(c.jsx)("div",{style:{position:"absolute",height:"15px",width:"37px"},children:e.variables.map((e=>Object(c.jsx)(Ea.a.div,{layoutId:e,className:pa(ar.a.variable,ar.a.top_variable),transition:i?{type:"tween"}:{duration:0},children:e},e)))})},t)))})}),Object(c.jsxs)("tr",{className:ar.a.row,children:[!1,"tc"===t&&Object(c.jsx)("td",{}),"BFS"!==t&&"DFSrec"!==t&&"DFS"!==t&&"kruskal"!==t&&"dijkstra"!==t&&"aStar"!==t&&"aStar"!==t&&"msort_lista_td"!==t&&"HashingLP"!==t&&"HashingDH"!==t&&a.map(((e,n)=>("tc"===t&&(n+=1),"prim"===t||"unionFind"==t?Object(c.jsx)(r.a.Fragment,{},n):Object(c.jsx)("th",{className:pa(ar.a.col,ar.a.index),children:Object(c.jsx)("span",{className:ar.a.value,children:n})},n))))]}),e.map(((e,a)=>{let r=!1;if(Array.isArray(s)&&s.includes(a)||a===s)return null;for(let t=0;t<e.length;t++)e[t].selected&&(r=!0);return Object(c.jsxs)("tr",{className:ar.a.row,children:["tc"===t&&Object(c.jsx)("th",{className:pa(ar.a.col,ar.a.index),children:Object(c.jsx)("span",{className:ar.a.value,children:a+1})},a),!1,e.map(((e,t)=>{const a=1===e.fill,r=2===e.fill,i=3===e.fill;return Object(c.jsx)("td",{className:pa(ar.a.col,e.selected&&ar.a.selected,e.patched&&ar.a.patched,e.sorted&&ar.a.sorted,e.selected1&&ar.a.selected1,e.selected2&&ar.a.selected2,e.selected3&&ar.a.selected3,a&&ar.a.variableGreen,r&&ar.a.variableOrange,i&&ar.a.variableRed),children:Object(c.jsx)("span",{className:ar.a.value,children:n(e.value)})},t)})),r&&"tc"===t&&Object(c.jsx)("th",{className:pa(ar.a.col,ar.a.index),children:Object(c.jsx)("span",{className:ar.a.value,children:" i "})})||"aStar"===t&&1===a&&Object(c.jsx)("th",{className:pa(ar.a.col,ar.a.index),children:Object(c.jsx)("span",{className:ar.a.value,children:" )Priority "})})||"aStar"===t&&2===a&&Object(c.jsx)("th",{className:pa(ar.a.col,ar.a.index),children:Object(c.jsx)("span",{className:ar.a.value,children:" )Queue\u2002 "})})||("prim"===t&&2===a||"dijkstra"===t&&2===a)&&Object(c.jsx)("th",{className:pa(ar.a.col,ar.a.index),children:Object(c.jsx)("span",{className:ar.a.value,children:" Priority Queue "})})||Object(c.jsx)("td",{className:pa(ar.a.col,ar.a.index)})]},a)})),"tc"===t&&Object(c.jsxs)("tr",{"j-tag":"transitive_closure",className:ar.a.row,children:[Object(c.jsx)("td",{}),u.map((e=>{let t=!1;for(let n=0;n<e.length;n++)e[n].selected1&&(t=!0);return t&&Object(c.jsx)("th",{className:pa(ar.a.col,ar.a.index),children:Object(c.jsx)("span",{className:ar.a.value,children:" j "})})||Object(c.jsx)("td",{className:pa(ar.a.col,ar.a.index)})}))]}),("prim"===t||"kruskal"===t||"dijkstra"===t||"aStar"===t||"DFS"===t||"DFSrec"===t||"msort_lista_td"===t||"BFS"===t||"HashingLP"===t||"HashingDH"===t)&&e.map(((e,t)=>2===t&&Object(c.jsx)(tr.a,{children:Object(c.jsx)("tr",{layout:!0,className:ar.a.row,children:e.map(((e,t)=>Object(c.jsx)("td",{className:pa(ar.a.col,ar.a.variables),children:e.variables.map((e=>Object(c.jsx)(sr,{value:e})))},t)))},t)})))]})}function m(e){return Object(c.jsxs)("table",{className:ir(0),style:{marginLeft:2*-l,marginTop:2*-d,transform:"scale(".concat(h,")")},children:[e,"tc"===t&&Object(c.jsxs)("caption",{"kth-tag":"transitive_closure",children:["k = ",n]}),"unionFind"==t&&Object(c.jsxs)("caption",{"kth-tag":"unionFind",className:ar.a.bottom_caption,children:[Object(c.jsx)("span",{className:ar.a.pseudocode_function,children:"Union"}),"(",n,")"]}),"DFS"===t&&Object(c.jsxs)("caption",{className:"DFS"===t?ar.a.captionDFS:"","kth-tag":"dfs_caption",children:["Nodes (stack):\u2003 ",a,"\u2003\u2003\u2003\u2003\u2003\u2003\u2003"]}),"DFSrec"===t&&Object(c.jsxs)("caption",{className:"DFSrec"===t?ar.a.captionDFSrec:"","kth-tag":"dfsrec_caption",children:["Call stack (n,p):\u2003 ",a,"\u2003\u2003"]}),"msort_arr_td"===t&&Object(c.jsxs)("caption",{className:"msort_arr_td"===t?ar.a.captionmsort_arr_td:"","kth-tag":"msort_arr_td_caption",children:["Call stack (n,p):\u2003 ",a,"\u2003\u2003"]}),"msort_lista_td"===t&&a&&Object(c.jsxs)("caption",{className:"msort_lista_td"===t?ar.a.captionmsort_lista_td:"","kth-tag":"msort_lista_td_caption",children:["Call stack (L, len):\u2003 ",a,"\u2003\u2003"]}),"BFS"===t&&Object(c.jsxs)("caption",{className:"BFS"===t?ar.a.captionBFS:"","kth-tag":"bfs_caption",children:["Nodes (queue): ",a]})]})}if("tc"===t&&(u=e[0].map(((t,n)=>e.map((e=>e[n]))))),o.doSplit){for(const t of e){let e=t.reduce(((e,t)=>e.length<t.length?t:e),[]);p.push(g(t,this.toString,e))}return Object(c.jsxs)("div",{className:ar.a.container,children:[Object(c.jsx)("div",{className:ar.a.array2d_container,children:m(p)}),Object(c.jsx)("div",{style:{flex:1,margin:"1% 0"},children:("HashingLP"===t||"HashingDH"===t)&&""!==n&&Object(c.jsxs)("span",{className:ar.a.captionHashing,children:["Insertions: ",Array.isArray(n)?n[0]:n,"\u2003\u2003\u2003\u2003\u2003\u2003 Increment: ",Array.isArray(n)?n[1]:""]})})]})}{let t=e.reduce(((e,t)=>e.length<t.length?t:e),[]);return p.push(g(e,this.toString,t)),m(p)}}};class lr{constructor(e,t){this.value=e,this.patched=0,this.selected=0,this.sorted=!1,this.key=t,this.variables=[],this.stack=[],this.fill=0}}var dr=class extends wa{getRendererClass(){return or}set(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],t=arguments.length>1?arguments[1]:void 0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,a=arguments.length>3?arguments[3]:void 0;if(void 0===a||a.rowLength<1)this.splitArray={doSplit:!1},this.data=e.map((e=>[...e].map(((e,t)=>new lr(e,t)))));else{this.splitArray=a,this.splitArray.doSplit=!0,Array.isArray(a.rowHeader)&&a.rowHeader.length?this.splitArray.hasHeader=!0:this.splitArray.hasHeader=!1;let t=[],n=0;for(;n<e[0].length;){let r=[];for(let t=0;t<e.length;t++)r.push([a.rowHeader[t],...e[t].slice(n,n+a.rowLength)]);n+=a.rowLength,t.push(r)}for(const e of t)this.data.push(e.map((e=>[...e].map(((e,t)=>new lr(e,t))))))}this.algo=t,this.kth=n,this.motionOn=!0,this.hideArrayAtIdx=null,this.listOfNumbers="",super.set()}patch(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.data[e][t].value;this.data[e][t]||(this.data[e][t]=new lr),this.data[e][t].value=n,this.data[e][t].patched++}depatch(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.data[e][t].value;this.data[e][t].patched--,this.data[e][t].value=n}sorted(e,t){this.data[e][t]||(this.data[e][t]=new lr),this.data[e][t].sorted=!0}select(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:e,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:t,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"0";for(let i=e;i<=n;i++)for(let e=t;e<=a;e++)switch(r){case"0":this.data[i][e].selected++;break;case"1":this.data[i][e].selected1=!0;break;case"2":this.data[i][e].selected2=!0;break;case"3":this.data[i][e].selected3=!0;break;case"4":this.data[i][e].selected4=!0;break;case"5":this.data[i][e].selected5=!0;break;default:this.data[i][e].selected=!0}}fill(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:e,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:t,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0;if(this.splitArray.doSplit)for(let i=0;i<this.data.length;i++){if(t===a){let s=t+(this.splitArray.hasHeader?1:0);if(s>this.splitArray.rowLength){t-=this.splitArray.rowLength,a-=this.splitArray.rowLength;continue}for(let t=e;t<=n;t++)this.data[i][t][s].fill=1===r||2===r||3===r?r:0;break}let s=t+(this.splitArray.hasHeader?1:0);if(s>this.splitArray.rowLength){t-=this.splitArray.rowLength,a-=this.splitArray.rowLength;continue}let o=a+(this.splitArray.hasHeader?1:0);if(o>this.splitArray.rowLength&&(o=this.splitArray.rowLength),o<0)break;s<0&&(s=0);for(let t=e;t<=n;t++)for(let e=s;e<=o;e++)this.data[i][t][e].fill=1===r||2===r||3===r?r:0;t-=this.splitArray.rowLength,a-=this.splitArray.rowLength}else for(let i=e;i<=n;i++)for(let e=t;e<=a;e++)this.data[i][e].fill=1===r||2===r||3===r?r:0}unfill(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:e,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:t;if(this.splitArray.doSplit)for(let r=0;r<this.data.length;r++){if(t===a){let a=t+(this.splitArray.hasHeader?1:0);if(a>this.splitArray.rowLength){t-=this.splitArray.rowLength;continue}for(let t=e;t<=n;t++)this.data[r][t][a].fill=0;break}let i=t+(this.splitArray.hasHeader?1:0);if(i>this.splitArray.rowLength){t-=this.splitArray.rowLength,a-=this.splitArray.rowLength;continue}let s=a+(this.splitArray.hasHeader?1:0);if(s>this.splitArray.rowLength&&(s=this.splitArray.rowLength),s<0)break;i<0&&(i=0);for(let t=e;t<=n;t++)for(let e=i;e<=s;e++)this.data[r][t][e].fill=0;t-=this.splitArray.rowLength,a-=this.splitArray.rowLength}else for(let r=e;r<=n;r++)for(let e=t;e<=a;e++)this.data[r][e].fill=0}fadeOut(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:e,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:t;for(let r=e;r<=n;r++)for(let e=t;e<=a;e++)this.data[r][e].faded=!0}fadeIn(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:e,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:t;for(let r=e;r<=n;r++)for(let e=t;e<=a;e++)this.data[r][e].faded=!1}assignVariable(e,t,n,a){function r(e){if(e instanceof lr){const t=new lr(e.value,e.key);return e.patched&&(t.patched=!0),e.selected&&(t.selected=!0),e.sorted&&(t.sorted=!0),t.variables=e.variables,t.fill=e.fill,t}}if(this.splitArray.doSplit){let i=[];for(let s=0;s<this.data.length;s++){let o=Object(lt.cloneDeepWith)(this.data[s],r);for(let n=0;n<o[t].length;n++)o[t][n].variables=o[t][n].variables.filter((t=>t!==(void 0!==a?a:e)));if(null!==n&&void 0!==n){let a=n+(this.splitArray.hasHeader?1:0);a>0&&a<=this.splitArray.rowLength&&o[t][a].variables.push(e)}i.push(o),n-=this.splitArray.rowLength}this.data=i}else{const a=Object(lt.cloneDeepWith)(this.data,r);for(let n=0;n<a[t].length;n++)a[t][n].variables=a[t][n].variables.filter((t=>t!==e));null!==n&&void 0!==n&&a[t][n].variables.push(e),this.data=a}}setMotion(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];this.motionOn=e}styledSelect(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:t,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:n;for(let i=t;i<=a;i++)for(let t=n;t<=r;t++)this.data[i][t].selected++,this.data[i][t].style=e}selectRow(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"0";this.select(e,t,e,n,a)}selectCol(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"0";this.select(t,e,n,e,a)}deselect(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:e,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:t;for(let r=e;r<=n;r++)for(let e=t;e<=a;e++)this.data[r][e].selected=!1,this.data[r][e].selected1=!1,this.data[r][e].selected2=!1,this.data[r][e].selected3=!1,this.data[r][e].selected4=!1,this.data[r][e].selected5=!1,this.data[r][e].style=void 0}deselectRow(e,t,n){this.deselect(e,t,e,n)}deselectCol(e,t,n){this.deselect(t,e,n,e)}showKth(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"0";this.kth=e}setList(e){this.listOfNumbers=e?e.join(", "):void 0}getKth(){return this.kth}hideArrayAtIndex(e){this.hideArrayAtIdx=e}updateValueAt(e,t,n){if(this.splitArray.doSplit){for(let a=0;a<this.data.length;a++)if(null!==t||void 0!==t||t>=0){let r=t+(this.splitArray.hasHeader?1:0);if(r>0&&r<=this.splitArray.rowLength){if(!this.data[a][e]||!this.data[a][e][r])continue;this.data[a][e][r].value=n}t-=this.splitArray.rowLength}}else{if(!this.data[e]||!this.data[e][t])return;this.data[e][t].value=n}}getValueAt(e,t){if(!this.splitArray.doSplit){if(!this.data[e]||!this.data[e][t])return;return this.data[e][t].value}for(let n=0;n<this.data.length;n++)if(null!==t||void 0!==t||t>=0){let a=t+(this.splitArray.hasHeader?1:0);if(a>0&&a<=this.splitArray.rowLength){if(!this.data[n][e]||!this.data[n][e][a])continue;return this.data[n][e][a].value}t-=this.splitArray.rowLength}}extractArray(e,t){let n=[];if(this.splitArray.doSplit){let t=[];if(this.splitArray.hasHeader)for(const e of this.data)if(t.length)for(let n=0;n<t.length;n++)t[n]=[...t[n],...e[n].slice(1)];else t=e.map((e=>e.slice(1)));else for(const e of this.data)if(t.length)for(let n=0;n<t.length;n++)t[n]=[...t[n],...e[n]];else t=e;if(Array.isArray(e)&&e.length)for(const a of e)n.push(t[a].map((e=>e.value)));else n=t[e].map((e=>e.value))}else if(Array.isArray(e)&&e.length)for(const a of e)n.push(this.data[a].map((e=>e.value)));else n=this.data[e].map((e=>e.value));for(let a=0;a<n.length;a++)n[a]=n[a]===t?void 0:n[a];return n}},cr=n(25),hr=n.n(cr);let ur;function pr(){switch(arguments.length>0&&void 0!==arguments[0]?arguments[0]:0){case 1:ur=hr.a.array_1d_green;break;case 2:ur=hr.a.array_1d_blue;break;default:ur=hr.a.array_1d}return ur}function gr(e){return["var(--not-started-section)","var(--in-progress-section)","var(--current-section)","var(--finished-section)","var(--i-section)","var(--j-section)","var(--p-section)"][e]}function mr(e,t,n,a){if(!e)return Object(c.jsx)("div",{});let r=[];for(let i=0;i<e.length;i+=1)r.push(Object(c.jsx)("div",{style:{display:"flex",justifyContent:"space-between"},children:e[i].map(((e,n)=>{let{base:a,extra:r}=e;return Object(c.jsx)("div",{className:hr.a.stackElement,style:{width:"calc(100%/".concat(t,")"),textAlign:"center",color:"gray",backgroundColor:gr(a)},children:r.map((e=>Object(c.jsx)("div",{className:hr.a.stackSubElement,style:{width:"100%",textAlign:"center",backgroundColor:gr(e)}})))})}))}));return Object(c.jsxs)("div",{className:hr.a.stack,children:[Object(c.jsx)("div",{style:{display:"flex",justifyContent:"space-between",width:"100%"},children:Object(c.jsx)("p",{children:e.length>0&&void 0!==n?"Current stack depth: ".concat(n):""})}),r]})}var fr=class extends or{constructor(e){super(e),this.togglePan(!0),this.toggleZoom(!0),this.maxStackDepth=0}renderData(){const{data:e,algo:t,stack:n,stackDepth:a,listOfNumbers:r}=this.props.data;let i=e.reduce(((e,t)=>e.length<t.length?t:e),[]),s=0;s=this.props.data.largestValue?this.props.data.largestValue:e[0].reduce(((e,t)=>e<t.value?t.value:e),0);let o=((e,t)=>"number"!==typeof t?0:t/e*20).bind(null,s);return this.props.data.arrayItemMagnitudes||(o=()=>0),Object(c.jsxs)("table",{className:pr(0),style:{marginLeft:2*-this.centerX,marginTop:2*-this.centerY,transform:"scale(".concat(this.zoom,")")},children:[Object(c.jsx)("tbody",{children:Object(c.jsxs)(Ea.a.div,{animate:{scale:this.zoom},className:pr(0),children:[e.map(((e,t)=>Object(c.jsx)("div",{className:hr.a.row,style:{display:"flex",alignItems:"flex-end",justifyContent:"center"},children:e.map((e=>Object(c.jsx)(Ea.a.div,{layout:!0,transition:{duration:.6},style:{height:"".concat(this.toString(o(e.value)),"vh"),display:"flex"},className:pa(hr.a.col,e.faded&&hr.a.faded,e.selected&&hr.a.selected,e.patched&&hr.a.patched,e.sorted&&hr.a.sorted,e.style&&e.style.backgroundStyle),children:Object(c.jsx)(Ea.a.span,{layout:"position",className:pa(hr.a.value,e.style&&e.style.textStyle),children:this.toString(e.value)})},e.key)))},t))),Object(c.jsxs)("div",{children:[Object(c.jsx)("div",{className:hr.a.row,style:{display:"flex",justifyContent:"space-between"},children:i.map(((e,t)=>(t+=1,Object(c.jsx)("div",{className:pa(hr.a.col,hr.a.index),children:Object(c.jsx)("span",{className:hr.a.value,children:t})},t))))}),e.map(((e,t)=>Object(c.jsx)(tr.a,{children:Object(c.jsx)("div",{layout:!0,className:hr.a.row,style:{minHeight:"50px",display:"flex",justifyContent:"space-between",alignItems:"start"},children:e.map((e=>Object(c.jsx)("div",{className:pa(hr.a.col,hr.a.variables),children:e.variables.map((e=>Object(c.jsx)(Ea.a.div,{layoutId:e,className:hr.a.variable,style:{fontSize:e.length>2?"12px":null},children:e},e)))},"vars-".concat(e.key))))},t)})))]}),Object(c.jsx)("div",{children:n&&n.length>0?(this.maxStackDepth=Math.max(this.maxStackDepth,a),mr(n,e[0].length,a,this.maxStackDepth)):Object(c.jsx)("div",{})})]})}),"msort_arr_td"===t&&r&&Object(c.jsxs)("caption",{className:hr.a.captionmsort_arr_td,"kth-tag":"msort_arr_td_caption",children:[" Call stack (n,p):\u2003 ",r,"\u2003\u2003 "]})]})}};var br=class extends dr{getRendererClass(){return fr}init(){super.init(),this.chartTracer=null}set(){let e=arguments.length>1?arguments[1]:void 0;const t=[arguments.length>0&&void 0!==arguments[0]?arguments[0]:[]];super.set(t,e),this.syncChartTracer()}patch(e,t){super.patch(0,e,t)}depatch(e){super.depatch(0,e)}sorted(e){super.sorted(0,e)}select(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e;super.select(0,e,0,t)}styledSelect(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:t;super.styledSelect(e,0,t,0,n)}deselect(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e;super.deselect(0,e,0,t)}fadeOut(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e;super.fadeOut(0,e,0,t)}fadeIn(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e;super.fadeIn(0,e,0,t)}chart(e){this.chartTracer=e?this.getObject(e):null,this.syncChartTracer()}syncChartTracer(){this.chartTracer&&(this.chartTracer.data=this.data)}swapElements(e,t){const n={...this.data[0][e],variables:this.data[0][t].variables},a={...this.data[0][t],variables:this.data[0][e].variables};this.data[0][e]=a,this.data[0][t]=n}addVariable(e,t){this.data[0][t].variables.push(e)}removeVariable(e){for(let t=0;t<this.data[0].length;t++){const n=this.data[0][t].variables.filter((t=>t!==e));this.data[0][t].variables=n}}clearVariables(){for(let e=0;e<this.data[0].length;e++)this.data[0][e].variables=[]}assignVariable(e,t){const n=Object(lt.cloneDeepWith)(this.data,(function(e){if(e instanceof lr){const t=new lr(e.value,e.key);return t.patched=e.patched,t.selected=e.selected,t.sorted=e.sorted,t.faded=e.faded,t.variables=e.variables,t.stack=e.stack,t.stackDepth=e.stackDepth,t.largestValue=e.largestValue,t}}));for(let a=0;a<n[0].length;a++){const t=n[0][a].variables.filter((t=>t!==e));n[0][a].variables=t}null!==t&&void 0!==t&&n[0][t].variables.push(e),this.data=n}setStack(e){this.stack=e}setStackDepth(e){this.stackDepth=e}setLargestValue(e){this.largestValue=e}stringTheContent(){return this.data}},yr={initVisualisers:()=>({array:{instance:new br("array",null,"Keys to insert",{arrayItemMagnitudes:!0}),order:0},graph:{instance:new er("bst",null,"Binary tree"),order:1}}),run(e,t){let n,{nodes:a}=t;if(0===a.length)return;let r=null,i=[null];const s={},o=a[0];s[o]={},e.add("1",((e,t)=>{e.array.set(t)}),[a]),e.add("1",(e=>{e.array.select(0)})),e.add(2),e.add(3,((e,t)=>{e.graph.addNode(t),e.graph.layoutBST(t,!0),e.graph.select(t,null)}),[o]),e.add(4),e.add(5),e.add(6),e.add(7),e.add(8);for(let l=1;l<a.length;l++){e.add(2,((e,t,n)=>{e.array.deselect(t-1),e.array.select(t);for(let a=1;a<n.length;a++)e.graph.leave(n[a],n[a-1]);a[t-1]!==n[n.length-1]&&e.graph.deselect(a[t-1],n[n.length-1])}),[l,i]),i=[null];const t=a[l];e.add(3),e.add(4),e.add(5),e.add(6),e.add(7),e.add(13);let d=s;for(n=o;d;)if(i.push(n),e.add(14,((e,t,n)=>e.graph.visit(t,n)),[n,r]),e.add(15),t<n){if(e.add(16),e.add(18),void 0===s[n].left){e.add(9),s[n].left=t,s[t]={},e.add(10,((e,t,n)=>{e.graph.addNode(t),e.graph.addEdge(n,t),e.graph.select(t,n)}),[t,n]);break}r=n,n=s[n].left,d=s[n]}else{if(!(t>n))break;if(e.add(17),e.add(18),void 0===s[n].right){e.add(9),s[n].right=t,s[t]={},e.add(11,((e,t,n)=>{e.graph.addNode(t),e.graph.addEdge(n,t),e.graph.select(t,n)}),[t,n]);break}r=n,n=s[n].right,d=s[n]}}return e.add(2,((e,t,n)=>{e.array.deselect(t);for(let a=1;a<n.length;a++)e.graph.leave(n[a],n[a-1]);a[t]!==n[n.length-1]&&e.graph.deselect(a[t],n[n.length-1])}),[a.length-1,i]),s}};function Ar(){return Dl(["BuildHeap"])}function xr(){return Dl(["BuildHeap","DownHeapk"])}var vr={initVisualisers:()=>({array:{instance:new br("array",null,"Array view",{arrayItemMagnitudes:!0}),order:0},heap:{instance:new er("heap",null,"Tree view"),order:1}}),run(e,t){let{nodes:n}=t;const a=[...n];let r,i,s,o=n.length;e.add(1,((e,t)=>{e.heap.setHeap(t),e.array.set(t,"heapsort")}),[n]);const l=function(e,t){!(arguments.length>2&&void 0!==arguments[2])||arguments[2]?(e.heap.visit(t+1),e.array.select(t)):(e.heap.select(t+1),e.array.patch(t))},d=function(e,t){!(arguments.length>2&&void 0!==arguments[2])||arguments[2]?(e.heap.leave(t+1),e.array.deselect(t)):(e.heap.deselect(t+1),e.array.depatch(t))},c=(t,n,a)=>{e.add(t,((e,t,n)=>{e.heap.swapNodes(t+1,n+1),e.array.swapElements(t,n)}),[n,a])};let h;for(let u=Math.floor(o/2)-1;u>=0;u-=1){let t;const n=r;for(r=u,e.add(4,((e,t,n)=>{e.array.assignVariable("k",t),null!=n&&(d(e,n),e.array.removeVariable("j")),l(e,t)}),[r,n]),e.add(6,((e,t,n)=>{e.array.assignVariable("i",t)}),[r,n]),h=u,i=!1,e.add(7),e.add(8);!(2*r+1>=o||i);)e.add(10),2*r+2<o&&a[2*r+1]<a[2*r+2]?(t=2*r+2,e.add(11,((e,t)=>{l(e,t,!1),e.array.assignVariable("j",t)}),[t])):(t=2*r+1,e.add(13,((e,t)=>{l(e,t,!1),e.array.assignVariable("j",t)}),[t])),e.add(14),a[r]>=a[t]?(i=!0,e.add(15,((e,t,n)=>{d(e,t,!1),xr()||(e.array.removeVariable("i"),e.array.removeVariable("j")),Ar()||(e.array.removeVariable("k"),d(e,n))}),[t,h])):(s=a[r],a[r]=a[t],a[t]=s,c(17,r,t),h=t,e.add(18,((e,t,n,a)=>{d(e,t,!1),e.array.assignVariable("i",n),xr()||(e.array.removeVariable("i"),e.array.removeVariable("j")),Ar()||(e.array.removeVariable("k"),d(e,a))}),[r,t,h]),r=t)}for(;o>1;){let t;for(e.add(20,((e,t,n)=>{e.array.clearVariables(),e.array.assignVariable("n",t-1),d(e,n)}),[o,r]),s=a[o-1],a[o-1]=a[0],a[0]=s,e.add(21,((e,t)=>{l(e,t),l(e,0,!1)}),[o-1]),c(21,0,o-1),e.add(22,((e,t)=>{d(e,t,!1),e.array.sorted(t),e.heap.sorted(t+1),e.array.assignVariable("n",t-1)}),[o-1]),o-=1,r=0,e.add(24,((e,t,n)=>{e.array.assignVariable("i",t)}),[r,o]),e.add(25),i=!1,e.add(26,((e,t)=>{}),[o]);!(2*r+1>=o||i);)e.add(28),2*r+2<o&&a[2*r+1]<a[2*r+2]?(t=2*r+2,e.add(29,((e,t)=>{l(e,t,!1),e.array.assignVariable("j",t)}),[t])):(t=2*r+1,e.add(31,((e,t)=>{l(e,t,!1),e.array.assignVariable("j",t)}),[t])),e.add(32),a[r]>=a[t]?(i=!0,e.add(33,((e,t)=>{d(e,t,!1)}),[t])):(s=a[r],a[r]=a[t],a[t]=s,c(35,r,t),e.add(36,((e,t,n)=>{d(e,t,!1),e.array.assignVariable("i",n)}),[r,t]),r=t)}return e.add(37,(e=>{e.array.clearVariables(),e.array.deselect(0),e.array.sorted(0),e.heap.sorted(1),d(e,0,!0)})),a}};function jr(){return Dl(["Partition"])}const wr="i",Er="j",kr="i==0",Nr="j==0",Or="pivot",Ir=0,Cr=1,Sr=2,Mr=3,Br=4,Tr=5,Rr=6,Lr=1,Dr=2,Pr=3,Fr=4,Hr=5,_r=5,Gr=6,Vr=7,zr=8,Qr=9,Ur=10,Wr=11,qr=11,Xr=12,Yr=12,Kr=13,Zr=14,Jr=15,$r=16,ei=17,ti=18,ni=300,ai=400,ri=19,ii=20,si=21,oi=22;function li(e,t){if(!e)throw new Error(t||"Assertion failed")}function di(e,t,n){let a,r,i;[a,r,i]=t;for(let s=a;s<=r;s+=1)e[i][s]={base:n,extra:[]};return e}const ci=function(e,t){!(arguments.length>2&&void 0!==arguments[2])||arguments[2]?e.array.select(t):e.array.patch(t)},hi=function(e,t){!(arguments.length>2&&void 0!==arguments[2])||arguments[2]?e.array.deselect(t):e.array.depatch(t)};function ui(){return{array:{instance:new br("array",null,"Array view",{arrayItemMagnitudes:!0}),order:0}}}function pi(e){return function(t,n){let{nodes:a}=n;const r=a;let i=-1;const s=[],o=[];function l(e,t,n,a,s,o){let l=[];for(let d=0;d<i+1;d++)l.push([...Array.from({length:r.length})].map((()=>({base:Ir,extra:[]}))));return t.forEach((e=>{l=di(l,e,Mr)})),e.forEach((e=>{l=di(l,e,Cr)})),0!==e.length&&(l=di(l,e[e.length-1],Sr)),void 0===o?l:(void 0!==s&&l[o][s].extra.push(Rr),jr()?(void 0!==n&&l[o][n].extra.push(Br),void 0!==a&&l[o][a].extra.push(Tr),l):l)}const d=(e,t,n,a,r,i,s)=>{let o,d;-1===a?(a=void 0,o=0):o=void 0,-1===r?(r=void 0,d=0):d=void 0,li(e.array),li(t&&n),jr()||(r=void 0,d=void 0),jr()||Dl(["QuicksortFirst"])||Dl(["QuicksortSecond"])||(a=void 0,o=void 0),e.array.setStackDepth(t.length),e.array.setStack(l(t,n,a,r,i,s)),c(e,wr,a),c(e,kr,o),c(e,Or,i),c(e,Er,r),c(e,Nr,d)};function c(e,t,n){void 0!==n?e.array.assignVariable(t,n):e.array.removeVariable(t)}t.add(Lr,((e,t)=>{e.array.set(t,"quicksort"),e.array.setStack([])}),[r],0);const h=function n(a,r,l,c){o.push([r,l,c]),i=Math.max(i,c);let h,u=a;if(t.add(Dr,d,[o,s],c),r<l){let a,i;[h,u]=function(n,a,r){const i=n;let l,h,u;function p(e,n,a){li(void 0!==e),li(void 0!==n),li(void 0!==a),[i[n],i[a]]=[i[a],i[n]],t.add(e,((e,t,n,a,r,i,s,o,l)=>{e.array.swapElements(t,n),d(e,a,r,i,s,o,l)}),[n,a,o,s,l,h,u,c],c)}function g(e,n,a){li(void 0!==e),void 0===a&&(a=[o,s,l,h,u,c]),t.add(e,n,a,c)}function m(){return i[u]}if(e){const e=Math.floor((a+r)/2);g(Zr,((e,t,n,a)=>{ci(e,t,!1),n!==t&&ci(e,n,!1),ci(e,a,!1)}),[e,a,r]),g(ii),i[a]>i[e]&&p(Jr,a,e),g(si),i[e]>i[r]&&(p($r,r,e),g(oi),i[a]>i[e]&&p(ei,a,e)),p(ti,e,r-1),u=r-1,g(_r,((e,t,n,a,r,i,s,o,l)=>{hi(e,t,!1),hi(e,t-1,!1),n!==t-1&&hi(e,n,!1),d(e,a,r,i,s,o,l)}),[r,a,o,s,l,h,u,c])}else u=r,g(Hr,((e,t,n,a,r,i,s,o,l)=>{d(e,a,r,i,s,o,l)}),[r,a,o,s,l,h,u,c]);for(li(void 0!==u),li(void 0===l),li(void 0===h),e?(l=a,g(qr,d),h=r-1,g(Yr,d)):(l=a-1,g(Wr,d),h=r,g(Xr,d)),li(void 0!==l),li(void 0!==h);l<h;){g(Gr);do{l+=1,g(Vr,d)}while(i[l]<m());do{h-=1,g(zr,d)}while(l<=h&&m()<i[h]);g(Qr),l<h&&p(Ur,l,h)}return u=l,p(Kr,l,e?r-1:r),g(Kr,((e,t,n,a,r,i,s)=>{e.array.sorted(i)})),[l,i]}(u,r,l);let p=h;t.add(ni,((e,t,n,a,r,i,s,o,l)=>{d(e,a,r,i,s,o,l)}),[l,r,o,s,p,i,a,c],c),n(u,r,h-1,c+1),t.add(Pr,((e,t,n,a,r,i,s,o,l)=>{d(e,a,r,i,s,o,l)}),[l,r,o,s,p,i,a,c],c),t.add(ai,((e,t,n,a,r,i,s,o,l)=>{d(e,a,r,i,s,o,l)}),[l,r,o,s,p,i,a,c],c),n(u,h+1,l,c+1),t.add(Fr,d,[o,s],c),s.push(o.pop())}else r<u.length?(t.add(ri,((e,t)=>{e.array.sorted(t)}),[r],c),s.push(o.pop())):(t.add(ri,(e=>null),[],c),s.push(o.pop()));return u}(r,0,r.length-1,1);return li(0===o.length),t.add(ri,((e,t)=>{e.array.setStackDepth(0),e.array.fadeOut(t);for(let n=0;n<r.length;n+=1)e.array.fadeIn(n);e.array.clearVariables(),e.array.setStack(l(o,s))}),[r.length-1],0),h}}var gi={explanation:j,initVisualisers:ui,run:pi(!1)};var mi={explanation:S,initVisualisers:ui,run:pi(!0)};var fi={explanation:w,initVisualisers:function(){return bi()?{array:{instance:new br("array",null,"Array A",{arrayItemMagnitudes:!0}),order:0},arrayB:{instance:new br("arrayB",null,"Array B",{arrayItemMagnitudes:!0}),order:0}}:{array:{instance:new br("array",null,"Array A",{arrayItemMagnitudes:!0}),order:0}}},run:function(e,t){let{nodes:n}=t;const a=n;let r=n,i=[...a].fill(void 0),s=-1;const o=[],l=[];function d(e,t,n){void 0===n?e.array.removeVariable(t):e.array.assignVariable(t,n)}function c(e,t,n){void 0===n?e.arrayB.removeVariable(t):e.arrayB.assignVariable(t,n)}function h(e,t,n,a,r,i,s,o,l,h){if(yi()){e.array.set(t,"msort_arr_td"),d(e,"ap1",r),d(e,"max1",o),vi(e,r,!0),i<t.length?(d(e,"ap2",i),vi(e,i,!0)):d(e,"ap2",void 0),d(e,"max2",l),e.arrayB.set(n,"msort_arr_td"),c(e,"bp",s);for(let t=a;t<s;t++)ji(e,t,!1)}}const u=(e,t)=>{Ai()&&e.setList(t)},p=a.reduce(((e,t)=>e<t?t:e),0),g=function t(n,a,g){if(l.push([n,a,g]),s=Math.max(s,g),xi.unshift("("+(n+1)+","+(a+1)+")"),e.add("Main",((e,t,n,a,r,i,s,o,l)=>{e.array.set(t,"msort_arr_td"),0===i&&(e.array.setLargestValue(p),e.array.setStack([]),bi()&&(e.arrayB.set(n,"msort_arr_td"),e.arrayB.setLargestValue(p))),d(e,"left",a),d(e,"right",r);for(let d=a;d<=r;d++)vi(e,d,!0);u(e.array,l)}),[r,i,n,a,g,l,o,xi],g),e.add("left<right",((e,t,n,a)=>{for(let r=n;r<=a;r++);}),[r,n,a],g),n<a){let s=Math.floor((n+a)/2);e.add("mid",((e,t,n,a,r)=>{for(let i=a+1;i<=r;i++)wi(e,i,!0);d(e,"mid",a)}),[r,n,s,a],g),e.add("preSortL",((e,t,n,r,i)=>{d(e,"left",void 0),d(e,"right",void 0),d(e,"mid",void 0);for(let s=r+1;s<=a;s++);}),[r,n,s,a],g),t(n,s,g+1),e.add("sortL",((e,t,n,a,r,i)=>{e.array.set(t,"msort_arr_td"),u(e.array,i),d(e,"left",n),d(e,"mid",a),d(e,"right",r);for(let s=n;s<=a;s++)vi(e,s,!1);for(let s=a+1;s<=r;s++)vi(e,s,!0)}),[r,n,s,a,xi],g),e.add("preSortR",((e,t,n,a,r)=>{for(let i=n;i<=a;i++)wi(e,i,!1);d(e,"left",void 0),d(e,"mid",void 0),d(e,"right",void 0);for(let i=a+1;i<=r;i++);}),[r,n,s,a],g),t(s+1,a,g+1),e.add("sortR",((e,t,n,a,r,i)=>{u(e.array,i),d(e,"left",n),d(e,"mid",a),d(e,"right",r)}),[r,n,s,a,xi],g);let o=n,l=s,p=s+1,m=a,f=n;for(e.add("ap1",((e,t,n,a,r)=>{u(e.array,void 0);for(let i=a+1;i<=r;i++)wi(e,i,!1);yi()&&(d(e,"left",void 0),d(e,"ap1",n),vi(e,n,!0))}),[r,n,s,a],g),e.add("max1",((e,t,n,a,r)=>{yi()&&(d(e,"mid",void 0),d(e,"max1",a))}),[r,n,s,a],g),e.add("ap2",((e,t,n,a,r)=>{yi()&&(d(e,"ap2",a+1),vi(e,a+1,!0))}),[r,n,s,a],g),e.add("max2",((e,t,n,r,i)=>{yi()&&(d(e,"right",void 0),d(e,"max2",a))}),[r,n,s,a],g),e.add("bp",((e,t,a,r,i)=>{yi()&&c(e,"bp",n)}),[r,n,s,a],g);e.add("MergeWhile",((e,t,n,a,r,i,s,o,l,d)=>{h(e,t,n,d,a,r,i,s,o)}),[r,i,o,p,f,l,m,xi,n],g),o<=l&&p<=m;)e.add("findSmaller",((e,t,n,a,r,i,s,o,l,d)=>{h(e,t,n,d,a,r,i,s,o)}),[r,i,o,p,f,l,m,xi,n],g),r[o]<r[p]?(i[f]=r[o],r[o]=void 0,e.add("copyap1",((e,t,n,a,r,i,s,o,l,d)=>{h(e,t,n,d,a,r,i,s,o),yi()&&ji(e,i,!1)}),[r,i,o,p,f,l,m,xi,n],g),o+=1,e.add("ap1++",((e,t,n,a,r,i,s,o,l,d)=>{h(e,t,n,d,a,r,i,s,o),yi()&&ji(e,i,!1)}),[r,i,o,p,f,l,m,xi,n],g),f+=1,e.add("bp++",((e,t,n,a,r,i,s,o,l,d)=>{h(e,t,n,d,a,r,i,s,o)}),[r,i,o,p,f,l,m,xi,n],g)):(i[f]=r[p],r[p]=void 0,e.add("copyap2",((e,t,n,a,r,i,s,o,l,d)=>{h(e,t,n,d,a,r,i,s,o),yi()&&ji(e,i,!1)}),[r,i,o,p,f,l,m,xi,n],g),p+=1,e.add("ap2++",((e,t,n,a,r,i,s,o,l,d)=>{h(e,t,n,d,a,r,i,s,o),yi()&&ji(e,i,!1)}),[r,i,o,p,f,l,m,xi,n],g),f+=1,e.add("bp++_2",((e,t,n,a,r,i,s,o,l,d)=>{h(e,t,n,d,a,r,i,s,o)}),[r,i,o,p,f,l,m,xi,n],g));for(let e=o;e<=l;e++)i[f]=r[e],r[e]=void 0,f+=1;e.add("CopyRest1",((e,t,n,a,r,i,s,o,l,h)=>{if(yi()){e.array.set(t,"msort_arr_td"),i<t.length&&d(e,"ap2",i),d(e,"max2",o),e.arrayB.set(n,"msort_arr_td");for(let t=a;t<=l-1;t++)ji(e,t,!1);l<t.length?c(e,"bp",l):c(e,"bp",void 0)}}),[r,i,n,o,p,l,m,f,xi],g);for(let e=p;e<=m;e++)i[f]=r[e],r[e]=void 0,f+=1;e.add("CopyRest2",((e,t,n,a,r,i,s,o,l)=>{if(bi()){e.array.set(t,"msort_arr_td"),e.arrayB.set(n,"msort_arr_td");for(let t=a;t<=r;t++)ji(e,t,!1)}yi()&&(i<t.length&&(wi(e,i,!0),d(e,"ap2",void 0)),d(e,"max2",void 0),c(e,"bp",void 0))}),[r,i,n,a,p,m,f,xi],g);for(let e=n;e<=a;e++)r[e]=i[e],i[e]=void 0;e.add("copyBA",((e,t,n,a,r,i,s)=>{if(bi()){for(let e=a;e<=i;e++);e.arrayB.set(n,"msort_arr_td")}e.array.set(t,"msort_arr_td"),u(e.array,s);for(let o=a;o<=i;o++)vi(e,o,!1);yi()&&(d(e,"ap1",void 0),d(e,"max1",void 0),d(e,"ap2",void 0),d(e,"max2",void 0))}),[r,i,n,s,a,xi],g)}else e.add("Done",((e,t,n,a)=>{n===a&&(wi(e,n,!0),vi(e,n,!1))}),[r,n,a],g);return xi.shift(),r}(0,a.length-1,0);return g}};function bi(){return Dl(["MergeCopy"])}function yi(){return Dl(["MergeCopy","Merge"])}function Ai(){return Dl(["MergesortL"])||Dl(["MergesortR"])}let xi=[];const vi=function(e,t){!(arguments.length>2&&void 0!==arguments[2])||arguments[2]?e.array.select(t):e.array.patch(t)},ji=function(e,t){!(arguments.length>2&&void 0!==arguments[2])||arguments[2]?e.arrayB.select(t):e.arrayB.patch(t)},wi=function(e,t){!(arguments.length>2&&void 0!==arguments[2])||arguments[2]?e.array.deselect(t):e.array.depatch(t)};var Ei={explanation:E,initVisualisers:function(){return{array:{instance:new dr("array",null,"Array representation of lists (PROTOTYPE FOR POINTER REPRESENTATION)"),order:0}}},run:function(e,t){let{nodes:n}=t;const a=n;let r=n;function i(e,t,n){"Null"===n?(e.array.assignVariable(t,2,void 0),e.array.assignVariable(t+"=Null",2,0)):e.array.assignVariable(t,2,n)}[...a].fill(void 0);const s=(e,t)=>{(Dl(["MergesortL"])||Dl(["MergesortR"]))&&e.setList(t)};ki=["i"],Ni=["Head(i) (data)"],Oi=["Tail(i) (next)"],Ii=[];for(let l=1;l<a.length;l++)ki.push(l),Ni.push(a[l-1]),Oi.push(l+1);Oi[a.length-1]="Null";const o=function t(n,a,o){if(Ii.unshift("(["+Ni[n]+"..],"+a+")"),e.add("Main",((e,t,n,a,r,i)=>{e.array.set(t,"msort_lista_td"),e.array.assignVariable("L",2,n);let o=t[2];for(let s=n;"Null"!==s;s=o[s])e.array.select(1,s,1,s,"0"),e.array.select(2,s,2,s,"0");s(e.array,i)}),[[ki,Ni,Oi],n,a,o,Ii],o),e.add("len>1",((e,t)=>{}),[[ki,Ni,Oi]],o),a>1){let r=Math.floor(a/2),l=n;e.add("Mid",((e,t,n,a,r)=>{e.array.assignVariable("Mid",2,a)}),[[ki,Ni,Oi],n,l,Ii],o);for(let e=1;e<r;e++)l=Oi[l];let d,c=Oi[l];Oi[l]="Null",e.add("tail(Mid)<-Null",((e,t,n,a,r,i)=>{e.array.set(t,"msort_lista_td"),s(e.array,i),e.array.assignVariable("L",2,n),e.array.assignVariable("Mid",2,a),e.array.assignVariable("R",2,r),e.array.select(1,n,1,n,"0"),e.array.select(2,n,2,n,"0"),e.array.select(1,r,1,r,"0"),e.array.select(2,r,2,r,"0")}),[[ki,Ni,Oi],n,l,c,Ii],o),e.add("preSortL",((e,t,n,a,r,i)=>{e.array.set(t,"msort_lista_td"),s(e.array,i),e.array.assignVariable("L",2,n),e.array.select(1,n,1,n,"0"),e.array.select(2,n,2,n,"0")}),[[ki,Ni,Oi],n,l,c,Ii],o),n=t(n,r,o+1),e.add("sortL",((e,t,n,a,r,i)=>{e.array.set(t,"msort_lista_td"),s(e.array,i),e.array.assignVariable("L",2,n),e.array.assignVariable("R",2,a);let o=t[2];for(let s=n;"Null"!==s;s=o[s])e.array.select(1,s,1,s,"1"),e.array.select(2,s,2,s,"1");e.array.select(1,a,1,a,"0"),e.array.select(2,a,2,a,"0")}),[[ki,Ni,Oi],n,c,l,Ii],o),e.add("preSortR",((e,t,n,a,r,i)=>{e.array.set(t,"msort_lista_td"),s(e.array,i),e.array.assignVariable("R",2,r),e.array.select(1,r,1,r,"0"),e.array.select(2,r,2,r,"0")}),[[ki,Ni,Oi],n,l,c,Ii],o),c=t(c,a-r,o+1),e.add("sortR",((e,t,n,a,r)=>{e.array.set(t,"msort_lista_td"),s(e.array,r),e.array.assignVariable("L",2,n),e.array.assignVariable("R",2,a),e.array.select(1,n,1,n,"0"),e.array.select(2,n,2,n,"0");let i=t[2];for(let s=a;"Null"!==s;s=i[s])e.array.select(1,s,1,s,"1"),e.array.select(2,s,2,s,"1")}),[[ki,Ni,Oi],n,c,Ii],o),Ni[n]<=Ni[c]?(d=n,n=Oi[n]):(d=c,c=Oi[c]);let h=d;for(e.add("E",((e,t,n,a,r,o,l)=>{e.array.set(t,"msort_lista_td"),s(e.array,l),i(e,"L",n),i(e,"R",a),e.array.assignVariable("M",2,r),e.array.assignVariable("E",2,o),"Null"!==n&&(e.array.select(1,n,1,n,"0"),e.array.select(2,n,2,n,"0")),"Null"!==a&&(e.array.select(1,a,1,a,"0"),e.array.select(2,a,2,a,"0")),e.array.select(1,r,1,r,"1"),e.array.select(2,r,2,r,"1")}),[[ki,Ni,Oi],n,c,d,h,Ii],o);"Null"!==n&&"Null"!==c;)e.add("whileNotNull",((e,t,n,a,r,o,l)=>{e.array.set(t,"msort_lista_td"),s(e.array,l),i(e,"L",n),i(e,"R",a),e.array.assignVariable("M",2,r),i(e,"E",o),"Null"!==n&&(e.array.select(1,n,1,n,"0"),e.array.select(2,n,2,n,"0")),"Null"!==a&&(e.array.select(1,a,1,a,"0"),e.array.select(2,a,2,a,"0"));let d=t[2];for(let i=r;i!==o;i=d[i])e.array.select(1,i,1,i,"1"),e.array.select(2,i,2,i,"1");"Null"!==o&&(e.array.select(1,o,1,o,"1"),e.array.select(2,o,2,o,"1"))}),[[ki,Ni,Oi],n,c,d,h,Ii],o),Ni[n]<=Ni[c]?(Oi[h]=n,h=n,n=Oi[n],e.add("popL",((e,t,n,a,r,o,l)=>{e.array.set(t,"msort_lista_td"),s(e.array,l),i(e,"L",n),i(e,"R",a),e.array.assignVariable("M",2,r),i(e,"E",o),"Null"!==n&&(e.array.select(1,n,1,n,"0"),e.array.select(2,n,2,n,"0")),"Null"!==a&&(e.array.select(1,a,1,a,"0"),e.array.select(2,a,2,a,"0"));let d=t[2];for(let i=r;i!==o;i=d[i])e.array.select(1,i,1,i,"1"),e.array.select(2,i,2,i,"1");"Null"!==o&&(e.array.select(1,o,1,o,"1"),e.array.select(2,o,2,o,"1"))}),[[ki,Ni,Oi],n,c,d,h,Ii],o)):(Oi[h]=c,h=c,c=Oi[c],e.add("popR",((e,t,n,a,r,o,l)=>{e.array.set(t,"msort_lista_td"),s(e.array,l),i(e,"L",n),i(e,"R",a),e.array.assignVariable("M",2,r),i(e,"E",o),"Null"!==n&&(e.array.select(1,n,1,n,"0"),e.array.select(2,n,2,n,"0")),"Null"!==a&&(e.array.select(1,a,1,a,"0"),e.array.select(2,a,2,a,"0"));let d=t[2];for(let i=r;i!==o;i=d[i])e.array.select(1,i,1,i,"1"),e.array.select(2,i,2,i,"1");"Null"!==o&&(e.array.select(1,o,1,o,"1"),e.array.select(2,o,2,o,"1"))}),[[ki,Ni,Oi],n,c,d,h,Ii],o));"Null"===n?(Oi[h]=c,e.add("appendR",((e,t,n,a,r,i,o)=>{e.array.set(t,"msort_lista_td"),s(e.array,o),e.array.assignVariable("M",2,r);let l=t[2];for(let s=r;"Null"!==s;s=l[s])e.array.select(1,s,1,s,"1"),e.array.select(2,s,2,s,"1")}),[[ki,Ni,Oi],n,c,d,h,Ii],o)):(Oi[h]=n,e.add("appendL",((e,t,n,a,r,i,o)=>{e.array.set(t,"msort_lista_td"),s(e.array,o),e.array.assignVariable("M",2,r);let l=t[2];for(let s=r;"Null"!==s;s=l[s])e.array.select(1,s,1,s,"1"),e.array.select(2,s,2,s,"1")}),[[ki,Ni,Oi],n,c,d,h,Ii],o)),e.add("returnM",((e,t,n,a,r)=>{e.array.set(t,"msort_lista_td"),s(e.array,r),e.array.assignVariable("L",2,void 0),e.array.assignVariable("R",2,void 0),e.array.assignVariable("E",2,void 0),e.array.assignVariable("M",2,a);let i=t[2];for(let s=a;"Null"!==s;s=i[s])e.array.select(1,s,1,s,"1"),e.array.select(2,s,2,s,"1")}),[[ki,Ni,Oi],n,d,Ii],o),n=d}else e.add("returnL",((e,t,n)=>{e.array.select(1,n,1,n,"1"),e.array.select(2,n,2,n,"1")}),[r,n],o);return Ii.shift(),n}(1,a.length-1,0);return o}};let ki,Ni,Oi,Ii;const Ci="transitiveClosure";let Si=()=>null,Mi=()=>null;function Bi(){return Si()}function Ti(e){return e||(e=Bi()),e.id.name===Ci}function Ri(){const e=Bi();return!!Ti(e)&&!e.collapse.transitiveClosure.tc.Reachable}window.getGlobalAlgotithm=Bi;let Li=[],Di=!1,Pi=!1;function Fi(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];const t=document.querySelectorAll("[j-tag=transitive_closure]")[0];t&&(t.style.opacity=e?1:0)}function Hi(e){Ri()?Li.push(e):e(),Pi||(Pi=!0,Fi(!1))}function _i(){Li.forEach((e=>{e()})),Li=[],Di=!1}function Gi(){if(Ri()){Bi().chunker._inPrevState,Di=!0}}function Vi(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];const t=document.querySelectorAll("[kth-tag=transitive_closure]")[0];t&&(t.style.opacity=e?1:0)}var zi={initVisualisers:()=>({graph:{instance:new er("key",null,"Transitive Closure"),order:0},array:{instance:new dr("array",null,"Matrix"),order:1}}),copyArr(e){const t=[];let n=0;const a=e.length;for(;n<a;n++)e[n]instanceof Array?t[n]=this.copyArr(e[n]):t[n]=e[n];return t},run(e,t){let{matrix:n,size:a}=t;const r=a,i=new Array(r);let s=0,o=0,l=0;e.add(1,(e=>{Vi(!0),e.array.set([...n],"tc"),e.graph.set([...n],Array.from({length:n.length},((e,t)=>t+1))),e.graph.layoutCircle(),e.graph.setIstc()}),[this.graph],[this.array]);for(let d=0;d<r;d++)i[d]=this.copyArr([...n]);for(let d=0;d<r;d++){e.add({bookmark:2,pauseInCollapse:!0},((e,t)=>{e.array.showKth(t+1),_i()}),[d]);for(let t=0;t<r;t++)if(e.add({bookmark:3,pauseInCollapse:!0},((e,t,n)=>{e.array.showKth(t+1),n>0&&(e.array.deselect(t,r-1),e.graph.leave1(o,l)),0===n&&t>0&&(e.array.deselect(t-1,r-1),e.graph.leave1(o,l)),_i()}),[d,t]),i[d][t][d]){e.add(4,((e,t,n)=>{e.graph.leave0(l,s),e.graph.leave0(s),t>0&&e.array.deselect(t-1,n),0===t&&n>0&&e.array.deselect(r-1,n-1),e.array.select(t,n),e.graph.visit0(t),e.graph.visit0(n,t),l=n,s=t}),[t,d]);for(let n=0;n<r;n++)if(e.add(5,(()=>{Gi()}),[]),i[d][d][n]){e.add(6,((e,t,n,a)=>{var i,s;Hi((i=o,s=l,()=>{e.graph.leave1(i,s)})),t>0&&(Hi((()=>{e.array.deselect(n,t-1)})),a===n&&n===t-1&&(e.array.select(n,t-1),e.graph.visit0(a))),0===t&&(Hi((()=>{e.array.deselect(n,r-1)})),a===n&&n===r-1&&(e.array.select(n,r-1),e.graph.visit0(a))),e.array.select(n,t,n,t,"1"),a===n&&n===t&&(e.array.select(n,t),e.graph.visit0(a)),e.graph.visit1(t,n,1),o=t,l=n}),[n,d,t]),e.add(7,((e,t,n)=>{e.array.data[t][n].value||(e.array.patch(t,n,"0->1"),e.graph.addEdge(t,n),e.graph.visit1(n,t,2))}),[t,n]),i[d][t][n]||e.add(7,((e,t,n)=>{Hi((()=>{e.array.depatch(t,n,1),e.graph.leave1(n,t,2)}))}),[t,n]);for(let e=d;e<r;e++)i[e][t][n]=1}else e.add(6,((e,t,n,a)=>{Hi((()=>{e.graph.leave1(o,l)})),n>0&&(Hi((()=>{e.array.deselect(t,n-1)})),a===t&&t===n-1&&(e.array.select(t,n-1),e.graph.visit0(a))),0===n&&(Hi((()=>{e.array.deselect(t,r-1)})),a===t&&t===r-1&&e.array.select(t,r-1)),e.array.select(t,n,t,n,"1"),a===t&&t===n&&(e.array.select(t,n),e.graph.visit0(a))}),[d,n,t])}else e.add(4,((e,t,n)=>{e.graph.leave0(l,s),e.graph.leave0(s),t>0&&e.array.deselect(t-1,n),0===t&&n>0&&e.array.deselect(r-1,n-1),e.array.select(t,n)}),[t,d])}return e.add({bookmark:8,pauseInCollapse:!0},(e=>{const t=r-1;e.graph.leave0(t),Vi(!1),Ri()?_i():(e.graph.leave1(t,t),e.array.deselect(t,t))}),[]),i.length?i[i.length-1]:i}},Qi=n(22),Ui=n.n(Qi);let Wi,qi=-1,Xi=!1;function Yi(){switch(arguments.length>0&&void 0!==arguments[0]?arguments[0]:0){case 1:Wi=Ui.a.graphgreen;break;case 2:Wi=Ui.a.graphblue;break;default:Wi=Ui.a.graph}return Wi}var Ki=class extends xa{constructor(e){super(e),this.elementRef=r.a.createRef(),this.selectedNode=null,this.ShowMsg=0,this.shiftcount=0,this.lastvisited=-1,this.hasGraph=!1,this.graphFinished=!1,this.togglePan(!0),this.toggleZoom(!0)}handleMouseDown(e){super.handleMouseDown(e);const t=this.computeCoords(e),{nodes:n,dimensions:a}=this.props.data,{nodeRadius:r}=a;this.selectedNode=n.find((e=>ga(t,e)<=r))}handleMouseMove(e){if(this.selectedNode){const{x:t,y:n}=this.computeCoords(e),a=this.props.data.findNode(this.selectedNode.id);a.x=t,a.y=n,this.refresh()}else super.handleMouseMove(e)}computeCoords(e){const t=this.elementRef.current,n=t.createSVGPoint();n.x=e.clientX,n.y=e.clientY;const{x:a,y:r}=n.matrixTransform(t.getScreenCTM().inverse());return{x:a,y:r}}renderData(){const{nodes:e,edges:t,isDirected:n,isWeighted:a,dimensions:r,text:i}=this.props.data,{baseWidth:s,baseHeight:o,nodeRadius:l,arrowGap:d,nodeWeightGap:h,edgeWeightGap:u}=r,p=[(this.centerX-s/4)/this.zoom,(this.centerY-o/4)/this.zoom,s/2/this.zoom,o/2/this.zoom],g=e[0];let m=0,f=0;g&&(m=g.x,f=g.y);let b=0,y=0,A=0;const x=e[0].x-2*l;let v="";e.length>1&&(b=e[1].StringLen,y=e[1].PatternLen,"bfsSearch"===e[1].algorithmName&&(v="bfsSearch",A=e[b-y-1].x),"horspools"===e[1].algorithmName&&(v="horspools",A=e[b-1].x));const j=e[0],w=e[b-1];let E=0,k=A,N=e[b+1].y;for(let c=0;c<e.length;c++)e[c].y<=N&&e[c].x<=k&&(k=e[c].x,N=e[c].y,E=e[c].id);for(let c=0;c<e.length;c++)e[c].y>0&&e[c].x===k&&(e[c].id===qi&&Xi?(this.shiftcount++,Xi=!1):e[c].id!==qi||Xi?(qi=e[c].id,Xi=!1):Xi=!0,this.shiftcount>y&&(this.shiftcount=y));let O=-1;for(let c=0;c<e.length;c++)1===e[c].selectedCount&&(O=e[c].id);const I=[],C=e[b],S=e[b+y-1];let M=e[b],B=e[y-1],T=!1,R=0;if("horspools"===v){for(let t=0;t<b;t++)if(1===e[t].selectedCount||1===e[t].visitedCount){B=e[t],I.push(e[t]),T=!0;break}for(let t=b;t>=b&&t<b+y;t++)if(1===e[t].selectedCount||1===e[t].visitedCount){M=e[t],I.push(e[t]),1===e[t].selectedCount&&(R=b+y-t);break}console.log("i=".concat(B.id,"\tj=").concat(M.id))}return Object(c.jsxs)("svg",{className:Yi(0),viewBox:p,ref:this.elementRef,children:[Object(c.jsxs)("defs",{children:[Object(c.jsx)("marker",{id:"markerArrow",markerWidth:"4",markerHeight:"4",refX:"2",refY:"2",orient:"auto",children:Object(c.jsx)("path",{d:"M0,0 L0,4 L4,2 L0,0",className:Ui.a.arrow})}),Object(c.jsx)("marker",{id:"markerArrowSelected",markerWidth:"4",markerHeight:"4",refX:"2",refY:"2",orient:"auto",children:Object(c.jsx)("path",{d:"M0,0 L0,4 L4,2 L0,0",className:pa(Ui.a.arrow,Ui.a.selected)})}),Object(c.jsx)("marker",{id:"markerArrowVisited",markerWidth:"4",markerHeight:"4",refX:"2",refY:"2",orient:"auto",children:Object(c.jsx)("path",{d:"M0,0 L0,4 L4,2 L0,0",className:pa(Ui.a.arrow,Ui.a.visited)})})]}),t.sort(((e,t)=>e.visitedCount-t.visitedCount)).map((e=>{const{source:t,target:r,weight:i,visitedCount:s,selectedCount:o}=e,h=this.props.data.findNode(t),p=this.props.data.findNode(r);if(!h||!p)return;const{x:g,y:m}=h;let{x:f,y:b}=p;const y=(g+f)/2,A=(m+b)/2,x=f-g,v=b-m,j=Math.atan2(v,x)/Math.PI*180;if(n){const e=Math.sqrt(x*x+v*v);0!==e&&(f=g+x/e*(e-l-d),b=m+v/e*(e-l-d))}return Object(c.jsxs)("g",{className:pa(Ui.a.edge,p.sorted&&Ui.a.sorted,o&&Ui.a.selected,s&&Ui.a.visited),children:[Object(c.jsx)("path",{d:"M".concat(g,",").concat(m," L").concat(f,",").concat(b),className:pa(Ui.a.line,n&&Ui.a.directed)}),a&&Object(c.jsx)("g",{transform:"translate(".concat(y,",").concat(A,")"),children:Object(c.jsx)("text",{className:Ui.a.weight,transform:"rotate(".concat(j,")"),y:-u,children:this.toString(i)})})]},"".concat(t,"-").concat(r))})),e.map((e=>{const{id:t,x:n,y:r,weight:i,visitedCount:s,selectedCount:o,value:d,key:u,style:p,sorted:g}=e,m=1===o,f=1===s;return Object(c.jsxs)(Ea.a.g,{animate:{x:n,y:r},initial:!1,transition:{duration:1},className:pa(Ui.a.node,m&&Ui.a.selected,g&&Ui.a.sorted,f&&Ui.a.visited),children:[Object(c.jsx)("rect",{className:Ui.a.circle,width:2*l,height:2*l,x:-l,y:-l}),Object(c.jsx)("text",{className:pa(Ui.a.id,p&&p.textStyle),children:d}),a&&Object(c.jsx)("text",{className:Ui.a.weight,x:l+h,children:this.toString(i)}),t===E&&"bfsSearch"===v?Object(c.jsx)("text",{style:{fill:"#2986CC"},y:4*-N,dy:".2em",children:"i"}):Object(c.jsx)(c.Fragment,{}),t===E&&O<0&&"bfsSearch"===v?Object(c.jsx)("text",{style:{fill:"#2986CC"},y:2*N,dy:".2em",children:"j"}):Object(c.jsx)(c.Fragment,{}),t===O&&O>=0&&"bfsSearch"===v?Object(c.jsx)("text",{style:{fill:"#2986CC"},y:2*N,dy:".2em",children:"j"}):Object(c.jsx)(c.Fragment,{}),t===M.id&&C.x!==j.x&&I.length>0&&"horspools"===v?Object(c.jsx)("text",{style:{fill:"#2986CC",textAlign:"centre"},y:2*M.y,dy:".2em",children:"m-j"}):Object(c.jsx)(c.Fragment,{}),t===M.id&&C.x!==j.x&&I.length>0&&"horspools"===v?Object(c.jsx)("text",{style:{fill:"#2986CC",textAlign:"centre"},y:6*-M.y,dy:".2em",children:"i-j"}):Object(c.jsx)(c.Fragment,{}),t===M.id&&t===S.id&&C.x===j.x&&I.length>0&&"horspools"===v?Object(c.jsx)("text",{style:{fill:"#2986CC",textAlign:"centre"},y:2*M.y,dy:".2em",children:"m-j"}):Object(c.jsx)(c.Fragment,{}),t===M.id&&t===S.id&&C.x===j.x&&I.length>0&&"horspools"===v?Object(c.jsx)("text",{style:{fill:"#2986CC",textAlign:"centre"},y:6*-M.y,dy:".2em",children:"i-j"}):Object(c.jsx)(c.Fragment,{}),t===S.id&&C.x!==j.x&&"horspools"===v?Object(c.jsx)("text",{style:{fill:"#2986CC"},y:4*-M.y,dy:".2em",children:"i"}):Object(c.jsx)(c.Fragment,{}),t===S.id&&C.x===j.x&&T&&"horspools"===v?Object(c.jsx)("text",{style:{fill:"#2986CC"},y:4*-M.y,dy:".2em",children:"i"}):Object(c.jsx)(c.Fragment,{}),t===S.id&&(C.x!==j.x||C.x===j.x&&T)&&"horspools"===v?Object(c.jsxs)("text",{style:{fill:"#2986CC"},x:w.x,y:8*M.y,dy:".2em",children:["j=",R]}):Object(c.jsx)(c.Fragment,{})]},u)})),e.map((e=>{const{id:t,x:n,y:a,visitedCount:r,Result:i}=e,s=r;return Object(c.jsxs)("g",{className:pa(Ui.a.node,s&&Ui.a.selected,r&&Ui.a.visited),transform:"translate(".concat(n,",").concat(a,")"),children:[null!==this.toString(i)?(this.ShowMsg+=1,this.ShowMsg=1,Object(c.jsx)("text",{x:"-20%",y:"20%",dy:".2em",children:this.toString(i)})):0===this.ShowMsg&&k!==A&&k>x&&E===t?Object(c.jsx)("text",{x:"-10%",y:"20%",dy:".2em",children:"Keep Seaching"}):Object(c.jsx)("text",{}),k===x?this.ShowMsg=0:Object(c.jsx)("text",{}),0===this.ShowMsg&&k===A&&E===t?Object(c.jsx)("text",{x:"-10%",y:"20%",dy:".2em",children:"Seaching Fail"}):Object(c.jsx)("text",{})]},t)})),Object(c.jsx)("text",{style:{fill:"#ff0000"},textAnchor:"middle",x:m,y:f-20,children:i})]})}};var Zi=class extends wa{getRendererClass(){return Ki}init(){super.init(),this.dimensions={baseWidth:480,baseHeight:480,padding:32,nodeRadius:12,arrowGap:4,nodeWeightGap:4,edgeWeightGap:4},this.isDirected=!0,this.isWeighted=!1,this.callLayout={method:this.layoutCircle,args:[]},this.text=null,this.logTracer=null}set(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];this.nodes=[],this.edges=[];for(let n=0;n<e.length;n++){this.addNode(n,t[n]?t[n]:n);for(let t=0;t<e.length;t++){const a=e[n][t];a&&this.addEdge(n,t,this.isWeighted?a:null)}}this.layout(),super.set()}clear(){this.edges.forEach((e=>{e.visitedCount=0,e.selectedCount=0})),this.nodes.forEach((e=>{e.visitedCount=0,e.selectedCount=0})),this.text=null}isEmpty(){return 0===this.nodes.length&&0===this.edges.length}getTree(){const e={},t=(e,t,n)=>{t<n?e[t].right=n:t>n&&(e[t].left=n)};return this.edges.forEach((n=>{e.hasOwnProperty(n.source)||(e[n.source]={}),t(e,n.source,n.target),e.hasOwnProperty(n.target)||(e[n.target]={})})),this.nodes.forEach((t=>{e.hasOwnProperty(t.id)||(e[t.id]={})})),e}getRoot(){if(0===this.edges.length&&1===this.nodes.length)return this.nodes[0].id;const e=this.edges.map((e=>e.source)),t=this.edges.map((e=>e.target));return[...new Set([...e,...t])].find((e=>!t.includes(e)))}setHeap(e){this.nodes=[],this.edges=[];for(let t=1;t<=e.length;t++)this.addNode(t,e[t-1]),2*t<=e.length&&this.addEdge(t,2*t),2*t+1<=e.length&&this.addEdge(t,2*t+1);this.layoutTree(1),this.directed(!1),this.layout(),super.set()}swapNodes(e,t){const n=this.findNode(e),a=n.value,r=this.findNode(t);n.value=r.value,r.value=a,this.layoutTree(this.root)}directed(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];this.isDirected=e}weighted(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];this.isWeighted=e}addNode(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:void 0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"circle",a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"blue",r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,s=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0,o=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,l=arguments.length>8&&void 0!==arguments[8]?arguments[8]:0;this.findNode(e)||(t=void 0===t?e:t,this.nodes.push({id:e,value:t,shape:n,color:a,weight:r,x:i,y:s,visitedCount:o,selectedCount:l}),this.layout())}addResult(e,t){this.findNode(t).Result=e}addStringLen(e,t){this.findNode(t).StringLen=e}addPatternLen(e,t){this.findNode(t).PatternLen=e}addAlgorithm(e,t){this.findNode(t).algorithmName=e}updateNode(e,t,n,a,r,i,s){const o=this.findNode(e),l={value:t,weight:n,x:a,y:r,visitedCount:i,selectedCount:s};Object.keys(l).forEach((e=>{void 0===l[e]&&delete l[e]})),Object.assign(o,l)}removeNode(e){const t=this.findNode(e);if(!t)return;const n=this.nodes.indexOf(t);this.nodes.splice(n,1),this.layout()}addEdge(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0;this.findEdge(e,t)||(this.edges.push({source:e,target:t,weight:n,visitedCount:a,selectedCount:r}),this.layout())}updateEdge(e,t,n,a,r){const i=this.findEdge(e,t),s={weight:n,visitedCount:a,selectedCount:r};Object.keys(s).forEach((e=>{void 0===s[e]&&delete s[e]})),Object.assign(i,s)}removeEdge(e,t){const n=this.findEdge(e,t);if(!n)return;const a=this.edges.indexOf(n);this.edges.splice(a,1),this.layout()}findValue(e){return this.findNode(e).value}findNode(e){return this.nodes.find((t=>t.id===e))}findEdge(e,t){return(arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.isDirected)?this.edges.find((n=>n.source===e&&n.target===t)):this.edges.find((n=>n.source===e&&n.target===t||n.source===t&&n.target===e))}findLinkedEdges(e){return(arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.isDirected)?this.edges.filter((t=>t.source===e)):this.edges.filter((t=>t.source===e||t.target===e))}findLinkedNodeIds(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.isDirected;return this.findLinkedEdges(e,t).map((t=>t.source===e?t.target:t.source))}findLinkedNodes(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.isDirected;return this.findLinkedNodeIds(e,t).map((e=>this.findNode(e)))}getRect(){const{baseWidth:e,baseHeight:t,padding:n}=this.dimensions,a=-e/2+n,r=-t/2+n,i=e/2-n,s=t/2-n;return{left:a,top:r,right:i,bottom:s,width:i-a,height:s-r}}layout(){const{method:e,args:t}=this.callLayout;e.apply(this,t)}layoutCircle(){this.callLayout={method:this.layoutCircle,args:arguments};const e=this.getRect(),t=2*Math.PI/this.nodes.length;let n=-Math.PI/2;for(const a of this.nodes){const r=Math.cos(n)*e.width/2,i=Math.sin(n)*e.height/2;a.x=r,a.y=i,n+=t}}shift(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1?arguments[1]:void 0;const n=t[0],a=t[1];let r=0;let i=-1;for(let s=0;s<n.length;s++){const e=this.findNode(r);e.shape="box",e.x=25*(s-n.length/2),0===s&&(i=e.x),e.y=15,r++}for(let s=0;s<a.length;s++){const t=this.findNode(r);t.shape="box",t.x=i+25*(s+e),t.y=-15,r++}}layoutBFSS(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1?arguments[1]:void 0;this.callLayout={method:this.layoutBFSS,args:arguments};const n=t[0],a=t[1];let r=0;let i=-1;for(let s=0;s<n.length;s++){const e=this.findNode(r);e.shape="square",e.x=25*(s-n.length/2),0===s&&(i=e.x),e.y=15,r++}for(let s=0;s<a.length;s++){const t=this.findNode(r);t.shape="square",t.x=i+(25*s+25*e),t.y=-15,r++}}layoutTree(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];this.root=e,this.callLayout={method:this.layoutTree,args:arguments};const n=this.getRect();if(1===this.nodes.length){const[e]=this.nodes;return e.x=(n.left+n.right)/2,void(e.y=(n.top+n.bottom)/2)}let a=0;const r={};let i={};const s=(e,t)=>{i[e]=!0,r[e]=0,a<t&&(a=t);const n=this.findLinkedNodeIds(e,!1);for(const a of n)i[a]||(r[e]+=s(a,t+1));return 0===r[e]&&(r[e]=1),r[e]};s(e,0);const o=n.width/r[e],l=n.height/a;i={};const d=(e,a,s)=>{i[e.id]=!0,e.x=n.left+(a+r[e.id]/2)*o,e.y=n.top+s*l;const c=this.findLinkedNodes(e.id,!1);t&&c.sort(((e,t)=>e.id-t.id));for(const t of c)i[t.id]||(d(t,a,s+1),a+=r[t.id])},c=this.findNode(e);d(c,0,0)}layoutBST(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];this.root=e,this.callLayout={method:this.layoutBST,args:arguments};const n=this.getRect(),a=(n.left+n.right)/2,r=(n.top+n.bottom)/2;if(1===this.nodes.length){const[e]=this.nodes;return e.x=a,void(e.y=r)}let i=0;const s={};let o={};const l=(e,t)=>{o[e]=!0,s[e]=t,i<t&&(i=t);const n=this.findLinkedNodeIds(e,!1);for(const a of n)o[a]||l(a,t+1)};l(e,0);const d=n.height/i;o={};const c=(e,a,r)=>{o[e.id]=!0,e.x=n.left+80*a+120,e.y=n.top+r*d;const i=this.findLinkedNodes(e.id,!1);t&&i.sort(((e,t)=>e.id-t.id));for(const t of i)o[t.id]||(t.id>e.id?(e.id,this.root,c(t,a+1/(r*r+1),r+1)):t.id<e.id&&(e.id<this.root?c(t,a-1/(r*r+1),r+1):c(t,a-1/(2*r+1),r+1)))},h=this.findNode(e);c(h,0,0)}layoutRandom(){this.callLayout={method:this.layoutRandom,args:arguments};const e=this.getRect(),t=[];for(const n of this.nodes){do{n.x=e.left+Math.random()*e.width,n.y=e.top+Math.random()*e.height}while(t.find((e=>ga(n,e)<48)));t.push(n)}}visit(e,t,n){this.visitOrLeave(!0,e,t,n)}leave(e,t,n){this.visitOrLeave(!1,e,t,n)}visitOrLeave(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,a=arguments.length>3?arguments[3]:void 0;const r=this.findEdge(n,t);r&&(r.visitedCount+=e?1:-1);const i=this.findNode(t);void 0!==a&&(i.weight=a),i.visitedCount+=e?1:-1,this.logTracer&&this.logTracer.println(e?(n||"")+" -> "+t:(n||"")+" <- "+t)}select(e,t){this.selectOrDeselect(!0,e,t)}deselect(e,t){this.selectOrDeselect(!1,e,t)}resetSelect(e,t){const n=this.findEdge(t,e);n&&(n.selectedCount=0);this.findNode(e).selectedCount=0}selectOrDeselect(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;const a=this.findEdge(n,t);a&&(a.selectedCount+=e?1:-1);this.findNode(t).selectedCount+=e?1:-1,this.logTracer&&this.logTracer.println(e?(n||"")+" => "+t:(n||"")+" <= "+t)}log(e){this.logTracer=e?this.getObject(e):null}setText(e){this.text=e,this.text.push({text:e})}},Ji={explanation:j,initVisualisers:()=>({graph:{instance:new Zi("bst",null,"Brute force string search"),order:0}}),run(e,t){let{nodes:n}=t;const a=n[0],r=n[1];e.add("1",((e,t)=>{e.graph.addNode(0,a[0],"box");for(let i=1;i<a.length;i++)e.graph.addNode(i,a[i],"box"),e.graph.addEdge(i,i-1),e.graph.addStringLen(a.length,i),e.graph.addPatternLen(r.length,i),e.graph.addAlgorithm("bfsSearch",i);e.graph.addNode(a.length,r[0]);const n=a.length;for(let a=1;a<r.length;a++)e.graph.addNode(n+a,r[a],"box"),e.graph.addEdge(n+a,n+a-1);e.graph.shift(0,t)}),[n]);for(let s=0;s<a.length-r.length+1;s++){e.add("2",((e,t,n)=>{e.graph.shift(t,n)}),[s,n]);for(let t=0;t<r.length;t++){if(e.add("3",((e,t,n,i)=>{e.graph.addEdge(a.length+n,t+n),a[t+n]!==r[n]?(e.graph.visit(a.length+n),e.graph.visit(t+n,null)):(e.graph.select(a.length+n,t+n),e.graph.select(t+n,null)),e.graph.shift(t,i)}),[s,t,n]),a[s+t]!==r[t]){e.add("3",((e,t,n,r)=>{for(let i=0;i<=n;i++)i===n?(e.graph.leave(a.length+i),e.graph.leave(t+i,null)):(e.graph.deselect(a.length+i),e.graph.deselect(t+i,null)),e.graph.removeEdge(a.length+i,t+i);e.graph.shift(t,r)}),[s,t,n]);break}if(t===r.length-1)return void e.add("5",((e,t,n,a)=>{const r="Success: pattern found position ".concat(t);e.graph.addResult(r,t)}),[s,t,n]);e.add("4",((e,t,n,a)=>{}),[s,t,n])}}const i=r.length;e.add("6",((e,t,n)=>{e.graph.addResult("Pattern not found",t)}),[i,n])}},$i=n(20),es=n.n($i);let ts;function ns(){switch(arguments.length>0&&void 0!==arguments[0]?arguments[0]:0){case 1:ts=es.a.array_2d_green;break;case 2:ts=es.a.array_2d_blue;break;default:ts=es.a.array_2d}return ts}var as=class extends xa{constructor(e){super(e),this.togglePan(!0),this.toggleZoom(!0)}renderData(){const{data:e,data1:t,algo:n}=this.props.data;let a=e.reduce(((e,t)=>e.length<t.length?t:e),[]);return Object(c.jsx)("table",{className:ns(0),style:{marginLeft:2*-this.centerX,marginTop:2*-this.centerY,transform:"scale(".concat(this.zoom,")")},children:Object(c.jsxs)("tbody",{children:[Object(c.jsxs)("tr",{className:es.a.row,children:[!1,a.map(((e,t)=>("horspools"===n&&(t=""),Object(c.jsx)("td",{className:pa(es.a.col,es.a.index),children:Object(c.jsx)("span",{className:es.a.value,children:t})},t))))]}),e.map(((e,t)=>Object(c.jsxs)("tr",{className:es.a.row,children:[!1,e.map(((e,t)=>Object(c.jsx)("td",{className:pa(es.a.col,e.selected&&es.a.selected,e.patched&&es.a.patched,e.sorted&&es.a.sorted),children:Object(c.jsx)("span",{className:es.a.value,children:this.toString(e.value)})},t)))]},t))),Object(c.jsx)("td",{style:{paddingBottom:"15px"}}),t.map(((e,t)=>Object(c.jsxs)("tr",{className:es.a.row,children:[!1,e.map(((e,t)=>Object(c.jsx)("td",{className:pa(es.a.col,e.selected&&es.a.selected,e.patched&&es.a.patched,e.sorted&&es.a.sorted),children:Object(c.jsx)("span",{className:es.a.value,children:this.toString(e.value)})},t)))]},t)))]})})}};class rs{constructor(e){this.value=e,this.patched=!1,this.selected=!1,this.sorted=!1}}var is=class extends wa{getRendererClass(){return as}set(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[],n=arguments.length>2?arguments[2]:void 0;this.data=e.map((e=>[...e].map((e=>new rs(e))))),this.data1=t.map((e=>[...e].map((e=>new rs(e))))),this.algo=n,super.set()}getposition(e,t){let n=this.data.reduce(((e,t)=>e.length<t.length?t:e),[]).length;var a=e,r=0;return e>=n&&(a=e-n,r=1),[r,a,t]}patch(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.data[e][t].value,a=this.getposition(e,t);var r=a[0],i=a[2],s=a[1];0===r?(this.data[i][s]||(this.data[i][s]=new rs),this.data[i][s].value=n,this.data[i][s].patched=!0):(this.data1[i][s]||(this.data1[i][s]=new rs),this.data1[i][s].value=n,this.data1[i][s].patched=!0)}depatch(e,t){let n=this.getposition(e,t);var a=n[0],r=n[2],i=n[1];0===a?(this.data[r][i]||(this.data[r][i]=new rs),this.data[r][i].patched=!1):(this.data1[r][i]||(this.data1[r][i]=new rs),this.data1[r][i].patched=!1)}select(e,t){let n=this.getposition(e,t);var a=n[0],r=n[2],i=n[1];0===a?(this.data[r][i]||(this.data[r][i]=new rs),this.data[r][i].selected=!0):(this.data1[r][i]||(this.data1[r][i]=new rs),this.data1[r][i].selected=!0)}deselect(e,t){let n=this.getposition(e,t);var a=n[0],r=n[2],i=n[1];0===a?this.data[r][i].selected=!1:this.data1[r][i].selected=!1}},ss={explanation:M,initVisualisers:()=>({array:{instance:new is("array",null,"Shift Table"),order:0},graph:{instance:new Zi("hsp",null,"Horspool String Search"),order:1}}),run(e,t){let{nodes:n}=t;const a=n[0],r=n[1],i=["a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z","space"],s=new Array(i.length).fill(r.length);e.add("1",((e,t)=>{e.graph.addNode(0,a[0],"box");for(let i=1;i<a.length;i++)e.graph.addNode(i,a[i],"box"),e.graph.addEdge(i,i-1),e.graph.addStringLen(a.length,i),e.graph.addPatternLen(r.length,i),e.graph.addAlgorithm("horspools",i);e.graph.addNode(a.length,r[0]);const n=a.length;for(let a=1;a<r.length;a++)e.graph.addNode(n+a,r[a],"box"),e.graph.addEdge(n+a,n+a-1);e.graph.shift(0,t)}),[n]),e.add("2",((e,t)=>{e.array.set([i.slice(0,13),new Array(13)],[i.slice(13,27),new Array(14)],"horspools")}),[n]);for(let g=0;g<i.length;g++)e.add("3",((e,t)=>{e.array.patch(i.indexOf(i[g]),1,r.length)}),[n]),e.add("2",((e,t)=>{e.array.depatch(i.indexOf(i[g]),1,r.length)}),[n]);for(let g=0;g<r.length-1;g++){let t=r[g].toLowerCase();" "===t&&(t="space"),s[i.indexOf(t)]=r.length-(g+1),e.add("5",((e,n)=>{e.graph.select(a.length+n),e.array.patch(i.indexOf(t),1,r.length-(n+1))}),[g]),e.add("4",((e,n)=>{e.graph.deselect(a.length+n),e.array.depatch(i.indexOf(t),1)}),[g])}const o=r.length,l=o;e.add("6",((e,t)=>{}),[n]);let d=0;const c=[],h=[];let u=0,p=0;for(let g=o;g<a.length+1;g+=d){let e=a[g-1].toLowerCase();" "===e&&(e="space"),d=s[i.indexOf(e)],c.push(u+d),h.push(d),u+=d}for(let g=o;g<a.length+1;g+=h.shift()){e.add("11",((e,t)=>{if(-1!==t){let n=a[t];" "===n&&(n="space"),e.array.deselect(i.indexOf(n),1),e.graph.deselect(t,null)}}),[p-1]),e.add("13",((e,t)=>{}),[n]);for(let i=0;i<r.length;i++){if(e.add("8",((e,t,n,i)=>{a[t-n-1]!==r[o-n-1]?(e.graph.visit(a.length+o-n-1),e.graph.visit(t-n-1,null)):(e.graph.select(a.length+o-n-1,t-n-1),e.graph.select(t-n-1,null))}),[g,i,n]),a[g-i-1]!==r[o-i-1]){e.add("8",((e,t,n,r)=>{for(let s=0;s<=i;s++)s===i?(e.graph.leave(a.length+o-s-1),e.graph.leave(t-s-1,null)):(e.graph.deselect(a.length+o-s-1),e.graph.deselect(t-s-1,null)),e.graph.removeEdge(a.length+o-s-1,t-s-1)}),[g,i,n]);break}if(i===r.length-1)return void e.add("10",((e,t,n,a)=>{const r="Success: pattern found position ".concat(t-n);e.graph.addResult(r,t)}),[g,i,n]);e.add("9",((e,t,n,a)=>{}),[g,i,n])}e.add("14",((e,t)=>{}),[n]),e.add("15",((e,t)=>{}),[n]);const t=c.shift();e.add("7",((e,t,n,r)=>{let s=a[n];" "===s&&(s="space"),e.array.select(i.indexOf(s),1),e.graph.select(n,null)}),[t,g-1,n]),e.add("7",((e,t,n,r)=>{t+o<=a.length&&e.graph.shift(t,r)}),[t,g-1,n]),p=g}e.add("12",((e,t)=>{if(-1!==t){let n=a[t];" "===n&&(n="space"),e.array.deselect(i.indexOf(n),1),e.graph.deselect(t,null)}e.graph.addResult("Pattern not found",l)}),[p-1])}},os=n(35),ls=n.n(os);let ds;function cs(){switch(arguments.length>0&&void 0!==arguments[0]?arguments[0]:0){case 1:ds=ls.a.graphgreen;break;case 2:ds=ls.a.graphblue;break;default:ds=ls.a.graph}return ds}var hs=class extends xa{constructor(e){super(e),this.elementRef=r.a.createRef(),this.selectedNode=null,this.togglePan(!0),this.toggleZoom(!0)}handleMouseDown(e){super.handleMouseDown(e);const t=this.computeCoords(e),{nodes:n,dimensions:a}=this.props.data,{nodeRadius:r}=a;this.selectedNode=n.find((e=>ga(t,e)<=r))}handleMouseMove(e){if(this.selectedNode){const{x:t,y:n}=this.computeCoords(e),a=this.props.data.findNode(this.selectedNode.id);a.x=t,a.y=n,this.refresh()}else super.handleMouseMove(e)}computeCoords(e){const t=this.elementRef.current,n=t.createSVGPoint();n.x=e.clientX,n.y=e.clientY;const{x:a,y:r}=n.matrixTransform(t.getScreenCTM().inverse());return{x:a,y:r}}renderData(){const{nodes:e,edges:t,isDirected:n,showSelfLoop:a,variableNodes:r,isReversed:i,dimensions:s,text:o,baseOffset:l,functionName:d}=this.props.data,{baseWidth:h,baseHeight:u,nodeRadius:p,arrowGap:g}=s,m=[(this.centerX-h/2)/this.zoom,(this.centerY-u/2)/this.zoom,h/this.zoom,u/this.zoom],f=e[0];let b=0,y=0;f&&(b=f.x,y=f.y);const A=i?.5:1;return Object(c.jsxs)("svg",{className:cs(0),viewBox:m,ref:this.elementRef,children:[Object(c.jsx)("defs",{children:Object(c.jsx)("marker",{id:"markerArrow",markerWidth:"".concat(6*A),markerHeight:"".concat(6*A),refX:"".concat(3*A),refY:"".concat(3*A),orient:"auto",children:Object(c.jsx)("path",{d:"M0,0 L0,".concat(6*A," L").concat(6*A,",").concat(3*A," L0,0"),className:ls.a.arrow})})}),t.map((e=>{const{source:t,target:s}=e;let o,l;if(r){if(o=this.props.data.findVariableNode(t),l=this.props.data.findVariableNode(s),0===o.id)return}else o=this.props.data.findNode(t),l=this.props.data.findNode(s);if(!o||!l)return;let d=null;if(o==l&&a){const{x:e,y:t}=o,a=1.1*p,r=1.1*p,i=n?g:0,s=Math.PI/180*210,l="".concat(e+p*Math.cos(s),",").concat(t+p*Math.sin(s)),c=Math.PI/180*330,h="".concat(e+(p+i)*Math.cos(c),",").concat(t+(p+i)*Math.sin(c));d="M".concat(l," A").concat(a,",").concat(r," 0 1,1 ").concat(h)}else{let e,a,r,c;i?(({x:e,y:a}=l),({x:r,y:c}=o)):(({x:e,y:a}=o),({x:r,y:c}=l));const h=r-e,u=c-a;if(n){const t=Math.sqrt(h*h+u*u);0!==t&&(r=e+h/t*(t-p-2*g*A),c=a+u/t*(t-p-2*g*A))}if(this.props.data.isInterConnected(t,s)){const{cx:t,cy:n}=Ja(e,a,r,c);d="M".concat(e,",").concat(a," Q").concat(t,",").concat(n,",").concat(r,",").concat(c)}else d="M".concat(e,",").concat(a," L").concat(r,",").concat(c)}return Object(c.jsx)("g",{className:pa(ls.a.edge),children:Object(c.jsx)("path",{d:d,className:pa(ls.a.line,n&&ls.a.directed)})},"".concat(t,"-").concat(s))})),e.map((e=>{const{x:t,y:n,fill:a,value:r,shape:i,key:s}=e,o=1===a,l=2===a,d=3===a;return Object(c.jsxs)(Ea.a.g,{animate:{x:t,y:n},initial:!1,transition:{duration:1},className:pa(ls.a.node,o&&ls.a.variableGreen,l&&ls.a.variableOrange,d&&ls.a.variableRed),children:["square"===i?Object(c.jsx)("rect",{className:ls.a.circle,width:2*p,height:2*p,x:-p,y:-p}):Object(c.jsx)("circle",{className:pa(ls.a.circle),r:p}),Object(c.jsx)("text",{className:pa(ls.a.id),children:r})]},s)})),Object(c.jsxs)("text",{className:pa(ls.a.text),x:"0",y:"".concat(s.baseHeight/2-this.props.data.baseOffset),children:[Object(c.jsx)("tspan",{className:ls.a.pseudocode_function,children:this.props.data.functionName}),o]})]})}};var us=class{constructor(e){this.id=e,this.parent=null,this.children=[],this.x=null,this.y=null,this.level=null,this.prelimx=0,this.modifier=0,this.rank=0}getIDs(){return[this.id]}getNodeLength(){return 1}addChild(e){e.parent=this,this.children.push(e)}getParent(){return this.parent}getLeftSibling(){if(null==this.getParent())return null;const e=this.getParent().getChildIndex(this);return e-1>=0?this.getParent().children[e-1]:null}getChildIndex(e){return this.children.findIndex((t=>t.id===e.id))}getRightSibling(){if(null==this.getParent())return null;const e=this.getParent().getChildIndex(this);return e+1<this.getParent().children.length?this.getParent().children[e+1]:null}getLeftNeighbour(e){const t=this.getLeftSibling();if(null==t){const t=e[this.level],n=t.findIndex((e=>e.id===this.id));return 0!==n?t[n-1]:null}return t}};var ps=class extends us{constructor(e){super(e),this.relatedNodeIDs=[]}getNodeId(){return this.id}getIDs(){return this.relatedNodeIDs}addRelatedNodeID(e){this.relatedNodeIDs.includes(e)||(this.relatedNodeIDs.push(e),this.relatedNodeIDs.sort(((e,t)=>e-t)))}removeRelatedNodeID(e){const t=this.relatedNodeIDs.indexOf(e);-1!==t&&this.relatedNodeIDs.splice(t,1)}clearRelatedNodeIDs(){this.relatedNodeIDs=[]}getNodeLength(){return this.relatedNodeIDs.length}hasRelatedNodeID(e){return this.relatedNodeIDs.includes(e)}};var gs=class extends wa{getRendererClass(){return hs}init(){super.init(),this.dimensions={baseWidth:1e3,baseHeight:480,padding:32,nodeRadius:20,arrowGap:4,nodeWeightGap:4,edgeWeightGap:4},this.isDirected=!0,this.showSelfLoop=!0,this.callLayout={method:this.layoutNTree,args:[]},this.realEdges=[],this.realNodes=[],this.variableNodes=!1,this.isReversed=!1,this.SiblingSeparation=50,this.xTopAdjustment=0,this.yTopAdjustment=0,this.maxDepth=5e4,this.SubtreeSeparation=50,this.LevelSeparation=100,this.levels=null,this.functionName="",this.text=null,this.swap=!1,this.baseOffset=20}set(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];this.nodes=[],this.edges=[];for(let n=0;n<e.length;n++){this.addNode(n,t[n]?t[n]:n);for(let t=0;t<e.length;t++){e[n][t]&&this.addEdge(n,t,null)}}this.layout(),super.set()}isEmpty(){return 0===this.nodes.length&&0===this.edges.length}getNTree(){const e={},t=new Set(this.realNodes.map((e=>e.id)));if(0===this.realNodes.length)return null;this.realNodes.forEach((t=>{let n;this.variableNodes?(n=new ps(t.id),t.nodeIDs.forEach((e=>n.addRelatedNodeID(e)))):n=new us(t.id),n.x=0,n.y=0,e[t.id]=n})),this.realEdges.forEach((n=>{const a=e[n.source],r=e[n.target];a&&r&&!a.children.includes(r)&&(a.children.push(r),r.parent=a,t.delete(r.id))}));const n=[],a=[],r=e[Array.from(t)[0]];for(r.level=0,n.push(r);n.length;){const e=n.shift();a[e.level]?a[e.level].push(e):a[e.level]=[e],e.children.forEach((t=>{t.level=e.level+1,n.push(t)}))}return{tree:r,levels:a}}getRoot(){if(0===this.edges.length&&1===this.realNodes.length)return this.realNodes[0].id;const e=this.edges.map((e=>e.source)),t=this.edges.map((e=>e.target));return[...new Set([...e,...t])].find((e=>!t.includes(e)))}swapNodes(e,t){this.swap=!0;const n=this.findNode(e.toString()),a=this.findNode(t.toString());for(const r of this.realEdges)r.source===n.id?r.source=a.id:r.source===a.id&&(r.source=n.id),r.target===n.id?r.target=a.id:r.target===a.id&&(r.target=n.id);for(const r of this.edges)r.source===n.id?r.source=a.id:r.source===a.id&&(r.source=n.id),r.target===n.id?r.target=a.id:r.target===a.id&&(r.target=n.id)}directed(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];this.isDirected=e}isParent(e,t){for(const n of this.realEdges)if(n.source===e&&n.target===t)return!0;return!1}addNode(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:void 0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"circle",a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;if(this.findNode(e))return;t=void 0===t?e:t,this.variableNodes||this.realNodes.push({id:e,x:r,y:i});const s=e;"0"!==e&&this.nodes.push({id:e,value:t,shape:n,fill:a,x:r,y:i,key:s})}addVariableNode(e,t){if(!this.variableNodes)return;const n=this.realNodes.findIndex((t=>t.id===e));-1===n?this.realNodes.push({id:e,x:0,y:0,nodeIDs:[t]}):(this.realNodes[n].nodeIDs.push(t),this.realNodes[n].nodeIDs.sort(((e,t)=>e-t))),this.addNode(t,void 0,"square")}removeFullNode(e){this.variableNodes&&(this.realNodes=this.realNodes.filter((t=>t.id!==e)),this.realEdges=this.realEdges.filter((t=>t.source!==e&&t.target!==e)),this.edges=this.edges.filter((t=>t.source!==e&&t.target!==e)))}removeNode(e){if(this.variableNodes)for(const a of this.realNodes)if(a.nodeIDs.includes(e)){const t=a.nodeIDs.indexOf(e);a.nodeIDs.splice(t,1)}const t=this.findNode(e);if(!t)return;const n=this.nodes.indexOf(t);this.nodes.splice(n,1),this.layout()}addEdge(e,t){this.findEdge(e,t)||("0"!==e&&this.edges.push({source:e,target:t}),e!==t&&this.realEdges.push({source:e,target:t}))}removeEdge(e,t){const n=this.edges.filter((n=>!(n.source===e&&n.target===t))),a=this.realEdges.filter((n=>!(n.source===e&&n.target===t)));this.edges=n,this.realEdges=a}findValue(e){return this.findNode(e).value}findNode(e){return this.nodes.find((t=>t.id===e))}findVariableNode(e){if(this.variableNodes)return this.realNodes.find((t=>t.id===e))}findEdge(e,t){return(arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.isDirected)?this.edges.find((n=>n.source===e&&n.target===t)):this.edges.find((n=>n.source===e&&n.target===t||n.source===t&&n.target===e))}getRect(){const{baseWidth:e,baseHeight:t,padding:n}=this.dimensions,a=-e/2+n,r=-t/2+n,i=e/2-n,s=t/2-n;return{left:a,top:r,right:i,bottom:s,width:i-a,height:s-r}}layout(){const{method:e,args:t}=this.callLayout;e.apply(this,t)}meanNodeSize(e,t){return(e.getNodeLength()*(2*this.dimensions.nodeRadius)+t.getNodeLength()*(2*this.dimensions.nodeRadius))/2}getLeftMost(e,t,n){if(t>=n)return e;if(0===e.children.length)return null;{let a=e.children[0],r=this.getLeftMost(a,t+1,n);for(;!r&&a.getRightSibling();)a=a.getRightSibling(),r=this.getLeftMost(a,t+1,n);return r}}apportion(e,t){let n=e.children[0],a=n.getLeftNeighbour(this.levels),r=1;const i=this.maxDepth-t;for(;n&&a&&r<=i;){let t=0,i=0,s=n,o=a;for(let e=0;e<r;e++)s=s.getParent(),o=o.getParent(),i+=s.modifier,t+=o.modifier;let l=a.prelimx+t+this.SubtreeSeparation+this.meanNodeSize(n,a)-(n.prelimx+i);if(l>0){let t=e,n=0;for(;t&&t!==o;)n++,t=t.getLeftSibling();if(!t)return;{const a=l/n;for(t=e;t!==o;)t.prelimx+=l,t.modifier+=l,l-=a,t=t.getLeftSibling()}}r++,n=0===n.children.length?this.getLeftMost(e,0,r):n.children[0],n&&(a=n.getLeftNeighbour(this.levels))}}firstWalk(e,t){if(0===e.children.length){const t=e.getLeftSibling();e.prelimx=null!==t?t.prelimx+this.SiblingSeparation+this.meanNodeSize(t,e):0}else{e.children.forEach((e=>this.firstWalk(e,t+1)));const n=(e.children[0].prelimx+e.children[e.children.length-1].prelimx)/2;null!==e.getLeftSibling()?(e.prelimx=e.getLeftSibling().prelimx+this.SiblingSeparation+this.meanNodeSize(e.getLeftSibling(),e),e.modifier=e.prelimx-n,this.apportion(e,t)):e.prelimx=n}}secondWalk(e,t,n){let a=!0;if(t<=this.maxDepth){const r=this.xTopAdjustment+e.prelimx+n,i=this.yTopAdjustment+t*this.LevelSeparation;e.x=r,e.y=i,0!==e.children.length&&(a=this.secondWalk(e.children[0],t+1,n+e.modifier)),a&&null!==e.getRightSibling()&&(a=this.secondWalk(e.getRightSibling(),t,n))}return a}getVariableNode(e){if(this.variableNodes)return this.realNodes.find((t=>t.varID===e))}translateCoords(){const e=[].concat(...this.levels);let t=308-100*(this.levels.length-2);e.forEach((e=>{if(this.variableNodes){const n=this.findVariableNode(e.id);n.x=e.x,n.y=e.y+t-1.5*this.baseOffset;let a=e.getNodeLength();const r=this.nodes.filter((t=>e.getIDs().includes(t.id)));if(r.sort(((e,t)=>e.id-t.id)),r){const n=this.dimensions.nodeRadius,i=n*a;r.forEach(((r,s)=>{let o;1===a&&(o=e.x),o=2===a?e.x+s*n*2-n:3===a?e.x+(s-1)*n*2:e.x-i+s*n*2+n,r.x=o,r.y=e.y+t-1.5*this.baseOffset}))}}else{const t=this.nodes.find((t=>t.id===e.id));t&&(t.x=e.x,t.y=e.y)}}))}layoutNTree(){this.callLayout={method:this.layoutNTree,args:arguments};const e=this.getRect();if(0===this.realNodes.length)return;if(1===this.realNodes.length&&!this.variableNodes){const[t]=this.realNodes;return t.x=(e.left+e.right)/2,void(t.y=(e.top+e.bottom)/2)}const{tree:t,levels:n}=this.getNTree();this.levels=n,t.x=(e.left+e.right)/2,t.y=e.top,null!==t&&(this.firstWalk(t,0),this.xTopAdjustment=t.x-t.prelimx,this.yTopAdjustment=t.y,this.secondWalk(t,0,0),this.translateCoords())}addSelfLoop(e){this.findNode(e)&&this.addEdge(e,e)}fill(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=this.findNode(e);n&&(n.fill=1===t||2===t||3===t?t:0)}unfill(e){const t=this.findNode(e);t&&(t.fill=0)}isInterConnected(e,t){return this.edges.find((n=>n.source===e&&n.target===t))&&this.edges.find((n=>n.source===t&&n.target===e))}extractNTree(){return this.unfillAll(),{realNodes:this.realNodes,realEdges:this.realEdges,nodes:this.nodes,edges:this.edges}}setNTree(e,t,n,a){this.realNodes=e,this.realEdges=t,this.nodes=n,this.edges=a}unfillAll(){this.text=null,this.nodes.forEach((e=>{e.fill=0}))}setText(e){this.text=e}setFunctionName(e){this.functionName=e}},ms={initVisualisers(e){let{visualiser:t}=e;return t.tree.instance.unfillAll(),{array:{instance:new dr("array",null,"Array View"),order:0},tree:{instance:new gs("n-tree",null,"Tree View"),order:1}}},run(e,t){let{visualiser:n,target:a,mode:r}=t;const i=a.arg1,s=a.arg2;let o=this.extractParentArray(n),{realNodes:l,realEdges:d,nodes:c,edges:h}=n.tree.instance.extractNTree();e.add("while n != parent[n]",((e,t)=>{e.array.set([As,t],"unionFind"),e.tree.setNTree(l,d,c,h),e.tree.isReversed=!0,e.tree.layout()}),[o]),this.find(e,o,i,"n",null,s,r)},extractParentArray(e){let t=e.array.instance.data[1].map((e=>parseInt(e.value,10)));return t[0]="Parent[i]",t},notAtRoot:(e,t,n)=>(e.add("while n != parent[n]",((e,t)=>{js.unhighlight(e.array,ys,t,!0),js.highlight(e.array,ys,t,fs.ORANGE)}),[n]),t[n]!=n),find(e,t,n,a,r,i,s){for(e.add("while n != parent[n]",((e,t)=>{e.array.setMotion(!0),js.highlight(e.array,bs,t,fs.ORANGE),js.highlight(e.tree,t,t,fs.ORANGE)}),[n]);this.notAtRoot(e,t,n);){e.add("while n != parent[n]",((e,t)=>{js.highlight(e.array,bs,t,fs.RED),js.highlight(e.array,ys,t,fs.RED),js.highlight(e.tree,t,t,fs.RED)}),[n]),i&&this.shortenPath(e,t,n);let s=n;n=t[n],e.add("n <- parent[n]",((e,t,n,r)=>{e.array.assignVariable("".concat(a),bs,t),t!==n&&null!==n&&js.highlight(e.array,bs,n,fs.GREEN),js.highlight(e.array,bs,t,fs.ORANGE),js.highlight(e.array,ys,r,fs.ORANGE),js.highlight(e.tree,t,t,fs.ORANGE),js.unhighlight(e.tree,r,r)}),[n,r,s])}return e.add("while n != parent[n]",((e,t)=>{js.highlight(e.array,bs,t,fs.GREEN),js.highlight(e.array,ys,t,fs.GREEN),js.highlight(e.tree,t,t,fs.GREEN)}),[n]),e.add("find"===s?"return n":"".concat(a," <- Find(").concat(a,")"),((e,t)=>{js.unhighlight(e.array,ys,t)}),[n]),n},shortenPath(e,t,n){if(e.add("parent[n] <- parent[parent[n]]",((e,t,n,a)=>{js.unhighlight(e.array,bs,t),js.unhighlight(e.tree,t,t),js.highlight(e.array,ys,t,fs.ORANGE),js.highlight(e.array,bs,n,fs.ORANGE),js.highlight(e.tree,t,t,fs.ORANGE),js.highlight(e.tree,n,n,fs.ORANGE)}),[n,t[n],t[t[n]]]),e.add("parent[n] <- parent[parent[n]]",((e,t,n,a)=>{js.unhighlight(e.array,bs,n),js.unhighlight(e.tree,n,n),js.highlight(e.array,ys,n,fs.ORANGE),js.highlight(e.tree,a,a,fs.ORANGE),e.tree.layout()}),[n,t[n],t[t[n]]]),t[n]!==n&&t[t[n]]!==t[n]){let a=t[n];t[n]=t[t[n]],e.add("parent[n] <- parent[parent[n]]",((e,t,n)=>{e.array.updateValueAt(ys,t,n),e.tree.removeEdge(a,t),e.tree.addEdge(n,t),e.tree.layout()}),[n,t[t[n]]]),e.add("parent[n] <- parent[parent[n]]",((e,t,n,a)=>{js.unhighlight(e.array,ys,n),js.unhighlight(e.tree,a,a),js.highlight(e.array,bs,t,fs.RED),js.highlight(e.array,ys,t,fs.RED),js.highlight(e.tree,t,t,fs.RED)}),[n,a,t[n]])}return t[n]}};const fs={RED:3,ORANGE:2,GREEN:1},bs=0,ys=1,As=["i",1,2,3,4,5,6,7,8,9,10],xs=["0",1,2,3,4,5,6,7,8,9,10];let vs=!1;var js={explanation:B,initVisualisers:()=>({array:{instance:new dr("array",null,"Array View"),order:0},tree:{instance:new gs("n-tree",null,"Tree View"),order:1}}),run(e,t){const{arg1:n,arg2:a}=t.target;let r=["Parent[i]",...As.slice(1)],i=["Rank[i]",...Array(10).fill(0)];e.add("Union(n, m)",((e,t)=>{e.array.set(t,"unionFind",""),e.array.hideArrayAtIndex(vs?null:2),e.tree.addNode(xs[0],void 0,"circle");for(const n of xs.slice(1))e.tree.addNode(n,void 0,"circle"),e.tree.addEdge(xs[0],n);e.tree.isReversed=!0,e.tree.layout();for(const n of xs.slice(1))e.tree.addSelfLoop(n)}),[[As,r,i]]);for(let s=0;s<n.length;s++)this.union(e,r,i,n[s][0],n[s][1],a);return r.slice(1)},highlight(e,t,n,a){"array"===e.key&&(e.unfill(t,n),e.fill(t,n,void 0,void 0,a)),"n-tree"===e.key&&(this.unhighlight(e,t,n),e.fill(t,a))},unhighlight(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if("array"===e.key)return!0===a?void e.unfill(t,0,void 0,As.length-1):void e.unfill(t,n);"n-tree"===e.key&&e.unfill(t)},union(e,t,n,a,r,i){e.add("Union(n, m)",((e,t,n)=>{e.array.setMotion(!1),e.array.assignVariable("n",bs,t),e.array.assignVariable("m",bs,n),e.array.showKth("".concat(t,", ").concat(n))}),[a,r]);let s=ms.find(e,t,a,"n",null,i),o=ms.find(e,t,r,"m",s,i);if(e.add("if n == m",((e,t,n,a,r)=>{e.array.showKth("".concat(t,", ").concat(n)),this.highlight(e.array,bs,a,fs.ORANGE),this.highlight(e.array,bs,r,fs.ORANGE),this.highlight(e.tree,a,a,fs.ORANGE),this.highlight(e.tree,r,r,fs.ORANGE)}),[a,r,s,o]),s!==o){if(e.add("if rank[n] > rank[m]",((e,t,n)=>{this.unhighlight(e.array,bs,t),this.unhighlight(e.array,bs,n),this.highlight(e.array,2,t,fs.ORANGE),this.highlight(e.array,2,n,fs.ORANGE)}),[s,o]),n[s]>n[o]){const t=s;s=o,o=t,e.add("swap(n, m)",((e,t,n)=>{e.array.assignVariable("n",bs,t),e.array.assignVariable("m",bs,n),this.highlight(e.array,2,t,fs.GREEN),this.highlight(e.array,2,n,fs.GREEN)}),[s,o])}e.add("parent[n] = m",((e,t,n)=>{this.unhighlight(e.array,bs,t),this.unhighlight(e.array,2,t),this.unhighlight(e.array,2,n),this.highlight(e.array,bs,n,fs.ORANGE),this.highlight(e.array,ys,t,fs.ORANGE)}),[s,o]),t[s]=o,e.add("parent[n] = m",((e,t,n)=>{e.array.updateValueAt(ys,t,n),this.highlight(e.array,bs,n,fs.GREEN),this.highlight(e.array,ys,t,fs.GREEN),this.highlight(e.tree,t,t,fs.GREEN),this.highlight(e.tree,n,n,fs.GREEN),e.tree.removeEdge("0",t),e.tree.removeEdge(t,t),e.tree.addEdge(n,t),e.tree.layout()}),[s,o]),e.add("if rank[n] == rank[m]",((e,t,n)=>{this.unhighlight(e.array,ys,t),this.unhighlight(e.array,bs,n),this.highlight(e.array,2,t,fs.ORANGE),this.highlight(e.array,2,n,fs.ORANGE),this.unhighlight(e.tree,t,t),this.unhighlight(e.tree,n,n)}),[s,o]),n[s]==n[o]?(n[o]+=1,n[s]=null,e.add("rank[m] <- rank[m] + 1",((e,t,n,a,r)=>{e.array.updateValueAt(2,t,a),e.array.updateValueAt(2,n,r),this.unhighlight(e.array,2,t),this.highlight(e.array,2,n,fs.GREEN)}),[s,o,n[s],n[o]]),e.add("rank[m] <- rank[m] + 1",((e,t)=>{this.unhighlight(e.array,2,t)}),[o])):(n[s]=null,e.add("if rank[n] == rank[m]",((e,t,n,a)=>{e.array.updateValueAt(2,t,a),this.unhighlight(e.array,2,t),this.unhighlight(e.array,2,n)}),[s,o,n[s]]))}else e.add("return",((e,t)=>{this.highlight(e.array,bs,t,fs.GREEN),this.highlight(e.tree,t,t,fs.GREEN)}),[s])}},ws={explanation:T,initVisualisers(e){let{visualiser:t}=e;return t.tree.instance.unfillAll(),t.tree.instance.setFunctionName(null),{tree:{instance:t.tree.instance,order:0}}},findChild(e,t,n){if(null===t)return null;const a=t.getNodeLength(),r=t.getIDs(),i=t.children;return e.add("if t is a two-node"),1===a?(e.add("if k < t.key1: if t is a two-node"),n<r[0]?this.childOrNull(e,"c <- t.child1: if t is a two-node",r[0],i,0):(e.add("else: if t is a two-node"),this.childOrNull(e,"c <- t.child2: if t is a two-node",r[0],i,1))):(e.add("else if t is a three-node"),2===a?(e.add("if k < t.key1: else if t is a three-node",((e,t,n)=>{Es.unhighlightNode(e.tree,t),Es.highlightValue(e.tree,n,fs.ORANGE)}),[t,r[0]]),n<r[0]?this.childOrNull(e,"c <- t.child1: else if t is a three-node",r[0],i,0):(e.add("else if k < t.key2: else if t is a three-node",((e,t,n)=>{Es.unhighlightValue(e.tree,t),Es.highlightValue(e.tree,n,fs.ORANGE)}),[r[0],r[1]]),n<r[1]?this.childOrNull(e,"c <- t.child2: else if t is a three-node",r[1],i,1):(e.add("else: else if t is a three-node"),this.childOrNull(e,"c <- t.child3: else if t is a three-node",r[1],i,2)))):(e.add("else: Find_child"),3===a?(e.add("if k < t.key1: else: Find_child",((e,t,n)=>{Es.unhighlightNode(e.tree,t),Es.highlightValue(e.tree,n,fs.ORANGE)}),[t,r[0]]),n<r[0]?this.childOrNull(e,"c <- t.child1: else: Find_child",r[0],i,0):(e.add("else if k < t.key2: else: Find_child",((e,t,n)=>{Es.unhighlightValue(e.tree,t),Es.highlightValue(e.tree,n,fs.ORANGE)}),[r[0],r[1]]),n<r[1]?this.childOrNull(e,"c <- t.child2: else: Find_child",r[1],i,1):(e.add("else if k < t.key3",((e,t,n)=>{Es.unhighlightValue(e.tree,t),Es.highlightValue(e.tree,n,fs.ORANGE)}),[r[1],r[2]]),n<r[2]?this.childOrNull(e,"c <- t.child3: else: Find_child",r[2],i,2):(e.add("else: else: Find_child"),this.childOrNull(e,"c <- t.child4",r[2],i,3))))):void 0))},childOrNull:(e,t,n,a,r)=>0===a.length?(e.add(t),null):(e.add(t,((e,t,n)=>{Es.unhighlightValue(e.tree,t),Es.highlightNode(e.tree,n,fs.ORANGE)}),[n,a[r]]),a[r]),returnIfKeyInNode:(e,t,n)=>(e.add("if t is a two-node: Return_if_key_in_node",((e,t)=>{Es.highlightNode(e.tree,t,fs.ORANGE)}),[n]),1===n.getNodeLength()?t===n.getIDs()[0]?(e.add("if t.key1 == k return t",((e,t)=>{Es.highlightNode(e.tree,t,fs.GREEN)}),[n]),n):(e.add("if t.key1 == k return t"),null):(e.add("if t is a three-node: Return_if_key_in_node"),2===n.getNodeLength()?t===n.getIDs()[0]||t===n.getIDs()[1]?(e.add("if t.key1 == k or t.key2 == k return t",((e,t)=>{Es.highlightNode(e.tree,t,fs.GREEN)}),[n]),n):(e.add("if t.key1 == k or t.key2 == k return t"),null):(e.add("else: Return_if_key_in_node"),3===n.getNodeLength()?t===n.getIDs()[0]||t===n.getIDs()[1]||t===n.getIDs()[2]?(e.add("if t.key1 == k or t.key2 == k or t.key3 == k return t",((e,t)=>{Es.highlightNode(e.tree,t,fs.GREEN)}),[n]),n):(e.add("if t.key1 == k or t.key2 == k or t.key3 == k return t"),null):null))),search(e,t,n){let a,r=t;for(e.add("while t not Empty");null!==r&&!this.returnIfKeyInNode(e,n,r);)a=r,r=this.findChild(e,r,n);null===r&&e.add("return NotFound",((e,t)=>{Es.highlightNode(e.tree,t,fs.RED)}),[a])},initTreeReturnRoot(e,t){let n={},a=e.filter((e=>0!==e.id));a.forEach((e=>{n[e.id]=new ps(e.id)})),a.forEach((e=>{const t=n[e.id];e.nodeIDs.forEach((e=>{t.addRelatedNodeID(e)}))})),t.forEach((e=>{const t=n[e.source],a=n[e.target];t&&a&&(t.children.push(a),a.parent=t)}));let r=Object.values(n).filter((e=>null===e.parent))[0];return Object.values(n).forEach((e=>{e.parent=null})),r},run(e,t){let{visualiser:n,target:a}=t,{realNodes:r,realEdges:i,nodes:s,edges:o}=n.tree.instance.extractNTree();e.add("T234_Search(t, k)",(e=>{e.tree.setNTree(r,i,s,o),e.tree.layout()}));let l=this.initTreeReturnRoot(r,i);this.search(e,l,a)}},Es={explanation:T,initVisualisers:()=>({tree:{instance:new gs("n-tree",null,"Tree View"),order:0}}),highlightValue(e,t,n){this.unhighlightValue(e,t),e.fill(t,n)},unhighlightValue(e,t){e.unfill(t)},highlightNode(e,t,n){this.unhighlightNode(e,t);for(let a=0;a<t.relatedNodeIDs.length;a++){let r=t.relatedNodeIDs[a];e.fill(r,n)}},unhighlightNode(e,t){for(let n=0;n<t.relatedNodeIDs.length;n++){let a=t.relatedNodeIDs[n];e.unfill(a)}},traverseAndInsert(e,t,n,a){e.add("if t = Empty"),e.add("else: T234_Insert(t, k)"),e.add("p <- Empty");let r=null,i=n;for(e.add("c <- t",((e,t)=>{this.highlightNode(e.tree,t,fs.ORANGE)}),[i]);null!=i;){e.add("repeat");let s=i;if(e.add("if c is a four-node"),3===i.getNodeLength()){let o,l;if(({node:o,id:a}=this.createNodeAndIncrement(a)),({node:l,id:a}=this.createNodeAndIncrement(a)),4===i.children.length&&(o.children.push(i.children[0]),o.children.push(i.children[1]),l.children.push(i.children[2]),l.children.push(i.children[3])),e.add("c1 <- new two-node with c.child1, c.key1 and c.child2"),e.add("c2 <- new two-node with c.child3, c.key3 and c.child4"),o.addRelatedNodeID(i.getIDs()[0]),l.addRelatedNodeID(i.getIDs()[2]),e.add("if p = Empty"),null===r)({node:n,id:a}=this.createNodeAndIncrement(a)),n.children.push(o),n.children.push(l),n.addRelatedNodeID(i.getIDs()[1]),e.add("t <- new two-node with c1, c.key2 and c2",this.handleChunkerAdd,[n.id,n.getIDs()[0],i.id,[o.id,o.getIDs()[0],o.children],[l.id,l.getIDs()[0],l.children],!0]),i=n;else if(1===r.getNodeLength()){e.add("else if p is a two-node");let t=r.children,n=this.formParentThreeNode(r,i,o,l);e.add("Change p to a three-node, with c1, c.key2 and c2 replacing c",this.handleChunkerAdd,[r.id,i.getIDs()[1],i.id,[o.id,o.getIDs()[0],o.children],[l.id,l.getIDs()[0],l.children],!1,n,t])}else{e.add("else: InsertParent");let t=r.children,n=this.formParentFourNode(r,i,o,l);e.add("Change p to a four-node, with c1, c.key2 and c2 replacing c",this.handleChunkerAdd,[r.id,i.getIDs()[1],i.id,[o.id,o.getIDs()[0],o.children],[l.id,l.getIDs()[0],l.children],!1,n,t])}e.add("if k < c.key2: Split",((e,t,n)=>{this.unhighlightNode(e.tree,t),this.unhighlightNode(e.tree,n)}),[o,l]),t<s.getIDs()[1]?(e.add("c <- c1",((e,t,n)=>{this.unhighlightValue(e.tree,t),this.highlightNode(e.tree,n,fs.ORANGE)}),[s.getIDs()[1],o]),i=o):(e.add("else: Split"),e.add("c <- c2",((e,t,n)=>{this.unhighlightValue(e.tree,t),this.highlightNode(e.tree,n,fs.ORANGE)}),[s.getIDs()[1],l]),i=l)}e.add("p <- c"),r=i,i=ws.findChild(e,i,t),null===i&&e.add("until c is Empty (and p is a leaf node)")}return r.addRelatedNodeID(t),e.add("if p is a two-node"),2===r.getNodeLength()?e.add("Change p to a three-node, containing the old p.key1 and k",((e,t,n)=>{e.tree.addVariableNode(t.id,n),this.unhighlightNode(e.tree,t),this.highlightValue(e.tree,n,fs.GREEN),e.tree.layout()}),[r,t]):(e.add("else: Insert"),e.add("Change p to a four-node, containing the old p.key1 and p.key2 and k",((e,t,n)=>{e.tree.addVariableNode(t.id,n),this.unhighlightNode(e.tree,t),this.highlightValue(e.tree,n,fs.GREEN),e.tree.layout()}),[r,t])),{nTree:n,id:a}},formParentThreeNode(e,t,n,a){let r=e.getIDs();e.clearRelatedNodeIDs();let i=e.children.indexOf(t);return e.children.splice(i,1,n,a),e.addRelatedNodeID(t.getIDs()[1]),e.addRelatedNodeID(r[0]),i},formParentFourNode(e,t,n,a){let r=e.getIDs();e.clearRelatedNodeIDs();let i=e.children.indexOf(t);return e.children.splice(i,1,n,a),e.addRelatedNodeID(t.getIDs()[1]),e.addRelatedNodeID(r[0]),e.addRelatedNodeID(r[1]),i},createNodeAndIncrement(e){null===e&&(e=1);return{node:new ps(e),id:++e}},handleChunkerAdd(e,t,n,a,r,i){let s=arguments.length>6&&void 0!==arguments[6]&&arguments[6],o=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null,l=arguments.length>8&&void 0!==arguments[8]?arguments[8]:null;if(s&&(e.tree.addVariableNode(t,n),e.tree.addEdge(0,t)),e.tree.removeFullNode(a),e.tree.addVariableNode(r[0],r[1]),e.tree.addVariableNode(i[0],i[1]),e.tree.addVariableNode(t,n),!s)for(let d=0;d<l.length;d++)d!=o&&e.tree.removeEdge(t,l[d].id);if(s)e.tree.addEdge(t,r[0]),e.tree.addEdge(t,i[0]);else for(let d=0;d<l.length;d++)d!=o?e.tree.addEdge(t,l[d].id):(e.tree.addEdge(t,r[0]),e.tree.addEdge(t,i[0]));for(let d=0;d<i[2].length;d++)e.tree.addEdge(i[0],i[2][d].id);for(let d=0;d<r[2].length;d++)e.tree.addEdge(r[0],r[2][d].id);e.tree.layout()},insert(e,t,n,a){return e.add("T234_Insert(t, k)",(e=>{e.tree.unfillAll(),e.tree.setText("(t, ".concat(t,")"))})),this.traverseAndInsert(e,t,n,a)},initTree(e,t,n){return e.add("T234_Insert(t, k)",(e=>{e.tree.setFunctionName("Tree is Empty"),e.tree.setText("")})),e.add("if t = Empty",(e=>{e.tree.setFunctionName("T234_Insert"),e.tree.setText("(t, ".concat(t,")"))})),n.addRelatedNodeID(t),e.add("t <- a new two-node containing k and empty subtrees",((e,t,n,a)=>{e.tree.variableNodes=!0,e.tree.isDirected=!1,e.tree.addVariableNode(0,"0"),e.tree.addVariableNode(n,a),e.tree.addEdge(0,n),this.highlightNode(e.tree,t,fs.GREEN),e.tree.layout()}),[n,n.id,n.getIDs()[0]]),n},run(e,t){let{nodes:n}=t;if(null===n||0===n.length)return;let{node:a,id:r}=this.createNodeAndIncrement(null),i=this.initTree(e,n[0],a);if(1!==n.length){i=this.insert(e,n[1],a,r);for(let t=2;t<n.length;t++)i=this.insert(e,n[t],i.nTree,i.id)}}};const ks="0",Ns=4,Os=4,Is=2,Cs="1",Ss=1,Ms=1,Bs="1",Ts="1",Rs=3;var Ls={initVisualisers:()=>({graph:{instance:new er("graph",null,"Graph view"),order:0},array:{instance:new dr("array",null,"Parent array & Priority Queue"),order:1}}),run(e,t){let{edgeValueMatrix:n,coordsMatrix:a,startNode:r,endNodes:i,moveNode:s}=t;const o="dijkstra",l="-",d=[...n],c=[...a],h=n.length,u=[],p=[],g=[],m=[],f=r-1,b=i[0]-1,y=new Set;let A=f,x=[null,null];const v=Array(h).fill(1/0),j=()=>{let e=1/0;A=null;for(let t=h-1;t>=0;t--)!y.has(t)&&v[t]<=e&&(e=v[t],A=t)},w=(e,t,n,a,r)=>{e.array.set(t,o);let i=null===r?null:r+1,s=null===a?null:a+1,l=null===n?null:n+1;e.array.assignVariable("n",2,s),e.array.assignVariable("m",2,i),e.array.assignVariable("Min",2,l);for(let o=0;o<h;o++)null===t[2][o+1]?(e.array.select(0,o+1,0,o+1,Cs),e.graph.removeNodeColor(o),e.graph.colorNode(o,Ss)):"number"===typeof(d=t[2][o+1])&&isFinite(d)&&(e.array.select(0,o+1,0,o+1,ks),e.graph.removeNodeColor(o),e.graph.colorNode(o,Ns));var d;null!=n&&e.array.select(2,n+1,2,n+1,Bs)};e.add(1,((e,t,n)=>{e.graph.directed(!1),e.graph.weighted(!0),e.graph.moveNodeFn(s),e.graph.set(t,Array.from({length:h},((e,t)=>t+1)),n)}),[d,c]);const E=Array(h).fill(null);g.push("i"),p.push("Parent[i]"),u.push("Cost[i]"),m.push("Final Cost");for(let N=0;N<h;N+=1)g[N+1]=N+1,u.push(l),p.push(0),m.push(l);e.add(5,((e,t)=>{e.array.set(t,o)}),[[g,p,u,m],0]);for(let N=0;N<h;N+=1)u[N+1]=1/0;e.add(6,((e,t)=>{e.array.set(t,o)}),[[g,p,u,m],0]),v[f]=0,u[f+1]=0,e.add(7,((e,t,n)=>{e.array.set(t,o),e.array.select(0,n+1,0,n+1,ks),e.graph.colorNode(n,Ns)}),[[g,p,u,m],f]),e.add(8,((e,t,n)=>{e.array.set(t,o),e.array.assignVariable("Min",2,n+1),e.array.select(2,n+1,2,n+1,Bs),e.array.select(0,n+1,0,n+1,ks)}),[[g,p,u,m],f]);let k=null;for(;;){if(j(),e.add(2,((e,t,n,a,r,i)=>{w(e,t,n,i,null),null!=a[0]&&(e.graph.removeEdgeColor(a[0],a[1]),null!=r[a[0]]&&t[3][a[0]+1]==l&&(e.graph.removeEdgeColor(r[a[0]],a[0]),e.graph.colorEdge(r[a[0]],a[0],Os)),null!=r[a[1]]&&t[3][a[1]+1]==l&&(e.graph.removeEdgeColor(r[a[1]],a[1]),e.graph.colorEdge(r[a[1]],a[1],Os)),t[3][a[0]+1]!=l&&(e.graph.removeEdgeColor(r[a[0]],a[0]),e.graph.colorEdge(r[a[0]],a[0],Ms)),t[3][a[1]+1]!=l&&(e.graph.removeEdgeColor(r[a[1]],a[1]),e.graph.colorEdge(r[a[1]],a[1],Ms)))}),[[g,p,u,m],A,x,E,k]),!(y.size<h)){e.add(99),e.add(99,((e,t,n,a,r)=>{}),[[g,p,u,m],A,null,null]);break}if(k=null,j(),k=A,m[A+1]=v[A],u[k+1]=null,y.add(k),j(),e.add(9,((e,t,n,a,r)=>{null!=r&&(e.graph.removeEdgeColor(r,a),e.graph.colorEdge(r,a,Ms)),w(e,t,n,a,null)}),[[g,p,u,m],A,k,E[k]]),e.add(10),null===k||v[k]===1/0){u[k+1]="\u221e",m[k+1]=l,A=k,e.add(3,((e,t,n,a,r)=>{e.graph.removeNodeColor(k),w(e,t,n,a,r)}),[[g,p,u,m],A,null,null]);break}if(k===b){e.add(3,((e,t)=>{e.array.set(t,o),e.array.assignVariable("end",2,b+1),e.array.assignVariable("start",2,f+1),e.array.assignVariable("n",2,null);let n=b,a=0;for(;n!=f&&null!=t[1][n+1];)a=t[1][n+1]-1,e.array.select(0,n+1,0,n+1,Ts),e.array.select(1,n+1,1,n+1,Ts),e.graph.removeEdgeColor(n,a),e.graph.colorEdge(n,a,Rs),n=a;e.array.select(0,f+1,0,f+1,Ts),e.array.select(3,b+1,3,b+1,Ts)}),[[g,p,u,m]]);break}for(let t=0;t<h;t++)if(0!==n[k][t]){e.add(4,((e,t,n,a,r,i,s)=>{null!=a[0]&&(e.graph.removeEdgeColor(a[0],a[1]),null!=r[a[0]]&&t[3][a[0]+1]==l&&(e.graph.removeEdgeColor(r[a[0]],a[0]),e.graph.colorEdge(r[a[0]],a[0],Os)),null!=r[a[1]]&&t[3][a[1]+1]==l&&(e.graph.removeEdgeColor(r[a[1]],a[1]),e.graph.colorEdge(r[a[1]],a[1],Os)),t[3][a[0]+1]!=l&&(e.graph.removeEdgeColor(r[a[0]],a[0]),e.graph.colorEdge(r[a[0]],a[0],Ms)),t[3][a[1]+1]!=l&&(e.graph.removeEdgeColor(r[a[1]],a[1]),e.graph.colorEdge(r[a[1]],a[1],Ms))),e.graph.removeEdgeColor(i,s),e.graph.colorEdge(i,s,Is),w(e,t,n,i,s)}),[[g,p,u,m],A,x,E,k,t]);const a=v[k]+n[k][t];let r=u[t+1];if(u[t+1]===1/0&&(r="\u221e"),y.has(t)||(a<v[t]?u[t+1]="".concat(a," ").concat("<"," ").concat(r):u[t+1]="".concat(a," ").concat("\u226e"," ").concat(r)),e.add(11,((e,t,n,a,r)=>{w(e,t,n,a,r)}),[[g,p,u,m],A,k,t]),y.has(t)||(u[t+1]=v[t]),x=[k,t],!y.has(t)&&a<v[t]){v[t]=a,u[t+1]=a,e.add(12,((e,t,n,a,r)=>{w(e,t,n,a,r)}),[[g,p,u,m],A,k,t]),j(),e.add(13,((e,t,n,a,r)=>{w(e,t,n,a,r)}),[[g,p,u,m],A,k,t]),p[t+1]=k+1;const n=E[t];E[t]=k,e.add(14,((e,t,n,a,r,i,s)=>{e.graph.removeEdgeColor(s,r),e.graph.removeNodeColor(a),e.graph.colorEdge(a,r,Os),e.graph.colorNode(a,1),null!=i&&e.graph.removeEdgeColor(i,r),w(e,t,n,s,r)}),[[g,p,u,m],A,E[t],t,n,k])}}}}},Ds={initVisualisers:()=>({graph:{instance:new er("graph",null,"Graph view"),order:0},array:{instance:new dr("array",null,"Parent array & Priority Queue"),order:1}}),run(e,t){let{edgeValueMatrix:n,coordsMatrix:a,startNode:r,endNodes:i,heuristicFn:s,moveNode:o}=t;const l="aStar",d="-",c=[...n],h=[...a],u=n.length,p=[],g=[],m=[],f=[],b=[],y=[],A=r-1,x=i[0]-1,v=new Set;let j=A,w=[null,null];const E=Array(u).fill(1/0),k=()=>{let e=1/0;j=null;for(let t=u-1;t>=0;t--)!v.has(t)&&E[t]+y[t]<=e&&(e=E[t]+y[t],j=t)},N=(e,t,n,a,r)=>{e.array.set(t,l);let i=null===r?null:r+1,s=null===a?null:a+1,o=null===n?null:n+1;e.array.assignVariable("n",2,s),e.array.assignVariable("m",2,i),e.array.assignVariable("Min",2,o);for(let l=0;l<u;l++)null===t[2][l+1]?(e.array.select(0,l+1,0,l+1,Cs),e.graph.removeNodeColor(l),e.graph.colorNode(l,Ss)):"number"===typeof(d=t[2][l+1])&&isFinite(d)&&(e.array.select(0,l+1,0,l+1,ks),e.graph.removeNodeColor(l),e.graph.colorNode(l,Ns));var d;null!=n&&(e.array.select(2,n+1,2,n+1,Bs),e.array.select(1,n+1,1,n+1,Bs))},O=h[x][0],I=h[x][1];for(let M=0;M<u;M++)y[M]=s(h[M][0],h[M][1],O,I);e.add(1,((e,t,n)=>{e.graph.directed(!1),e.graph.weighted(!0),e.graph.moveNodeFn(o),e.graph.set(t,Array.from({length:u},((e,t)=>t+1)),n)}),[c,h]);const C=Array(u).fill(null);m.push("i"),g.push("Parent[i]"),p.push("Length[i]"),b.push("heur(i)"),f.push("Final Length");for(let M=0;M<u;M+=1)m[M+1]=M+1,b.push(y[M]),p.push(d),g.push(0),f.push(d);e.add(5,((e,t)=>{e.array.set(t,l),e.array.getRendererClass().zoom=8}),[[m,b,p,g,f],0]);for(let M=0;M<u;M+=1)p[M+1]=1/0;e.add(6,((e,t)=>{e.array.set(t,l)}),[[m,b,p,g,f],0]),E[A]=0,p[A+1]=0,e.add(7,((e,t,n)=>{e.array.set(t,l),e.array.select(0,n+1,0,n+1,ks),e.graph.colorNode(n,Ns)}),[[m,b,p,g,f],A]),e.add(8,((e,t,n)=>{e.array.set(t,l),e.array.assignVariable("Min",2,n+1),e.array.select(2,n+1,2,n+1,Bs),e.array.select(1,n+1,1,n+1,Bs),e.array.select(0,n+1,0,n+1,ks)}),[[m,b,p,g,f],A]);let S=null;for(;;){if(k(),e.add(2,((e,t,n,a,r,i)=>{N(e,t,n,i,null),null!=a[0]&&(e.graph.removeEdgeColor(a[0],a[1]),null!=r[a[0]]&&t[4][a[0]+1]==d&&(e.graph.removeEdgeColor(r[a[0]],a[0]),e.graph.colorEdge(r[a[0]],a[0],Os)),null!=r[a[1]]&&t[4][a[1]+1]==d&&(e.graph.removeEdgeColor(r[a[1]],a[1]),e.graph.colorEdge(r[a[1]],a[1],Os)),t[4][a[0]+1]!=d&&(e.graph.removeEdgeColor(r[a[0]],a[0]),e.graph.colorEdge(r[a[0]],a[0],Ms)),t[4][a[1]+1]!=d&&(e.graph.removeEdgeColor(r[a[1]],a[1]),e.graph.colorEdge(r[a[1]],a[1],Ms)))}),[[m,b,p,g,f],j,w,C,S]),!(v.size<u)){e.add(99);break}if(S=null,k(),S=j,f[j+1]=E[j],p[S+1]=null,b[S+1]=null,v.add(S),k(),e.add(9,((e,t,n,a,r)=>{null!=r&&(e.graph.removeEdgeColor(r,a),e.graph.colorEdge(r,a,Ms)),N(e,t,n,a,null)}),[[m,b,p,g,f],j,S,C[S]]),e.add(10),null===S||E[S]===1/0){p[S+1]="\u221e",f[S+1]=d,j=S,e.add(3,((e,t,n,a,r)=>{e.graph.removeNodeColor(S),N(e,t,n,a,r)}),[[m,g,p,f],j,S,null]);break}if(S===x){e.add(3,((e,t)=>{e.array.set(t,l),e.array.assignVariable("n",2,null),e.array.assignVariable("end",2,x+1),e.array.assignVariable("start",2,A+1);let n=x,a=0;for(;n!=A&&null!=t[3][n+1];)a=t[3][n+1]-1,e.array.select(0,n+1,0,n+1,Ts),e.array.select(3,n+1,3,n+1,Ts),e.graph.removeEdgeColor(n,a),e.graph.colorEdge(n,a,Rs),n=a;e.array.select(0,A+1,0,A+1,Ts),e.array.select(4,x+1,4,x+1,Ts)}),[[m,b,p,g,f]]);break}for(let t=0;t<u;t++)if(0!==n[S][t]){e.add(4,((e,t,n,a,r,i,s)=>{null!=a[0]&&(e.graph.removeEdgeColor(a[0],a[1]),null!=r[a[0]]&&t[4][a[0]+1]==d&&(e.graph.removeEdgeColor(r[a[0]],a[0]),e.graph.colorEdge(r[a[0]],a[0],Os)),null!=r[a[1]]&&t[4][a[1]+1]==d&&(e.graph.removeEdgeColor(r[a[1]],a[1]),e.graph.colorEdge(r[a[1]],a[1],Os)),t[4][a[0]+1]!=d&&(e.graph.removeEdgeColor(r[a[0]],a[0]),e.graph.colorEdge(r[a[0]],a[0],Ms)),t[4][a[1]+1]!=d&&(e.graph.removeEdgeColor(r[a[1]],a[1]),e.graph.colorEdge(r[a[1]],a[1],Ms))),e.graph.removeEdgeColor(i,s),e.graph.colorEdge(i,s,Is),N(e,t,n,i,s)}),[[m,b,p,g,f],j,w,C,S,t]);const a=E[S]+n[S][t];let r=p[t+1];if(p[t+1]===1/0&&(r="\u221e"),v.has(t)||(a<E[t]?p[t+1]="".concat(a," ").concat("<"," ").concat(r):p[t+1]="".concat(a," ").concat("\u226e"," ").concat(r)),e.add(11,((e,t,n,a,r)=>{N(e,t,n,a,r)}),[[m,b,p,g,f],j,S,t]),v.has(t)||(p[t+1]=E[t]),w=[S,t],!v.has(t)&&a<E[t]){E[t]=a,p[t+1]=a,e.add(12,((e,t,n,a,r)=>{N(e,t,n,a,r)}),[[m,b,p,g,f],j,S,t]),k(),e.add(13,((e,t,n,a,r)=>{N(e,t,n,a,r)}),[[m,b,p,g,f],j,S,t]),g[t+1]=S+1;const n=C[t];C[t]=S,e.add(14,((e,t,n,a,r,i,s)=>{e.graph.removeEdgeColor(s,r),e.graph.removeNodeColor(a),e.graph.colorEdge(a,r,Os),e.graph.colorNode(a,1),null!=i&&e.graph.removeEdgeColor(i,r),N(e,t,n,s,r)}),[[m,b,p,g,f],j,C[t],t,n,S])}}}}},Ps={initVisualisers:()=>({graph:{instance:new er("graph",null,"Graph view"),order:0},array:{instance:new dr("array",null,"Parent array, Seen array & Queue"),order:1}}),run(e,t){let{edgeValueMatrix:n,coordsMatrix:a,endNodes:r,startNode:i,moveNode:s}=t;function o(){this.items=[]}o.prototype.enqueue=function(e){this.items.push(e)},o.prototype.dequeue=function(){return this.isEmpty()?null:this.items.shift()},o.prototype.isEmpty=function(){return 0==this.items.length};const l=[...n],d=[...a],c=n.length,h=new Array(c).fill(!1),u=new Array(c).fill(null),p=new Array(c).fill(!1),g=[],m=[],f=[],b=[];let y=[];const A=i-1,x=r[0]-1;let v=null,j=null;e.add(1,((e,t,a)=>{e.graph.directed(!1),e.graph.weighted(!1),e.graph.moveNodeFn(s),e.graph.set(t,Array.from({length:n.length},((e,t)=>t+1)),a)}),[l,d]),m.push("Parent[i]"),g.push("Seen[i]"),f.push("i");for(let w=0;w<c;w+=1)u[w]=null,m.push(0),g.push(" "),f.push(w+1);e.add(6,((e,t)=>{e.array.set(t,"BFS")}),[[f,m,g]]);for(let w=0;w<c;w+=1)g[w+1]="false";e.add(7,((e,t)=>{e.array.set(t,"BFS")}),[[f,m,g]]);(t=>{const n=[t];for(h[t]=!0,g[t+1]="true",p[t]=!1,b.push(t),e.add(8,((e,n,a)=>{e.array.set(n,"BFS"),e.array.setList(a),e.array.select(0,t+1,0,t+1,ks),e.graph.colorNode(t,Ns)}),[[f,m,g],y]),p[t]=!0,y=[],y.push(t+1),e.add(9,((e,t,n,a,r)=>{e.array.setList(n)}),[[f,m,g],y,p,n]);e.add(2,((e,t,n,a,r,i)=>{e.array.assignVariable("m",2,void 0);for(let s=0;s<r.length;s++)1==r[s]&&(i.includes(s)?e.array.select(0,s+1,0,s+1,ks):e.array.select(0,s+1,0,s+1,Cs));null!=t&&null!=n&&(e.graph.removeEdgeColor(t,n),null!=t&&null!=n&&(e.graph.removeEdgeColor(t,n),a[n]===t?e.graph.colorEdge(t,n,Os):a[t]===n&&e.graph.colorEdge(t,n,Ms)))}),[j,v,u,h,n]),n.length>0;){if(j=n.shift(),y.shift(),e.add(10,((e,t,n,a,r,i,s,o)=>{e.array.set(t,"BFS"),e.array.assignVariable("n",2,n+1);for(let l=0;l<r.length;l++)1==r[l]&&o.includes(l)&&e.array.select(0,l+1,0,l+1,ks);for(let l=0;l<i.length;l++)1!=i[l]||o.includes(l)||(e.array.select(0,l+1,0,l+1,Cs),e.graph.removeNodeColor(l),e.graph.colorNode(l,Ss));null!==s[n]&&(e.graph.removeEdgeColor(n,s[n]),e.graph.colorEdge(n,s[n],Ms)),e.array.setList(a)}),[[f,m,g],j,y,p,h,u,n]),e.add(11),j==x)return void e.add(3,((e,n,a,r,i,s)=>{if(null!=a){e.graph.removeEdgeColor(a,n),null!=r[a]&&(e.graph.removeEdgeColor(r[a],a),e.graph.colorEdge(r[a],a,Os));for(let t=0;t<r.length;t++)r[t]==a&&(e.graph.removeEdgeColor(t,a),e.graph.colorEdge(t,a,Os))}e.array.assignVariable("n",2,void 0),e.array.assignVariable("end",2,s+1),e.array.assignVariable("start",2,t+1);for(let t=0;t<r.length;t++)e.array.deselect(0,t);let o=s;for(;o!=i&&null!=r[o];)e.array.select(0,o+1,0,o+1,Ts),e.array.select(1,o+1,1,o+1,Ts),e.graph.removeEdgeColor(o,r[o]),e.graph.colorEdge(o,r[o],Rs),o=r[o];e.array.select(0,A+1,0,A+1,Ts)}),[j,v,u,A,x]);v=null;for(let t=0;t<c;t++)if(0!=l[j][t]&&(e.add(4,((e,t,n,a,r,i,s)=>{null!=t&&null!=a&&(e.graph.removeEdgeColor(t,a),r[t]===a?e.graph.colorEdge(t,a,Ms):r[a]===t&&e.graph.colorEdge(t,a,Os)),e.graph.removeEdgeColor(t,n),e.graph.colorEdge(t,n,Is),e.array.assignVariable("m",2,n+1);for(let o=0;o<i.length;o++)1==i[o]&&(s.includes(o)?e.array.select(0,o+1,0,o+1,ks):e.array.select(0,o+1,0,o+1,Cs))}),[j,t,v,u,h,n]),v=t,e.add(12),!h[t])){h[t]=!0,g[t+1]="true",p[t]=!1,b.push(t),e.add(13,((e,t,n,a,r,i,s,o)=>{e.array.set(t,"BFS"),e.array.assignVariable("n",2,i+1),e.array.assignVariable("m",2,s+1);for(let l=0;l<r.length;l++)1==r[l]&&(o.includes(l)||l===s?e.array.select(0,l+1,0,l+1,ks):e.array.select(0,l+1,0,l+1,Cs));e.array.setList(n),e.graph.removeNodeColor(s),e.graph.colorNode(s,Ns)}),[[f,m,g],y,p,h,j,t,n]);let a=u[t];u[t]=j,m[t+1]=j+1,e.add(14,((e,t,n,a,r,i,s,o,l)=>{e.array.set(t,"BFS"),e.array.assignVariable("n",2,i+1),e.array.assignVariable("m",2,s+1);for(let d=0;d<r.length;d++)1!=a[d]&&d!==s||(d===s||l.includes(d)?e.array.select(0,d+1,0,d+1,ks):e.array.select(0,d+1,0,d+1,Cs));e.array.setList(n),e.graph.removeEdgeColor(o,s),e.graph.removeEdgeColor(i,s),e.graph.colorEdge(i,s,Os),e.array.setList(t),e.array.setList(n)}),[[f,m,g],y,p,h,j,t,a,n]),n.push(t),y.push(t+1),p[t]=!0,e.add(15,((e,t,n,a,r)=>{e.array.setList(t),0==n[a]&&r.includes(a)&&(e.array.deselect(0,a+1),e.array.select(0,a+1,0,a+1,Cs))}),[y,h,t,n])}}e.add(5,((e,t,n,a,r,i)=>{e.array.assignVariable("m",2,void 0),e.array.assignVariable("n",2,void 0);for(let s=0;s<r.length;s++)1==r[s]&&(i.includes(s)?e.array.select(0,s+1,0,s+1,ks):e.array.select(0,s+1,0,s+1,Cs));null!=t&&null!=n&&(e.graph.removeEdgeColor(t,n),null!=t&&null!=n&&(e.graph.removeEdgeColor(t,n),a[n]===t?e.graph.colorEdge(t,n,Os):a[t]===n&&e.graph.colorEdge(t,n,Ms)))}),[j,v,u,h,n])})(A)}},Fs={initVisualisers:()=>({graph:{instance:new er("graph",null,"Graph view"),order:0},array:{instance:new dr("array",null,"Parent array, Finalized array & Stack"),order:1}}),run(e,t){let{edgeValueMatrix:n,coordsMatrix:a,endNodes:r,startNode:i,moveNode:s}=t;const o=[...n],l=[...a],d=n.length,c=new Array(d).fill(!1),h=new Array(d).fill(null),u=new Array(d).fill(!1),p=[],g=[],m=[];let f=[];const b=i-1,y=r[0]-1;let A=null,x=null;e.add(1,((e,t,a)=>{e.graph.directed(!1),e.graph.weighted(!1),e.graph.moveNodeFn(s),e.graph.set(t,Array.from({length:n.length},((e,t)=>t+1)),a)}),[o,l]),g.push("Parent[i]"),p.push("Finalised[i]"),m.push("i");for(let v=0;v<d;v+=1)h[v]=null,g.push(0),p.push(" "),m.push(v+1);e.add(6,((e,t)=>{e.array.set(t,"DFS")}),[[m,g,p]]);for(let v=0;v<d;v+=1)p[v+1]="false";e.add(7,((e,t)=>{e.array.set(t,"DFS")}),[[m,g,p]]);(t=>{const n=[t];for(f=n.toReversed().map((e=>e+1)),u[t]=!0,e.add(8,((e,n,a,r)=>{e.array.set(n,"DFS"),e.array.setList(a),e.array.select(0,t+1,0,t+1,ks),e.graph.colorNode(t,Ns)}),[[m,g,p],f,u]);e.add(2,((e,t,n,a,r,i)=>{e.array.assignVariable("m",2,void 0);for(let s=0;s<i.length;s++)1==i[s]&&e.array.select(0,s+1,0,s+1,ks);for(let s=0;s<r.length;s++)1==r[s]&&e.array.select(0,s+1,0,s+1,Cs);null!=t&&null!=n&&(e.graph.removeEdgeColor(t,n),null!=t&&null!=n&&(e.graph.removeEdgeColor(t,n),a[n]===t?e.graph.colorEdge(t,n,Os):a[t]===n&&e.graph.colorEdge(t,n,Ms)))}),[x,A,h,c,u]),n.length>0;){for(x=n.pop(),f=n.toReversed().map((e=>e+1)),e.add(9,((e,t,n,a,r,i)=>{e.array.set(t,"DFS"),e.array.assignVariable("n",2,i+1);for(let s=0;s<a.length;s++)1==a[s]&&e.array.select(0,s+1,0,s+1,ks);for(let s=0;s<r.length;s++)1==r[s]&&e.array.select(0,s+1,0,s+1,Cs);e.array.setList(n)}),[[m,g,p],f,u,c,x]),e.add(10);c[x];){if(e.add(11),0===n.length)return void e.add(12,((e,t,n,a)=>{e.array.set(t,"DFS"),e.array.assignVariable("n",2,void 0);for(let r=0;r<n.length;r++)1==n[r]&&e.array.select(0,r+1,0,r+1,Cs)}),[[m,g,p],c]);x=n.pop(),f=n.toReversed().map((e=>e+1)),e.add(13,((e,t,n,a,r,i)=>{e.array.set(t,"DFS"),e.array.assignVariable("n",2,n+1);for(let s=0;s<r.length;s++)1==r[s]&&e.array.select(0,s+1,0,s+1,ks);for(let s=0;s<i.length;s++)1==i[s]&&e.array.select(0,s+1,0,s+1,Cs);e.array.setList(a)}),[[m,g,p],x,f,u,c])}if(c[x]=!0,p[x+1]="true",u[x]=!1,e.add(14,((e,t,n,a,r,i,s)=>{e.array.set(t,"DFS"),e.array.assignVariable("n",2,i+1);for(let o=0;o<a.length;o++)1==a[o]&&e.array.select(0,o+1,0,o+1,ks);for(let o=0;o<r.length;o++)1==r[o]&&e.array.select(0,o+1,0,o+1,Cs);e.graph.removeNodeColor(i),e.graph.colorNode(i,1),null!==s[i]&&(e.graph.removeEdgeColor(i,s[i]),e.graph.colorEdge(i,s[i],Ms)),e.array.setList(n)}),[[m,g,p],f,u,c,x,h]),e.add(15),x==y)return void e.add(3,((e,n,a,r,i,s)=>{e.array.assignVariable("n",2,void 0),e.array.assignVariable("end",2,s+1),e.array.assignVariable("start",2,t+1);for(let t=0;t<r.length;t++)e.array.deselect(0,t);let o=s;for(;o!=i&&null!=r[o];)e.array.select(0,o+1,0,o+1,Ts),e.array.select(1,o+1,1,o+1,Ts),e.graph.removeEdgeColor(o,r[o]),e.graph.colorEdge(o,r[o],Rs),o=r[o];e.array.select(0,b+1,0,b+1,Ts)}),[x,A,h,b,y]);A=null;for(let t=0;t<d;t++)if(0!=o[x][t]&&(e.add(4,((e,t,n,a,r,i,s)=>{null!=t&&null!=a&&(e.graph.removeEdgeColor(t,a),r[a]===t?e.graph.colorEdge(t,a,Os):r[t]===a&&e.graph.colorEdge(t,a,Ms)),e.graph.removeEdgeColor(t,n),e.graph.colorEdge(t,n,2),e.graph.colorEdge(t,n,Is),e.array.assignVariable("m",2,n+1);for(let o=0;o<s.length;o++)1==s[o]&&e.array.select(0,o+1,0,o+1,ks);for(let o=0;o<i.length;o++)1==i[o]&&e.array.select(0,o+1,0,o+1,Cs)}),[x,t,A,h,c,u]),A=t,e.add(16),!c[t])){let a=h[t];h[t]=x,g[t+1]=x+1,e.add(17,((e,t,n,a,r,i,s,o)=>{e.array.set(t,"DFS"),e.array.assignVariable("n",2,i+1),e.array.assignVariable("m",2,s+1);for(let l=0;l<a.length;l++)1==a[l]&&e.array.select(0,l+1,0,l+1,ks);for(let l=0;l<r.length;l++)1==r[l]&&e.array.select(0,l+1,0,l+1,Cs);e.graph.removeEdgeColor(o,s),e.graph.removeEdgeColor(i,s),e.graph.colorEdge(i,s,Os),e.array.deselect(0,s+1),e.array.select(0,s+1,0,s+1,ks),e.graph.removeNodeColor(s),e.graph.colorNode(s,Os),e.array.setList(n)}),[[m,g,p],f,u,c,x,t,a]),n.push(t),f=n.toReversed().map((e=>e+1)),u[t]=!0,e.add(18,((e,t,n,a)=>{e.array.setList(t)}),[f,c,t])}}e.add(5,((e,t,n,a)=>{e.array.set(t,"DFS"),e.array.assignVariable("n",2,void 0);for(let r=0;r<n.length;r++)1==n[r]&&e.array.select(0,r+1,0,r+1,Cs)}),[[m,g,p],c])})(b)}},Hs={initVisualisers:()=>({graph:{instance:new er("graph",null,"Graph view"),order:0},array:{instance:new dr("array",null,"Parent array"),order:1}}),run(e,t){let{edgeValueMatrix:n,coordsMatrix:a,startNode:r,endNodes:i,moveNode:s}=t;const o="DFSrec",l=[...n],d=[...a],c=n.length,h=" ",u=[],p=[],g=[],m=r-1,f=i[0]-1,b=[],y=(e,t,n,a,r)=>{e.array.set(t,o),e.array.hideArrayAtIndex(2),e.array.setList(r),e.array.assignVariable("n",2,n),e.array.assignVariable("m",2,a);for(let i=0;i<c;i++)t[1][i+1]!==h?(e.array.select(0,i+1,0,i+1,Cs),e.graph.removeNodeColor(i),e.graph.colorNode(i,Ss)):t[2][i+1]&&(e.array.select(0,i+1,0,i+1,ks),e.graph.removeNodeColor(i),e.graph.colorNode(i,Ns))},A=(t,a,r)=>{if(b.unshift("("+t+","+a+")"),e.add("dfs1",((e,t,n,a,r)=>{y(e,t,n,null,r)}),[[g,u,p],t,null,b],r),e.add("check_parent",((e,t,n,a,r,i)=>{y(e,t,n,null,r),0!==i&&(t[1][n]===h||t[1][n]===i||t[1][i]===n?(e.graph.removeEdgeColor(i-1,n-1),e.graph.colorEdge(i-1,n-1,Ms)):(e.graph.removeEdgeColor(i-1,n-1),e.graph.colorEdge(i-1,n-1,Os)))}),[[g,u,p],t,null,b,a],r),u[t]===h){if(u[t]=a,e.add("assign_parent",((e,t,n,a,r)=>{y(e,t,n,null,r)}),[[g,u,p],t,null,b],r),e.add("check_end",((e,t,n,a,r)=>{y(e,t,n,null,r)}),[[g,u,p],t,0,b],r),t===f+1)return e.add("found",((e,t,n,a,r)=>{y(e,t,n,null,r)}),[[g,u,p],t,null,b],r),b.shift(),!0;for(let e=c;e>0;e--)0!==n[t-1][e-1]&&(p[e]=!0);e.add("frontier",((e,t,a,r,i)=>{y(e,t,a,null,i);for(let s=c;s>0;s--)0!==n[a-1][s-1]&&t[1][a]!==s&&t[1][s]!==a&&(e.graph.colorEdge(a-1,s-1,Os),e.graph.removeNodeColor(a-1),e.graph.colorNode(a-1,Ss))}),[[g,u,p],t,null,b],r);for(let a=c;a>0;a--)if(0!==n[t-1][a-1]){e.add("neighbours",((e,t,n,a,r)=>{y(e,t,n,a,r),e.graph.removeEdgeColor(a-1,n-1),e.graph.colorEdge(a-1,n-1,Is)}),[[g,u,p],t,a,b],r),e.add("rec_dfs1",((e,t,n,a,r)=>{y(e,t,n,a,r)}),[[g,u,p],t,a,b],r);let n=A(a,t,r+1);if(e.add("rec_dfs1_done",((e,t,n,a,r)=>{y(e,t,n,a,r)}),[[g,u,p],t,a,b],r),n)return e.add("rec_found",((e,t,n,a,r)=>{y(e,t,n,a,r)}),[[g,u,p],t,a,b],r),b.shift(),!0}}return e.add("not_found",((e,t,n,a,r)=>{y(e,t,n,null,r)}),[[g,u,p],t,null,b],r),b.shift(),!1};e.add("start",((e,t,n)=>{e.graph.directed(!1),e.graph.weighted(!1),e.graph.moveNodeFn(s),e.graph.set(t,Array.from({length:c},((e,t)=>t+1)),n)}),[l,d],0),g.push("i"),u.push("Parent[i]"),p.push("Seen[i]");for(let v=0;v<c;v+=1)g[v+1]=v+1,p.push(!1),u.push(h);p[r]=!0,e.add("init",((e,t,n,a,r)=>{y(e,t,n,null,r)}),[[g,u,p],r,null,b],0);let x=A(r,0,0);e.add("top_call",((e,t,n,a,r)=>{y(e,t,n,null,r)}),[[g,u,p],null,null,b],0),x?e.add("finish",((e,t)=>{e.array.set(t,o),e.array.hideArrayAtIndex(2),e.array.setList([]),e.array.assignVariable("end",2,f+1),e.array.assignVariable("start",2,m+1);let n=f,a=0;for(;n!=m&&null!=t[1][n+1];)a=t[1][n+1]-1,e.array.select(0,n+1,0,n+1,Ts),e.array.select(1,n+1,1,n+1,Ts),e.graph.removeEdgeColor(n,a),e.graph.colorEdge(n,a,Rs),n=a;e.array.select(0,m+1,0,m+1,Ts)}),[[g,u,p],p],0):e.add("finish",((e,t,n,a,r)=>{y(e,t,n,null,r)}),[[g,u,p],null,null,b],0)}},_s={initVisualisers:()=>({graph:{instance:new er("graph",null,"Graph view",{displayAxis:!1}),order:0},array:{instance:new dr("array",null,"Parent array & Priority Queue"),order:1}}),run(e,t){let{edgeValueMatrix:n,coordsMatrix:a,startNode:r}=t;const i=[...n],s=[...a],o=n.length;let l=new Array(o);for(let N=0;N<l.length;N+=1)l[N]=new Array(o);const d=new Array(o),c=new Array(o),h=new Array(o),u=new Array(o),p=[],g=new Array(o).fill("");let m,f,b,y;const A=[],x=[],v=[];e.add(1,((e,t,n)=>{e.graph.directed(!1),e.graph.weighted(!0),e.graph.set(t,Array.from({length:o},((e,t)=>t+1)),n)}),[i,s]);const j=()=>{let e,t,n;for(e=m;e<f;e+=1){for(n=u[e],t=e-1;t>=m&&d[n]<d[u[t]];t-=1)u[t+1]=u[t];u[t+1]=n}},w=()=>{let e=1/0;for(let t=1;t<x.length;t++)null!=x[t]&&x[t]<e&&(e=x[t],b=t)},E=t=>{let n,a,r;for(e.add(5),n=0;n<f;n+=1)a=l[t][n],a>0&&!h.includes(n)&&m<f&&!A.includes(n)&&e.add(5,((e,t,n)=>{e.graph.visit0(t,n)}),[t,n]),a>0&&c[n]&&a<d[n]&&(d[n]=a,x[n+1]===1/0?x[n+1]="".concat(d[n].toString(),"<\u221e"):null!==d[n]&&null!=x[n+1]&&(x[n+1]="".concat(d[n].toString(),"<").concat(x[n+1].toString())),e.add(6,((e,t,n)=>{e.array.set(t,"prim"),null!=t[2][n]&&(e.array.select(2,n),e.array.assignVariable("Min",2,n))}),[[p,v,x],b]),x[n+1]=d[n],e.add(7,((e,t,n)=>{e.array.set(t,"prim"),null!=t[2][n]&&(e.array.select(2,n),e.array.assignVariable("Min",2,n))}),[[p,v,x],b]),j(),h[n]=t,r=b,w(),e.add(8,((e,t,n,a)=>{e.array.deselect(2,t),null!==a[n]&&(e.array.select(2,n),e.array.assignVariable("Min",2,n))}),[r,b,x]),v[n+1]=t+1,e.add(9,((e,t,n)=>{e.array.set(t,"prim"),e.array.select(2,n),e.array.assignVariable("Min",2,n)}),[[p,v,x],b]))};let k;for(l=[...i],f=o,k=0;k<f;k+=1)d[k]=1/0,h[k]=-1,c[k]=1;for(x.push("Cost[i]"),p.push("i"),v.push("Parent[i]"),k=0;k<f;k+=1)u[k]=k,p[k+1]=k+1,x.push(1/0),v.push("-");for(d[r-1]=0,x[r]=0,u[0]=r-1,h[r-1]=r-1,v[r]=r,u[r-1]=0,b=r,m=0,e.add(2,((e,t,n)=>{e.array.set(t,"prim"),e.array.select(2,n),e.array.assignVariable("Min",2,n)}),[[p,v,x],b]),e.add(3,((e,t,n)=>{e.array.set(t,"prim"),e.array.select(2,n),e.array.assignVariable("Min",2,n)}),[[p,v,x],b]);m<f;){k=u[m],g[m]=k+1,c[k]=0,m+=1,x[b]=null,y=b,w(),e.add(4,((e,t,n,a,r,i,s)=>{e.graph.visit0(r,i),e.graph.select(r,i),e.array.deselect(s),e.array.set(t,"prim"),e.array.deselect(2,a),a!==n&&null!==t[2][n]&&(e.array.select(2,n),e.array.assignVariable("Min",2,n))}),[[p,v,x],b,y,k,h[k],b]),E(k),w();const t=[];for(let e=0;e<f;e+=1)l[k][e]>0&&!h.includes(e)&&m<f&&!A.includes(e)&&t.push(e);u[m]&&e.add(5,((e,t,n)=>{e.graph.visit0(t,n)}),[h[u[m]],u[m]]),e.add(5,((e,t,n)=>{e.graph.allLeave(t,n),e.graph.visit0(t,t)}),[k,t]),e.add(3),A.push(k)}return h}},Gs={initVisualisers:()=>({graph:{instance:new er("graph",null,"Graph view"),order:0},array:{instance:new dr("array",null,"Parent array & Priority Queue"),order:1}}),run(e,t){let{edgeValueMatrix:n,coordsMatrix:a,startNode:r,endNodes:i,moveNode:s}=t;const o="prim",l="-",d=["Cost","Tot."," = "],c=[...n],h=[...a],u=n.length,p=[],g=[],m=[],f=[],b=r-1;i[0];let y=0;const A=new Set;let x=b,v=[null,null];const j=Array(u).fill(1/0),w=()=>{let e=1/0;x=null;for(let t=u-1;t>=0;t--)!A.has(t)&&j[t]<=e&&(e=j[t],x=t)},E=e=>"number"===typeof e&&isFinite(e),k=function(e,t,n,a,r){let i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:null;if(e.array.set(t,o),null!=i&&t[2].length>3)e.array.assignVariable(d[0],2,0),e.array.assignVariable(d[1],2,1),e.array.assignVariable(d[2],2,2),e.array.assignVariable(i,2,3);else{let t=null===r?null:r+1,i=null===a?null:a+1,s=null===n?null:n+1;e.array.assignVariable("n",2,i),e.array.assignVariable("m",2,t),e.array.assignVariable("Min",2,s)}for(let s=0;s<u;s++)null===t[2][s+1]?(e.array.select(0,s+1,0,s+1,Cs),e.graph.removeNodeColor(s),e.graph.colorNode(s,Ss)):E(t[2][s+1])&&(e.array.select(0,s+1,0,s+1,ks),e.graph.removeNodeColor(s),e.graph.colorNode(s,Ns));null!=n&&e.array.select(2,n+1,2,n+1,Bs)};e.add(1,((e,t,n)=>{e.graph.directed(!1),e.graph.weighted(!0),e.graph.moveNodeFn(s),e.graph.set(t,Array.from({length:u},((e,t)=>t+1)),n)}),[c,h]);const N=Array(u).fill(null);m.push("i"),g.push("Parent[i]"),p.push("Cost[i]"),f.push("Final Cost");for(let I=0;I<u;I+=1)m[I+1]=I+1,p.push(l),g.push(0),f.push(l);e.add(5,((e,t)=>{e.array.set(t,o)}),[[m,g,p,f],0]);for(let I=0;I<u;I+=1)p[I+1]=1/0;e.add(6,((e,t)=>{e.array.set(t,o)}),[[m,g,p,f],0]),j[b]=0,p[b+1]=0,e.add(7,((e,t,n)=>{e.array.set(t,o),e.array.select(0,n+1,0,n+1,ks),e.graph.colorNode(n,Ns)}),[[m,g,p,f],b]),e.add(8,((e,t,n)=>{e.array.set(t,o),e.array.assignVariable("Min",2,n+1),e.array.select(2,n+1,2,n+1,Bs),e.array.select(0,n+1,0,n+1,ks)}),[[m,g,p,f],b]);let O=null;for(;;){if(w(),e.add(2,((e,t,n,a,r,i)=>{k(e,t,n,i,null),null!=a[0]&&(e.graph.removeEdgeColor(a[0],a[1]),null!=r[a[0]]&&t[3][a[0]+1]==l&&(e.graph.removeEdgeColor(r[a[0]],a[0]),e.graph.colorEdge(r[a[0]],a[0],Os)),null!=r[a[1]]&&t[3][a[1]+1]==l&&(e.graph.removeEdgeColor(r[a[1]],a[1]),e.graph.colorEdge(r[a[1]],a[1],Os)),t[3][a[0]+1]!=l&&(e.graph.removeEdgeColor(r[a[0]],a[0]),e.graph.colorEdge(r[a[0]],a[0],Ms)),t[3][a[1]+1]!=l&&(e.graph.removeEdgeColor(r[a[1]],a[1]),e.graph.colorEdge(r[a[1]],a[1],Ms)))}),[[m,g,p,f],x,v,N,O]),!(A.size<u)){y=f.reduce(((e,t)=>E(t)?e+t:e),0),e.add(99,((e,t,n,a,r,i)=>{k(e,t,n,a,r,i);for(let s=0;s<u;s++)for(let n=0;n<u;n++)t[1][s+1]===n+1&&(e.graph.removeEdgeColor(s,n),e.graph.colorEdge(s,n,Rs))}),[[m,g,p,f],null,null,null,y]);break}if(O=null,w(),O=x,f[x+1]=j[x],p[O+1]=null,A.add(O),w(),e.add(9,((e,t,n,a,r)=>{null!=r&&(e.graph.removeEdgeColor(r,a),e.graph.colorEdge(r,a,Ms)),k(e,t,n,a,null)}),[[m,g,p,f],x,O,N[O]]),e.add(10),null===O||j[O]===1/0){p[O+1]="\u221e",f[O+1]=l,x=O,y=f.reduce(((e,t)=>E(t)?e+t:e),0),e.add(3,((e,t,n,a,r,i)=>{e.graph.removeNodeColor(O),k(e,t,n,a,r,i);for(let s=0;s<u;s++)for(let n=0;n<u;n++)t[1][s+1]===n+1&&(e.graph.removeEdgeColor(s,n),e.graph.colorEdge(s,n,Rs))}),[[m,g,p,f],x,O,null,y]);break}for(let t=0;t<u;t++)if(0!==n[O][t]){e.add(4,((e,t,n,a,r,i,s)=>{null!=a[0]&&(e.graph.removeEdgeColor(a[0],a[1]),null!=r[a[0]]&&t[3][a[0]+1]==l&&(e.graph.removeEdgeColor(r[a[0]],a[0]),e.graph.colorEdge(r[a[0]],a[0],Os)),null!=r[a[1]]&&t[3][a[1]+1]==l&&(e.graph.removeEdgeColor(r[a[1]],a[1]),e.graph.colorEdge(r[a[1]],a[1],Os)),t[3][a[0]+1]!=l&&(e.graph.removeEdgeColor(r[a[0]],a[0]),e.graph.colorEdge(r[a[0]],a[0],Ms)),t[3][a[1]+1]!=l&&(e.graph.removeEdgeColor(r[a[1]],a[1]),e.graph.colorEdge(r[a[1]],a[1],Ms))),e.graph.removeEdgeColor(i,s),e.graph.colorEdge(i,s,Is),k(e,t,n,i,s)}),[[m,g,p,f],x,v,N,O,t]);const a=n[O][t];let r=p[t+1];if(p[t+1]===1/0&&(r="\u221e"),A.has(t)||(a<j[t]?p[t+1]="".concat(a," ").concat("<"," ").concat(r):p[t+1]="".concat(a," ").concat("\u226e"," ").concat(r)),e.add(11,((e,t,n,a,r)=>{k(e,t,n,a,r)}),[[m,g,p,f],x,O,t]),A.has(t)||(p[t+1]=j[t]),v=[O,t],!A.has(t)&&a<j[t]){j[t]=a,p[t+1]=a,e.add(12,((e,t,n,a,r)=>{k(e,t,n,a,r)}),[[m,g,p,f],x,O,t]),w(),e.add(13,((e,t,n,a,r)=>{k(e,t,n,a,r)}),[[m,g,p,f],x,O,t]),g[t+1]=O+1;const n=N[t];N[t]=O,e.add(14,((e,t,n,a,r,i,s)=>{e.graph.removeEdgeColor(s,r),e.graph.removeNodeColor(a),e.graph.colorEdge(a,r,Os),e.graph.colorNode(a,1),null!=i&&e.graph.removeEdgeColor(i,r),k(e,t,n,s,r)}),[[m,g,p,f],x,N[t],t,n,O])}}}}},Vs={initVisualisers:()=>({graph:{instance:new er("graph",null,"Graph view"),order:0},array:{instance:new dr("array",null,"Parent array & Priority Queue"),order:1}}),run(e,t){let{edgeValueMatrix:n,coordsMatrix:a,startNode:r,endNodes:i,moveNode:s}=t;const o="kruskal",l="...",d=["Cost","Tot."," = "],c=[...n],h=[...a],u=n.length,p=[],g=[],m=[],f=[],b=[],y=(e,t)=>{for(;e[t]!=t;)e[t]=e[e[t]],t=e[t];return t},A=(e,t,n,a)=>{let r=y(e,n),i=y(e,a);if(r!==i){if(t[r]>t[i]){const e=r;r=i,i=e}e[r]=i,t[r]==t[i]?(t[i]+=1,t[r]=null):t[r]=null}},x=()=>{for(let e=1;e<=u;e+=1)g[e]=y(j,e-1)+1,e-1<v.length?b[e]=v[e-1].node1+1+"-"+(v[e-1].node2+1):b[e]="";v.length>u&&(b[u]=l)};e.add("Kruskal(G)",((e,t,n)=>{e.graph.directed(!1),e.graph.weighted(!0),e.graph.moveNodeFn(s),e.graph.set(t,Array.from({length:u},((e,t)=>t+1)),n)}),[c,h]);let v=[],j=[],w=[];for(let N=0;N<u;N+=1){j.push(N),w.push(0);for(let e=0;e<u;e+=1)c[N][e]>0&&N<e&&v.push({weight:c[N][e],node1:N,node2:e})}v.sort(((e,t)=>e.weight-t.weight)),p.push("i"),g.push("find(i)"),m.push("Selected"),f.push("Cost"),b.push("Edges");for(let N=0;N<u;N+=1)p[N+1]=N+1,m.push(""),g.push(""),f.push(""),N<v.length?b.push(v[N].node1+1+"-"+(v[N].node2+1)):b.push("");b.length>u&&(b.pop(),b.push(l)),e.add("initEdges",((e,t)=>{e.array.set(t,o)}),[[p,g,m,f,b],0]),e.add("SelectedEmpty",((e,t)=>{}),[[p,g,m,f,b],0]);let E=u,k=0;for(let N=1;N<=u;N+=1)g[N]=y(j,N-1)+1;for(e.add("initNodeSets",((e,t)=>{e.array.set(t,o)}),[[p,g,m,f,b],0]);x(),v.length>u&&(b[u]=l),e.add("while",((e,t,n)=>{e.array.set(t,o);for(let a=0;a<u;a++)e.graph.removeNodeColor(a);n<E-1?e.array.select(4,1,4,1,ks):e.array.select(2,0,2,0,ks)}),[[p,g,m,f,b],k]),0!==v.length&&k<E-1;){let t=v.shift(),n=t.node1,a=t.node2;x(),e.add("RemoveMin",((e,t,n,a)=>{e.array.set(t,o),e.graph.colorEdge(n,a,Os),e.array.select(0,n+1,0,n+1,ks);for(let r=0;r<u;r++)t[1][r+1]===t[1][n+1]&&(e.graph.removeNodeColor(r),e.graph.colorNode(r,Ns));if(t[1][n+1]!==t[1][a+1]){for(let n=0;n<u;n++)t[1][n+1]===t[1][a+1]&&(e.graph.removeNodeColor(n),e.graph.colorNode(n,Ss));e.array.select(0,a+1,0,a+1,Cs)}else e.array.select(0,a+1,0,a+1,ks)}),[[p,g,m,f,b],n,a]),e.add("DifferentTrees",((e,t,n,a)=>{e.array.set(t,o),e.array.select(0,n+1,0,n+1,ks),e.array.select(1,n+1,1,n+1,ks);for(let r=0;r<u;r++)t[1][r+1]===t[1][n+1]&&(e.graph.removeNodeColor(r),e.graph.colorNode(r,Ns));if(t[1][n+1]!==t[1][a+1]){for(let n=0;n<u;n++)t[1][n+1]===t[1][a+1]&&(e.graph.removeNodeColor(n),e.graph.colorNode(n,Ss));e.array.select(0,a+1,0,a+1,Cs),e.array.select(1,a+1,1,a+1,Cs)}else e.array.select(0,a+1,0,a+1,ks),e.array.select(1,a+1,1,a+1,ks)}),[[p,g,m,f,b],n,a]),y(j,n)!=y(j,a)&&(k++,m[k]=t.node1+1+"-"+(t.node2+1),f[k]=t.weight,x(),e.add("addSelected",((e,t,r,i,s)=>{e.array.set(t,o),e.array.select(0,r+1,0,r+1,ks),e.array.select(1,r+1,1,r+1,ks),e.array.select(0,i+1,0,i+1,Cs),e.array.select(1,i+1,1,i+1,Cs),e.array.select(3,s,3,s,ks),e.array.select(2,s,2,s,ks);for(let n=0;n<u;n++)e.graph.removeNodeColor(n);e.graph.removeEdgeColor(n,a),e.graph.colorEdge(n,a,Rs)}),[[p,g,m,f,b],n,a,k]),A(j,w,n,a),x(),e.add("union",((e,t,n,a)=>{e.array.set(t,o),e.array.select(0,n+1,0,n+1,ks),e.array.select(0,a+1,0,a+1,ks),e.array.select(1,n+1,1,n+1,ks),e.array.select(1,a+1,1,a+1,ks)}),[[p,g,m,f,b],n,a]))}e.add("return",((e,t,n)=>{e.array.set(t,o);let a=0;for(let r=1;r<=n;r++)a+=t[3][r];e.array.assignVariable(d[0],2,0),e.array.assignVariable(d[1],2,1),e.array.assignVariable(d[2],2,2),e.array.assignVariable(a,2,3)}),[[p,g,m,f,b],k])}};const zs=1,Qs=2,Us=3,Ws=4,qs=5,Xs=6,Ys=7,Ks=8,Zs=9,Js=10;var $s={explanation:H,initVisualisers:()=>({array:{instance:new dr("array",null,"Hash Table"),order:0},graph:{instance:new er("graph",null,"Hashing Functions"),order:1}}),run(e,t){const n=t.name,a=t.hashSize;let r,i=t.values,s=Array.from({length:a},((e,t)=>t)),o=Array(a).fill("-"),l=Array(a).fill("");let d=0;function c(t,r,i,s){d+=1,e.add(Ws,((e,t,r,i,s)=>{e.array.showKth(r),e.array.unfill(0,0,void 0,a-1),e.array.assignVariable(t,2,s,i),e.graph.updateNode(In.Key,t),e.graph.updateNode(In.Value," "),"HashingDH"===n&&(e.graph.updateNode(In.Key2,t),e.graph.updateNode(In.Value2," "))}),[r,d,i,s]);let o=Cn(e,qs,r,a),l=Sn(e,Xs,r,a,n,"Insert");for(e.add(Ys,((e,t,n)=>{e.array.assignVariable(t,2,n),e.array.fill(0,n,void 0,void 0,Nn)}),[r,o]);void 0!==t[o];){let t=o;o=(o+l)%a,e.add(Ks,((e,t)=>{e.array.fill(0,t,void 0,void 0,On)}),[t]),e.add(Ys,((e,t,n)=>{e.array.assignVariable(t,2,n),e.array.fill(0,n,void 0,void 0,Nn)}),[r,o])}return t[o]=r,e.add(Zs,((e,t,n)=>{e.array.updateValueAt(1,n,t),e.array.fill(0,n,void 0,void 0,kn)}),[r,o]),o}let h,u,p=new Array(a);e.add(zs,((e,a)=>{switch(e.array.set(a,t.name,"",{rowLength:20,rowHeader:["Index","Value",""]}),e.array.hideArrayAtIndex([1,2]),e.graph.weighted(!0),n){case"HashingLP":e.graph.set([[0,"Hash"],[0,0]],[" "," "],[[-5,0],[5,0]]);break;case"HashingDH":e.graph.set([[0,"Hash1",0,0],[0,0,0,0],[0,0,0,"Hash2"],[0,0,0,0]],[" "," "," "," "],[[-5,2],[5,2],[-5,-2],[5,-2]])}}),[[s,o,l]]),e.add(Qs,(e=>{e.array.hideArrayAtIndex(2)})),e.add(Us,(e=>{e.array.showKth([0,""])}));for(const g of i)u=c(p,g,h,u),h=g;return e.add(Js,((e,t)=>{e.array.assignVariable(t,2,void 0),e.array.unfill(0,0,void 0,a-1),e.graph.updateNode(In.Key," "),e.graph.updateNode(In.Value," "),"HashingDH"===n&&(e.graph.updateNode(In.Key2," "),e.graph.updateNode(In.Value2," ")),r=e.array.extractArray([1],"x")}),[h]),r}};const eo=1,to=2,no=3,ao=4,ro=5,io=7,so=8;var oo={initVisualisers(e){let{visualisers:t}=e;return{array:{instance:t.array.instance,order:0},graph:{instance:t.graph.instance,order:1}}},run(e,t){const n=t.target,a=t.hashSize;let r=t.visualisers.array.instance.extractArray(1,"-");e.add(eo,((e,t)=>{e.array.showKth(["N/A",""]),e.graph.updateNode(In.Key,t),e.graph.updateNode(In.Value," ");for(let n=0;n<a;n++)e.array.unfill(0,0,void 0,a-1)}),[n]);let i=Cn(e,to,n,a),s=Sn(e,no,n,a,t.name,"Search");for(e.add(ao,((e,t)=>{e.array.assignVariable("i",2,t),e.array.fill(0,t,void 0,void 0,Nn)}),[i]);r[i]!==n&&void 0!==r[i];)e.add(ao,((e,t)=>{e.array.fill(0,t,void 0,void 0,On)}),[i]),i=(i+s)%a,e.add(ro,((e,t)=>{e.array.assignVariable("i",2,t)}),[i]),e.add(ao,((e,t)=>{e.array.fill(0,t,void 0,void 0,Nn)}),[i]);r[i]===n?e.add(io,((e,t)=>{e.array.fill(0,t,void 0,void 0,kn)}),[i]):e.add(so,((e,t)=>{e.array.fill(0,t,void 0,void 0,On)}),[i])}};function lo(e){const t=[];let n={},a="",r=!1,i=0;for(const s of e)0===s.localeCompare("\\In{")?i+=1:0===s.localeCompare("\\In}")?i-=1:s.indexOf("\\Expl{")>=0?(r=!0,a="",a+=s.substring(7,s.length)):0===s.localeCompare("\\Expl}")?(r=!1,0!==Object.keys(n).length&&(n.explanation=a),a=""):r?(a+=" ",a+=s):(0!==Object.keys(n).length&&(t.push(n),n={}),0===s.localeCompare("\\NewLine")?t.push({code:"\n",explanation:"",indentation:i}):(s.indexOf(" \\Ref ")>=0?(n.code=s.substring(0,s.indexOf(" \\Ref ")),n.ref=s.substring(s.indexOf(" \\Ref ")+6,s.length)):s.indexOf(" \\B ")>=0?(n.code=s.substring(0,s.indexOf(" \\B ")),n.bookmark=s.substring(s.indexOf(" \\B ")+4,s.length)):n.code=s,n.explanation="",n.indentation=i));return 0!==Object.keys(n).length&&t.push(n),t}function co(e,t,n,a){let r;a[t]=[],e[t].forEach((i=>{r="\xa0\xa0\xa0\xa0".repeat(n+i.indentation)+i.code,a[t].push({...i,code:r}),i.ref&&co(e,i.ref,n+i.indentation,a)}))}function ho(e){const t=function(e){let t="Default";const n={};let a=[],r=!1,i=!1;for(const s of e)0===s.localeCompare("\\Code}")?(n[t]=lo(a),a=[],r=!1):0===s.localeCompare("\\Code{")?(r=!0,i=!0):!0===r&&(i?(t=s,i=!1):a.push(s));return n}(function(e){const t=e.split("\n"),n=[];let a="";for(const r of t)a="".concat(r.trim()),""!==a&&n.push(a);return n}(e.replace(/\\Note\{[^}]*\}/gs,"")));if(Object.keys(t).length>0){const e={};return co(t,"Main",0,e),e}return t}var uo=ho("\n\\Code{\n    Main\n    BST_Search(t, k)  // return subtree whose root has key k \\B 8\n                      // or NotFound, if no such node is present\n    \\In{\n        while t not Empty \\B 1\n        \\In{\n            if t.key = k  \\B 2\n            \\In{\n                return t \\B 3\n                \\Expl{  We have found a node with the desired key k.\n                \\Expl}\n            \\In}\n            if t.key > k  \\B 4\n            \\Expl{  The BST condition is that nodes with keys less than the \n                    current node's key are to be found in the left subtree, and\n                    nodes whose keys are greater are to be in the right subtree.\n            \\Expl}\n            \\In{\n                t <- t.left \\B 5\n            \\In}\n            else\n            \\In{\n                t <- t.right \\B 6\n            \\In}\n        return NotFound \\B 7\n        \\In}\n    \\In}\n    \\Code}\n"),po=ho("\n\\Code{\n    Main\n    BST_Build(keys)  // return the BST that results from inserting nodes\n                     // with keys 'keys', in the given order, into an\n                     // initially empty BST\n    t <- Empty \\B 1\n    for each k in keys \\B 2\n    \\In{\n        t <- BST_Insert(t, k) \\Ref Insert\n    \\In}\n\\Code}\n\\Code{\n    Insert\n    // Insert key k in BST t, maintaining the BST invariant\n    Create_Node() \\Ref NewNode\n\n    if t = Empty \\B 7\n    \\In{\n        t <- n      // in this case, the result is a tree with just one node \\B 8\n        \\Expl{  If the tree is initially empty, the resulting BST is just\n                the new node, which has key k, and empty sub-trees.\n        \\Expl}\n    \\In}\n    else\n    \\In{\n      Locate the node p that should be the parent of the new node n. \\Ref Locate\n      if k < p.key  \\B 9\n      \\Expl{  The new node n (whose key is k) will be a child of p. We just \n              need to decide whether it should be a left or a right child of p.\n      \\Expl}\n      \\In{\n          p.left <- n       // insert n as p's left child \\B 10\n      \\In}\n      else\n      \\In{\n          p.right <- n      // insert n as p's right child  \\B 11\n      \\In}\n    \\In}\n\\Code}\n\n\\Code{\n    NewNode\n    n <- new Node     // create a new node to hold key k \\B 3\n    n.key <- k \\B 4\n    n.left <- Empty   // it will be a leaf, that is, \\B 5\n    n.right <- Empty  // it has empty subtrees \\B 6\n\\Code}\n  \n\\Code{\n  Locate\n  c <- t            // c traverses the path from the root to the insertion point \\B 13\n  \n  \\Expl{  c is going to follow a path down to where the new node is to \n          be inserted. We start from the root (t).\n  \\Expl}\n  repeat\n  \\In{\n      p <- c        // when the loop exits, p will be c's parent \\B 14\n      \\Expl{  Parent p and child c will move in lockstep, with p always \n              trailing one step behind c.\n      \\Expl}\n      if k < c.key \\B 15\n      \\Expl{  The BST condition is that nodes with keys less than the current\n              node's key are to be found in the left subtree, and nodes whose\n              keys are greater (or the same) are to be in the right subtree.\n      \\Expl}\n      \\In{\n          c <- c.left \\B 16\n      \\In}\n      else\n      \\In{\n          c <- c.right \\B 17\n      \\In}\n  \\In}\n  until c = Empty \\B 18\n  \\Expl{  At the end of this loop, c has located the empty subtree where new\n          node n should be located, and p will be the parent of the new node.\n  \\Expl}\n\\Code}\n"),go=ho("\n\\Note{  REAL specification of heapsort animation\n        \\Note}\n        \n        \\Code{\n        Main\n        HeapSort(A, n) // Sort array A[1]..A[n] in ascending order. \\B 1\n        \\Expl{  We are not using A[0] (for languages that start array indices at 0).\n        \\Expl}\n        \\In{\n            BuildHeap(A, n)    \\Ref BuildHeap \n            \\Expl{  First reorder the array elements so they form a (max) heap\n                    (no element is larger than its parent). The root node, A[1],\n                    is therefore the largest element.  \n            \\Expl}\n            SortHeap(A, n)    \\Ref SortHeap \n            \\Expl{  Convert the heap into a sorted array. The largest element is\n                    put in the correct position A[n] first and we work backwards \n                    from there, putting the next-largest element in its place, \n                    etc, shrinking the heap by one element at each step. \n            \\Expl}\n        \\In}\n        \\Code}\n        \n        \\Code{\n        BuildHeap\n        // build heap\n        for k <- Index of last non-leaf downto 1    \\Ref BHForLoop \n        \\Expl{  We use bottom-up heap creation, to build the heap from the bottom\n                up (tree view) and right to left (array view). The leaves are \n                already heaps of size 1, so nothing needs to be done with them. \n                Working backwards through the heap, and starting from the last \n                non-leaf node, we form heaps of up to size 3 (from 2 leaves plus\n                their parent k), then 7 (2 heaps of size 3 and their parent k) \n                etc, until the whole array is a single heap. \n        \\Expl}\n        \\In{\n            DownHeap(A, k, n)    \\Ref DownHeapk \n            \\Expl{  DownHeap is where smaller heaps are combined to form larger\n                    heaps. The children of node k are already heaps, so we need\n                    only be concerned about where A[k] fits in. \n            \\Expl}\n        \\In}\n        \\Code}\n        \n        \\Code{\n        BHForLoop\n        for k <- n/2 downto 1 \\B 4\n        \\Expl{  Using root index 1, the last non-leaf has index n/2 (rounded down\n                to the nearest integer).\n        \\Expl}\n        \\Code}\n        \n        \\Code{\n        DownHeapk\n        // DownHeap(A, k, n)\n        i <- k \\B 6\n        \\Expl{  Set index i to the root of the subtree that we are now going to \n                make into a heap. \n        \\Expl}\n        heap <- False // 'heap' is a flag \\B 7\n        while not (IsLeaf(A[i]) or heap) \\B 8\n        \\Expl{  Traverse down the heap until the current node A[i] is a leaf. \n                We also terminate the loop if the children of A[i] are in the \n                correct order relative to the parent, since we know that subtrees\n                lower down already meet the heap condition. We use the heap flag\n                to test the heap condition.  \n        \\Expl}\n        \\In{        \n            j <- IndexOfLargestChild(A, i, n)    \\Ref IndexOfLargestk \n            \\Expl{  Find the larger of the two children of the node.\n            \\Expl}\n            if A[i] >= A[j] \\B 14\n            \\In{\n                heap <- True \\B 15\n                \\Expl{  The heap condition is satisfied (the root is larger \n                        than both children), so exit from while loop. \n                \\Expl}\n            \\In}\n            else\n            \\In{\n                Swap(A[i], A[j]) // Swap root element with (larger) child \\B 17\n                i <- j \\B 18\n            \\In}\n        \\In}        \n        \\Code}\n        \n        \\Code{\n        IndexOfLargestk\n        if 2*i < n and A[2*i] < A[2*i+1] \\B 10\n        \\Expl{  The left child of A[i] is A[2*i] and the right child (if there is\n                a right child) is A[2*i+1]; set j to the index of the larger child.\n        \\Expl}\n        \\In{\n            j <- 2*i+1 \\B 11\n        \\In}\n        else\n        \\In{\n            j <- 2*i \\B 13\n        \\In}\n        \\Code}\n        \n        \\Code{\n        SortHeap\n        // Sort heap\n        while n > 1 \\B 20\n        \\Expl{  A[1] always has the largest value not yet processed in the \n                sorting phase. A[n] is the last array element in the heap-ordered\n                array that is not yet sorted. Repeatedly swap these two values, \n                so that the largest element is now in the last place, decrement n \n                and re-establish the heap condition for the remaining heap (which\n                now has one less element). Repeat this procedure until n=1, that \n                is, only one node remains.  \n        \\Expl}\n        \\In{\n            Swap(A[n], A[1]) \\B 21\n            n <- n-1 \\B 22\n            DownHeap(A, 1, n)    \\Ref DownHeap1\n            \\Expl{  Now that the root node has been swapped to the end, A[1] may \n                    no longer be the largest element in the (reduced size) heap.\n                    Use the DownHeap operation to restore the heap condition. \n            \\Expl}\n        \\In}\n        // Done \\B 37\n        \\Code}\n        \n        \\Note{  This is very similar to DownHeapk.\n        \\Note}\n        \n        \\Code{\n        DownHeap1\n        // DownHeap(A, 1, n)\n        i <- 1 \\B 24\n        \\Expl{  Set index i to the root of the subtree that we are now going to \n                examine. \n        \\Expl}\n        heap <- False // 'heap' is a flag \\B 25\n        while not (IsLeaf(A[i]) or heap) do \\B 26\n        \\Expl{  Traverse down the heap until the current node A[i] is a leaf. \n                We also terminate the loop if the children of A[i] are in the \n                correct order relative to the parent, since we know that subtrees\n                lower down already meet the heap condition. We use the heap flag\n                to test the heap condition.  \n        \\Expl}\n        \\In{        \n            j <- IndexOfLargestChild(A, i, n)    \\Ref IndexOfLargest0 \n            \\Expl{  Find the larger of the two children of the node. \n            \\Expl}\n            if A[i] >= A[j]         // Parent is larger than the largest child \\B 32\n                                                                          \n            \\In{\n                heap <- True \\B 33\n                \\Expl{  The heap condition is satisfied, that is, the root is \n                        larger than both children, so we exit from the while loop.\n                \\Expl}\n            \\In}\n            else\n            \\In{\n                Swap(A[i], A[j])    // Swap root element with (larger) child \\B 35\n                i <- j \\B 36\n            \\In}\n        \\In}\n        \\Code}\n        \n        \\Note{  Same as IndexOfLargestk (could possible reuse that; it is duplicated \n                here because it might make linking with animation easier if each code \n                expansion is used from a single place).\n        \\Note}\n        \n        \\Code{\n        IndexOfLargest0\n        if 2*i < n and A[2*i] < A[2*i+1] \\B 28\n        \\Expl{  The left child of A[i] is A[2*i] and the right child (if there is\n                a right child) is A[2*i+1]; set j to the index of the larger child.\n        \\Expl}\n        \\In{\n            j <- 2*i+1 \\B 29\n        \\In}\n        else\n        \\In{\n            j <- 2*i \\B 31\n        \\In}\n        \\Code}    \n"),mo=ho('\n\\Note{ REAL specification of quicksort (simple version) for animation\n\nNOTE: Ultimately it would be nice to support different versions (eg,\nmedian of three partitioning, etc), in AIA. Ideally the list of algorithms\npresented by AIA should just include a single occurrence of quicksort.\nDifferent versions could be selected via a menu in the quicksort animation\n(or perhaps a sub-menu at the top level).  This version should be the\ndefault/first listed. Currently this version plus M3 are supported and\nare listed separately at the top level.\n\\Note}\n\n\\Code{\nMain\n// Sort array A[left]..A[right] in ascending order\nQuicksort(A, left, right) \\B 1\n\\Expl{  We need left and right indices because the code is recursive\n        and both may be different for recursive calls.\n\\Expl}\n    if (left < right) \\B 2\n    \\Expl{  Terminating condition (if there are less than two\n            elements in the array segment do nothing).\n    \\Expl}\n    \\In{\n        Choose pivot    \\Ref ChoosePivot \n        \\Expl{  There are various ways to choose the "pivot", which\n                is used to distinguish (relatively) small elements\n                and (relatively) large elements in the partitioning\n                process.\n        \\Expl}\n        Partition array segment    \\Ref Partition \n        \\Expl{  This is where most of the work of Quicksort gets done.\n                We start with an unordered array segment, and finish\n                with an array segment containing the pivot in its final\n                place, A[i], and two partitions, one containing only\n                elements smaller than or equal to the pivot, and the other\n                containing only elements larger than or equal to the pivot.\n                There are various ways this can be coded, often with\n                some subtle points.\n        \\Expl}\n        Sort FirstPart   \\Ref QuicksortFirst\n        \\Expl{  Sort elements left of (smaller or equal to) the pivot, which is in A[i].\n        \\Expl}\n        Sort SecondPart  \\Ref QuicksortSecond\n        \\Expl{  Sort elements right of (greater or equal to) the pivot, which is in A[i].\n        \\Expl}\n    \\In}\n    // Done \\B 19\n\\Code}\n\n\\Code{\nQuicksortFirst\n// *Recursively* sort first part: \\B 300\nQuicksort(A, left, i - 1) \\B 3\n\\Code}\n\n\\Code{\nQuicksortSecond\n// *Recursively* sort second part: \\B 400\nQuicksort(A, i + 1, right) \\B 4\n\\Code}\n\n\\Code{\nChoosePivot\npivot <- A[right] \\B 5\n\\Expl{  This simple method of choosing a pivot just uses the rightmost \n        element of the array segment. Unfortunately it leads to very poor \n        performance in some common cases, such as when the array is almost \n        sorted already.\n\\Expl}\n\\Code}\n\n\\Code{\nPartition\nSet index i at left the of array segment and j at the right    \\Ref init_iAndj \n\\Expl{  i scans from left to right stopping at "large" elements\n(greater than or equal to the pivot) and j scans from right to left\nstopping at "small" elements (less than or equal to the pivot).\n\\Expl}\nwhile i < j \\B 6\n\\Expl{  When the indices cross, all the large elements at the left of\n        the array segment have been swapped with small elements from the\n        right of the array segment. The coding here can be simplified \n        if we use "break" or similar to exit from this loop.\n\\Expl}\n\\In{\n    Repeatedly increment i until A[i] >= pivot \\B 7\n    \\Expl{  Stopping at elements equal to the pivot results in better\n            performance when there are many equal elements and because \n            the pivot is in A[right] this also acts as a sentinel, so \n            we don\'t increment beyond the right of the array segment.\n    \\Expl}\n    Repeatedly decrement j until A[j] <= pivot or j < i \\B 8\n    \\Expl{  Stopping at elements equal to the pivot results in better\n            performance when there are many equal elements. If the \n            indices cross we exit the outer loop; this also stops us \n            decrementing beyond the left of the array segment.\n    \\Expl}\n    if j > i \\B 9\n    \\Expl{  If the indices cross, we exit the loop.\n    \\Expl}\n    \\In{\n        swap(A[i], A[j]) \\B 10\n        \\Expl{  Swap the larger element (A[i]) with the smaller\n                element (A[j]).\n        \\Expl}\n    \\In}\n\\In}\n// Put the pivot in its final place\nswap(A[i], A[right]) \\B 13\n\\Expl{  The pivot element, in A[right], is swapped with A[i]. All\n        elements to the left of A[i] must be less than or equal to\n        the pivot and A[i] plus all elements to its right must be\n        greater than or equal to the pivot, thus the pivot is now in its\n        final position and is not considered further.\n\\Expl}\n\\Code}\n\n\\Code{\ninit_iAndj\ni <- left - 1 \\B 11\n\\Expl{  The i pointer scans left to right with a preincrement, so\nit is set to left - 1 (this may be off the left end of the array but\nwe never access that element).\n\\Expl}\nj <- right \\B 12\n\\Expl{  The j pointer scans right to left with a predecrement and\nis set to right so the pivot element, in A[right], is skipped in the\nscanning (it is swapped into its correct position at the end).\n\\Expl}\n\\Code}\n\n'),fo=ho('\n\\Code{\nMain\n// Sort array A[left]..A[right] in ascending order\nMergesort(A, left, right) \\B Main\n\\Expl{  We need left and right indices because the code is recursive\n        and both may be different for recursive calls.\n\\Expl}\n    if left < right \\B left<right\n    \\Expl{  Terminating condition (if there are less than two\n            elements in the array segment it\'s already sorted).\n    \\Expl}\n    \\In{\n        mid <- (left + right)/2 \\B mid\n        sort first half, A[left]..A[mid]    \\Ref MergesortL\n        \\Expl{ Sort elements in the first half of the array segment.\n        \\Expl}\n        \\Note{ This should be animated in one step if not expanded\n        \\Note}\n        sort second half, A[mid+1]..A[right]    \\Ref MergesortR\n        \\Expl{ Sort elements in the second half of the array segment.\n        \\Expl}\n        \\Note{ This should be animated in one step if not expanded\n        \\Note}\n        Merge the two sorted halves, with the result in A \\Ref MergeCopy\n    \\In}\n    // Done \\B Done\n    \\Note{ Good to have this as a step in animation to clarify recursion\n           (especially the base case), plus clean up stack display at end\n    \\Note}\n\n\n\\Code}\n\n\\Code{\nMergesortL\n    \\Note{ Recursive call should be animated if this is expanded, like\n      quicksort.  We add the comment below to pause the animation,\n      making recursion clearer, and the animation also needs an extra\n      "chunk" at the right recursion level if we hit the "back" button.\n    \\Note}\n    // *recursively* sort the first half \\B preSortL\n    Mergesort(A, left, mid) \\B sortL\n\\Code}\n\n\\Code{\nMergesortR\n    \\Note{ See MergesortL note\n    \\Note}\n    // *recursively* sort the second half \\B preSortR\n    Mergesort(A, mid + 1, right) \\B sortR\n\\Code}\n\n\\Code{\nMergeCopy\n    Merge(A, left, mid, right, B) \\Ref Merge\n    \\Expl{ Takes two sorted array segments, A[left..mid] and A[mid+1..right],\n        and merges them together to form a single sorted array segment\n        in temporary array B[left..right].\n        The animation shows values being deleted from A since they\n        are no longer needed (they are actually still there).\n    \\Expl}\n    Copy merged elements back to A \\B copyBA\n    \\Expl{ Copy elements from B[left..right] back to A[left..right].\n        Copying can be reduced by merging\n        from A to B and from B to A in alternate levels of recursion -\n        a slightly more tricky coding.\n        The animation shows values being deleted from B since they\n        are no longer needed (they are actually still there).\n    \\Expl}\n    \\Note{ Might be better to move above to overview.\n    \\Note}\n\\Code}\n\n\\Code{\nMerge\n    ap1 <- left \\B ap1\n    max1 <- mid \\B max1\n    \\Expl{ ap1 scans through the segment A[left..mid], "pointing at" or\n        indexing elements of this array segment we copy from.\n    \\Expl}\n    ap2 <- max1+1 \\B ap2\n    max2 <- right \\B max2\n    \\Expl{ ap2 scans through the segment A[mid+1..right], "pointing at" or\n        indexing elements of this array segment we copy from.\n    \\Expl}\n    bp <- ap1 \\B bp\n    \\Expl{ bp scans through the segment B[left..right], "pointing at" or\n        indexing elements of this array segment we copy to.\n    \\Expl}\n    while both A segments still have elements to copy \\Ref MergeWhile\n    \\Expl{ we scan through both A segments from left to right by \n        incrementing ap1 and ap2, copying to B as we go.\n        The animation shows values being deleted from A since they\n        are no longer needed (they are actually still there).\n    \\Expl}\n    \\In{\n        copy the smaller A element, increment its pointer and bp \\Ref CopySmaller\n        \\Expl{ The smaller of A[ap1] and A[ap2] is copied to B[bp].\n        \\Expl}\n    \\In}\n    copy any remaining elements from A to B \\Ref CopyRest\n    \\Expl{ One of the A segments will have been completely copied;\n        the other has uncopied elements.\n    \\Expl}\n\\Code}\n\n\\Code{\nMergeWhile\n    while ap1 <= max1 and ap2 <= max2 \\B MergeWhile\n    \\Expl{ Elements up to max1/max2 must be copied; those before\n        ap1/ap2 have been copied already.\n    \\Expl}\n\\Code}\n\n\\Code{\nCopySmaller\n    if A[ap1] < A[ap2] \\B findSmaller\n    \\In{\n        B[bp] <- A[ap1] \\B copyap1\n        \\Expl{ The animation shows the value being deleted from A[ap1] since it\n            is no longer needed (it is actually still there).\n        \\Expl}\n        ap1 <- ap1+1    \\B ap1++\n        bp <- bp+1      \\B bp++\n        \\Note{ Clearer to duplicate this in then and else branches(?)\n        \\Note}\n    \\In}\n    else\n    \\In{\n        B[bp] <- A[ap2] \\B copyap2\n        \\Expl{ The animation shows the value being deleted from A[ap2] since it\n            is no longer needed (it is actually still there).\n        \\Expl}\n        ap2 <- ap2+1    \\B ap2++\n        bp <- bp+1      \\B bp++_2\n    \\In}\n\\Code}\n\n\\Code{\nCopyRest\n    copy A[ap1..max1] to B[bp..] \\B CopyRest1\n    \\Note{ Need to expand this? I dont think so.\n    \\Note}\n    copy A[ap2..max2] to B[bp..] \\B CopyRest2\n    \\Expl{ One of these copy steps will do nothing because one of the\n        A segments will be empty. If ap2 is not shown in the animation\n        it is max2+1, off the end of the array.\n        The animation shows values being deleted from A since they\n        are no longer needed (they are actually still there).\n    \\Expl}\n\\Code}\n\n'),bo=ho('\n\\Note{ top down merge sort for lists.  Should be able to use identical\npsuedocode independently of list implementation.  Needs more bookmarks.\n\\Note}\n\\Code{\nMain\n// Sort list L of length len, in ascending order\nMergesort(L, len) \\B Main\n\\Expl{ We pass in len so we can find the middle of the list more\n    easily; it can be computed using a separate scan of the list at the top\n    level if unknown.\n\\Expl}\n    if len > 1 \\B len>1\n    \\Expl{  Terminating condition (if there are less than two\n            elements in the list it\'s already sorted).\n    \\Expl}\n    \\In{\n        split L at its mid point, giving lists L and R \\Ref split\n        sort L    \\Ref MergesortL\n        \\Note{ This should be animated in one step if not expanded\n        \\Note}\n        sort R    \\Ref MergesortR\n        \\Note{ This should be animated in one step if not expanded\n        \\Note}\n        M <- Merge of L and R \\Ref Merge\n        return M \\B returnM\n    \\In}\n    else\n    \\In{\n        return L // already sorted \\B returnL\n    \\In}\n\\Note{ Might want "Done" line+bookmark to clean up at end???\n\\Note}\n\\Code}\n\n\\Code{\nsplit\n    Mid <- mid point of L \\Ref scan\n    R <- tail(Mid)    // R starts after Mid\n    tail(Mid) <- Null // truncate L after Mid \\B tail(Mid)<-Null\n\\Code}\n\n\\Code{\nscan\n    Mid <- L \\B Mid\n    \\Expl{ Start at first element of L\n    \\Expl}\n    for i = 1 to len/2 - 1 // while not at middle\n    \\In{\n        Mid <- tail(Mid) \\B MidNext\n        \\Expl{ Skip to next element\n        \\Expl}\n    \\In}\n\\Code}\n\n\\Code{\nMergesortL\n    \\Note{ Recursive call should be animated if this is expanded, like\n      quicksort.  We add the comment below to pause the animation,\n      making recursion clearer, and the animation also needs an extra\n      "chunk" at the right recursion level if we hit the "back" button.\n    \\Note}\n    // *recursively* sort the first half \\B preSortL\n    L <- Mergesort(L, len/2) \\B sortL\n\\Code}\n\n\\Code{\nMergesortR\n    \\Note{ See MergesortL note\n    \\Note}\n    // *recursively* sort the second half \\B preSortR\n    R <- Mergesort(R, len - len/2) \\B sortR\n    \\Expl{ We don\'t use len/2 for the length due to truncation with\n      integer division.\n    \\Expl}\n\\Code}\n\n\\Code{\nMerge\n    Initialise M with minimum of L and R \\Ref initM\n    \\Expl{ Set M to the input list with the smallest first element and\n      skip over (delete) that element for that input list.\n    \\Expl}\n    E <- M // E is the end element of M \\B E\n    while L != Null && R != Null  \\B whileNotNull\n    \\Expl{ Scan through L and R, appending elements to M.  E is always the\n        end element of M, and L and R are the remaining inputs that have\n        not yet been appended.\n    \\Expl}\n    \\In{\n        append the smaller input element to M, advance pointers \\Ref CopySmaller\n        \\Expl{ The smaller of head(L) and head(R) is appended to M.\n        \\Expl}\n    \\In}\n    append any remaining elements onto M \\Ref CopyRest\n    \\Expl{ One of the input lists will have been completely appended;\n        the other will have remaining elements.\n    \\Expl}\n\\Code}\n\n\\Code{\ninitM\n    if head(L) < head(R)\n    \\In{\n        M <- L \\B M<-L\n        L <- tail(L) \\B L<-tail(L)\n        \\Expl{ M will contain the first element of L so we skip L to\n          its next element.\n        \\Expl}\n    \\In}\n    else\n    \\In{\n        M <- R \\B M<-R\n        R <- tail(R) \\B R<-tail(R)\n        \\Expl{ M will contain the first element of R so we skip R to\n          its next element.\n        \\Expl}\n    \\In}\n\\Code}\n\n\\Code{\nCopySmaller\n    if head(L) <= head(R) \\B findSmaller\n    \\In{\n        tail(E) <- L // append L element to M\n        E <- L       // E <- end element of M\n        L <- tail(L)     // skip element in L that has been appended \\B popL\n    \\In}\n    else\n    \\In{\n        tail(E) <- R // append R element to M\n        E <- R       // E <- end element of M\n        R <- tail(R)     // skip element in R that has been appended \\B popR\n    \\In}\n\\Code}\n\n\\Code{\nCopyRest\n    if L == Null\n    \\In{\n        tail(E) <- R // append extra R elements to M \\B appendR\n    \\In}\n    else\n    \\In{\n        tail(E) <- L // append extra L elements to M \\B appendL\n    \\In}\n\\Code}\n\n'),yo=ho('\n\\Code{\n  Main\n  Warshall(A, n) // Compute the transitive closure of a graph \\B 1\n  \\Expl{  Compute the transitive closure of a directed graph\n    with nodes 1..n, represented by n x n adjacency matrix A \n  \\Expl}\n  \\In{\n    for k <- 1 to n  \\B 2\n    \\Expl{  Consider all possible nodes k that might be\n      used as stepping stones on the way from i to j.\n    \\Expl}  \n    \\In{\n      for i <- 1 to n   \\B 3\n      \\Expl{ Explore and try to add new paths from each source node i.\n      \\Expl} \n      \\In{\n        if A[i,k]  \\B 4\n        \\Expl{ When A[i,k] is 0 (that is, there is no path from i to k), k\n          cannot possibly be a stepping stone in the path from i to j,\n          so we do not explore whether there is a path from k to j.\n        \\Expl}  \n        // Consider all paths from i to j, either already reachable (using \n        // nodes 1 to k-1 as intermediates), or now reachable using k as an \n        // intermediate.   \n        Find all nodes reachable from i via k \\Ref Reachable\n        \\Expl{  Identify target nodes j that are reachable from \n        source node i, whether they were already reachable \n        before now, or whether they are now reachable using \n        node k as a stepping stone.\n        \\Expl}\n      \\In}\n    \\In}\n  \\In}\n  \\In{\n  return A  \\B 8\n  \\In}\n\\Code}\n\n\\Code{\n  Reachable\n  \\In{\n  for j <- 1 to n   \\B 5\n  \\Expl{ Consider paths to all possible target nodes j.\n  The effect of this innermost loop is to update row i\n  to become its binary "or" with row k.\n  \\Expl} \n  \\In{\n    if A[k,j]   \\B 6\n    \\Expl{  Check if there is a path from this intermediate \n    node k to target node j.\n    \\Expl} \n    \\In{\n      A[i,j] <- 1     \\B 7\n      \\Expl{  Record the new path from i to j (through k) in the \n      reachability matrix by setting A[i,j] to 1 (if there\n      was already a path from i to j in the reachability\n      matrix, then it remains there, whether or not that\n      path goes through k.\n      \\Expl} \n    \\In}\n  \\In}\n  \\In}\n\\Code}\n'),Ao=ho("\n\\Note{  REAL specification of Prim's algorithm\n\\Note}\n\n\\Code{\nMain\nPrim(E, n, s) // Given a weighted connected graph G with nodes 1..n \\B 1\n\\In{\n\\In{\n           // and edges E, start at node s to find a minimum spanning tree for G.\n\\In}\n\\In}\n\\In{\n    PQ <- InitPriorityQueue(n, s) \\Ref InitPQ\n    \\Expl{  Nodes are put in a priority queue PQ according to their\n            Cost. Smaller cost means higher priority and initially \n            all nodes have the highest possible cost, except the start\n            node s, which has cost zero (we start building the tree from\n            s and it costs nothing to get from s to s).\n    \\Expl}\n\n    while PQ not Empty \\B 3\n    \\In{\n        i <- RemoveMin(PQ)  // i is now part of the spanning tree \\B 4\n        \\Expl{  Node i is closest to the tree constructed so far.\n                More precisely, for every node k inside the current \n                tree, and every node j outside of it, the weight of\n                (k,i) is smaller than (or possibly equal to) the weight\n                of (k,j) for all outside nodes j. So i is picked as \n                the next node to add to the tree. The array Parent keeps\n                track of the connections: Parent[i] is the spanning tree\n                node that i is connected to. Note that, unless i = 1, \n                Parent[i] has already been determined.\n        \\Expl}\n        update priority queue PQ    \\Ref Update\n        \\Expl{  Adding node i to the tree may reduce the costs of nodes\n                neighbouring i, affecting PQ. The node with minumum cost \n                may also change.\n        \\Expl}\n    \\In}\n\\In}\n\\Code}\n\n\\Code{\nInitPQ\n        for i <- 1 to n    \\B 2                                           \n        \\In{\n            Cost[i] <- Infinity                                     \n            \\Expl{  The Cost of each node is initially set to Infinity to\n                    indicate we do not (yet) know how node i can be added\n                    to the spanning tree\n            \\Expl}\n            Parent[i] <- Null\n            \\Expl{  The array Parent will be used to track how nodes are \n                    connected into the resulting spanning tree. Node s\n                    will be the root of the spanning tree and an edge (j,i)\n                    is added to the tree by setting Parent[i] to j.\n                    Eventually all nodes have a (non-Null) Parent,\n                    thus all nodes are in the spanning tree.\n            \\Expl}\n        \\In}\n        Cost[s] <- 0\n        Parent[s] <- s // the parent of the tree root s points to itself\n\\Code}\n\n\\Code{\nUpdate\n        for each (i,j) in E \\B 5\n        \\Expl{  Now that i gets included in the tree, we need to check the edge \n                to each of its neighbours j.\n        \\Expl}\n        \\In{\n        if j is in PQ and weight(i,j) < Cost[j] \\B 6\n        \\Expl{  The inclusion of i may have brought i's neighbour j closer \n            to the tree; if so, update the information we have about j.\n        \\Expl}\n        \\In{\n                Cost[j] <- weight(i,j) \\B 7                                 \n                \\Expl{  The new cost for j is its distance to i.\n                \\Expl}\n                Update(PQ, j, Cost[j]) \\B 8\n                \\Expl{  Rearrange PQ so the priority queue reflects j's new cost.\n                \\Expl}\n                Parent[j] <- i \\B 9                                          \n                \\Expl{  Record the fact that j's closest neighbour in the \n                        spanning tree (so far) was i.\n                \\Expl}\n        \\In}\n\\Code}\n"),xo=ho('\n\\Code{\nMain\nPrim(G, s) // Find a minimum spanning tree for graph G starting at node s \\B 1\n    \\Expl{ Given a weighted graph G, return a minimum spanning tree\n        for the graph component that includes s (with a different termination\n        condition a minimum spanning forest for all graph components could\n        be found). Nodes are numbered 1..nmax. Prim returns the Parent\n        array, which gives a path from each connected node back to\n        the root s (which has 0 as the parent).\n    \\Expl}\n        \\In{\n                initialise, with fontier={s}, stored in Nodes \\Ref Init\n                while Nodes is not empty \\B 2\n           \\Expl{ Nodes is the data structure used to represent the frontier.\n                For Prim\'s algorithm, Nodes is a priority queue, ordered on\n                Cost (the minumum edge weight found so far). Here we highlight the Min\n                value. The priority queue also contains nodes that have not been\n                seen, which have infinite Cost. The frontier nodes are those\n                shown with a finite Cost. Nodes with no Cost shown\n                have been finalised. The frontier and finalised nodes are also\n                highlighted in the graph display.\n            \\Expl}\n                \\In{\n                    remove next node n from Nodes and finalise it \\Ref Next_node\n                    // The Parent of n has now been determined\n                    if task_completed(n) \\Ref Completed\n                    \\Expl{ If we want a MST for just one component we may be able to\n                            finish here, otherwise we can skip this "if".\n                    \\Expl} \n                    \\In{\n                        return \\B 3\n                        \\Expl{ The Parent array has a MST for the component containing s.\n                           We reset the Nodes PQ etc to show the component more clearly.\n                        \\Expl} \n                    \\In} \n                    for each node m neighbouring n // G has edge from n to m \\B 4\n                    \\In{\n                        update Nodes, Parent etc with n & m \\Ref UpdateNodes\n                    \\In}\n                \\In}\n                return \\B 99\n                \\Expl{ A minimal spanning forest for the whole graph has been found.\n                \\Expl}\n            \\In}\n            \n\\Code}\n\n\\Code{\n        Init\n            initialise each element of array Parent to zero \\B 5\n            initialise each element of array Cost to infinity \\B 6\n            Cost[s] <- 0 \\B 7\n            Nodes <- PQ containing all nodes  // only s has finite cost \\B 8\n            //  Nodes in the PQ with finite cost are in the frontier; others are yet to be seen. \n\\Code}  \n\n\\Code{\n        Next_node\n            n <- PQRemoveMin(Nodes) // remove lowest cost element of Nodes PQ \\B 9\n            \\Expl{ n is the node in the frontier closest to a finalised\n                    node (if it has infinite cost it must be in a component not\n                    connected to s; not actually in the frontier).\n            \\Expl}\n        \\Code}\n        \n\n\\Code{\n        Completed\n            if Cost[n] = infinity \\B 10\n            \\Expl{ The MST of the component containing s has been found!\n                 If we just want a minimal spanning forest the whole graph\n                 we can skip this "if" and continue until Nodes is empty.\n            \\Expl}\n\\Code}\n\n\\Code{\n        UpdateNodes\n            if m is in Nodes PQ and weight(n,m) < Cost[m] \\B 11\n            \\Expl{ Adding n to the MST may have brought n\'s neighbour m closer\n                 to the tree. If so, update the information we have about m.\n                 If Cost[m] = infinity it will be replaced with a finite weight,\n                 implicitly moving m from the unseen nodes to the frontier.\n            \\Expl} \n            \\In{\n                Cost[m] <- weight(n,m) // new cost is distance from n \\B 12\n                PQUpdateCost(Nodes, m, Cost[m]) // update cost in Nodes PQ \\B 13\n                Parent[m] <- n \\B 14\n                \\Expl{ m\'s closest neighbour in the MST (so far) is n.\n                \\Expl}\n            \\In}\n\\Code}\n'),vo=ho("\n\\Code{\nMain\nKruskal(G)  // Compute minimum spanning tree for graph G \\B Kruskal(G)\n    \\Expl{ Given a weighted graph G, return Selected, a set of edges.\n        If G is connected, Selected represents a minimal spanning tree\n        (there may be more than one tree with minimal weight).\n        In general it represents a minimal spanning forest (one MST for\n        each connected component of the graph).\n    \\Expl}\n\\In{\n    Initialise Edges, Selected (and Cost) and NodeSets \\Ref Init\n    while Edges is not empty and size(Selected) < size(G) - 1 \\B while\n    \\Expl{ size(G) is the number of nodes in G.\n        A tree with n nodes has n-1 edges, so if there are size(G)-1\n        selected edges, all nodes are in the same tree. It's not necessary\n        to perform this check but it can be made easy and can save time\n        for connected graphs with many edges.\n    \\Expl}\n    \\In{\n        (n1, n2) <- RemoveMin(Edges) // remove edge n1-n2 with minimum weight \\B RemoveMin\n        \\Expl{ The graph display highlights node n1 and all nodes\n            connected to it by selected edges in one colour.\n            If n1 and n2 are not already connected by selected edges the\n            same is done with n2, with a different colour.\n        \\Expl}\n        \\Note{highlight edge + trees for n1, n2?\n        \\Note}\n        if n1 and n2 are in different trees \\Ref DifferentTrees\n        \\In{\n            Add e to Selected \\B addSelected\n            \\Expl{ The counter used to keep track of size(Selected)\n                can be incremented here.\n            \\Expl}\n            union(NodeSets, n1, n2) // update NodeSets, combining n1&n2 \\B union\n            \\Expl{ This is a union-find operation that takes the union\n                of the sets containing n1 and n2, respectively, since\n                they are now connected by a selected edge.\n            \\Expl}\n        \\In}\n    \\In}\n    return Selected \\B return\n    \\Note{display total cost\n    \\Note}\n\\In}\n\\Code}\n\n\\Code{\nInit\n    Edges <- all edges in G // may involve sorting the edges \\B initEdges\n    \\Expl{ We display Edges as a list, sorted on weight. Other data\n        structures could be used but at each stage the edge with the\n        next lowest weight is removed and this should be efficient.\n        There may be (far) more edges than nodes; here we omit listing the\n        edges with higher weights if there are too many.\n    \\Expl}\n    Selected <- empty set of edges (Costs also shown) \\B SelectedEmpty\n    \\Expl{ The number of selected edges is always less than the number\n        of nodes so the display can list all of them. We also display\n        the cost (weight) of each selected edge.\n        Explicitly keeping track of the number of selected edges is\n        also beneficial, eg, with a simple counter initialised to zero\n        here. It is not necessary but allows us to exit\n        from the while loop significantly earlier in some cases.\n    \\Expl}\n    NodeSets <- set of singleton sets with each node in G \\B initNodeSets\n    \\Expl{ NodeSets is a set of sets of nodes that are connected by\n        selected edges (like a forest but without information about\n        which edges are used to connect the nodes of each tree).\n        Initially there are no selected edges so we have singleton sets.\n    \\Expl}\n\\Code}\n\n\\Code{\nDifferentTrees\n    \\Note{highlight find(n1), find(n2)?\n    \\Note}\n    if find(NodeSets, n1) != find(NodeSets, n2) \\B DifferentTrees\n    \\Expl{ Find is a union-find operation that returns a representative\n        element of a set containing a given element. If the elements\n        returned for n1 and n2 are not equal, it means they are not\n        in the same set, so they are not connected by selected edges.\n    \\Expl}\n\\Code}\n\n\n"),jo=ho('\n\\Note{ REAL specification of quicksort (median of 3 version) for animation\n\n\\Note}\n    \n\\Code{\nMain\n// Sort array A[left]..A[right] in ascending order\nQuicksort(A, left, right) \\B 1\n\\Expl{  We need left and right indices because the code is recursive\n        and both may be different for recursive calls.\n\\Expl}\n    if (left < right) \\B 2\n    \\Expl{  Terminating condition (if there are less than two\n            elements in the array segment do nothing).\n    \\Expl}\n    \\In{\n        Choose pivot    \\Ref ChoosePivot \n        \\Expl{  There are various ways to choose the "pivot", which is\n                used to distinguish (relatively) small elements and\n                (relatively) large elements in the partitioning process.\n        \\Expl}\n        Partition array segment    \\Ref Partition \n        \\Expl{  This is where most of the work of Quicksort gets done.\n                We start with an unordered array segment, and finish\n                with an array segment containing the pivot in its final\n                place, A[i], and two partitions, one containing only\n                elements smaller than or equal to the pivot, and the other\n                containing only elements larger than or equal to the pivot.\n                There are various ways this can be coded, often with\n                some subtle points.\n        \\Expl}\n        Sort FirstPart   \\Ref QuicksortFirst\n        \\Expl{  Sort elements left of (smaller or equal to) the pivot, which is in A[i].\n        \\Expl}\n        Sort SecondPart  \\Ref QuicksortSecond\n        \\Expl{  Sort elements right of (greater or equal to) the pivot, which is in A[i].\n        \\Expl}\n    \\In}\n    // Done \\B 19\n\\Code}\n\n\\Code{\nQuicksortFirst\n// *Recursively* sort first part: \\B 300\nQuicksort(A, left, i - 1) \\B 3\n\\Code}\n\n\\Code{\nQuicksortSecond\n// *Recursively* sort second part: \\B 400\nQuicksort(A, i + 1, right) \\B 4\n\\Code}\n\n\\Code{\nChoosePivot\nPut the left, right and middle elements in increasing order    \\Ref SortLMR\n\\Expl{  This method of choosing a pivot uses the median of the left,\n        right and middle elements of the array segment. Sorting the left,\n        middle and and right elements ensures the median is in the middle\n        plus A[left] and A[right] are in their correct partitions, so \n        they can be skipped in the rest of the partitioning.\n\\Expl}\nSwap(A[mid], A[right - 1]) // put median in A[right-1] \\B 18\n\npivot <- A[right - 1] \\B 5\n\\Expl{  Using the median of the left, right and middle elements for the\n        pivot leads to very good performance for sorted and reverse sorted\n        inputs, and the theoretical worse case is rarely encountered.\n\\Expl}\n\\Code}\n    \n\\Code{\nSortLMR\nmid <- (left + right) / 2 // index of middle element \\B 14\nif A[left] > A[mid] \\B 20\n\\In{\n    Swap(A[left], A[mid]) \\B 15\n\\In}\nif A[mid] > A[right] \\B 21\n\\In{\n    Swap(A[right], A[mid]) \\B 16\n    if A[left] > A[mid] \\B 22\n    \\In{\n        Swap(A[left], A[mid]) \\B 17\n    \\In}\n    // now A[left] <= A[mid] <= A[right]\n\\In}\n\\Code}\n    \n\\Code{\nPartition\nSet index i at left the of array segment and j at the right    \\Ref init_iAndj \n\\Expl{  i scans from left to right stopping at "large" elements\n(greater than or equal to the pivot) and j scans from right to left\nstopping at "small" elements (less than or equal to the pivot).\n\\Expl}\nwhile i < j \\B 6\n\\Expl{  When the indices cross, all the large elements at the left of\n        the array segment have been swapped with small elements from the\n        right of the array segment. The coding here can be simplified \n        if we use "break" or similar to exit from this loop.\n\\Expl}\n\\In{\n    Repeatedly increment i until A[i] >= pivot \\B 7\n    \\Expl{  Stopping at elements equal to the pivot results in better\n            performance when there are many equal elements and because\n            the pivot is in A[right] this also acts as a sentinel so we \n            don\'t increment beyond the right of the array segment.\n    \\Expl}\n    Repeatedly decrement j until A[j] <= pivot or j < i \\B 8\n    \\Expl{  Stopping at elements equal to the pivot results in better\n            performance when there are many equal elements. If the \n            indices cross we exit the outer loop; this also stops us \n            decrementing beyond the left of the array segment.\n    \\Expl}\n    if j > i \\B 9\n    \\Expl{  If the indices cross, we exit the loop.\n    \\Expl}\n    \\In{\n        swap(A[i], A[j]) \\B 10\n        \\Expl{  Swap the larger element (A[i]) with the smaller\n                element (A[j]).\n        \\Expl}\n    \\In}\n\\In}\n// Put the pivot in its final place\nswap(A[i], A[right - 1]) \\B 13\n\\Expl{  The pivot element, in A[right-1], is swapped with A[i]. All\n        elements to the left of A[i] must be less then or equal to\n        the pivot and A[i] plus all elements to its right must be\n        greater than or equal to the pivotC thus the pivot is now in its\n        final position and is not considered further.\n\\Expl}\n\\Code}\n    \n\\Code{\ninit_iAndj\ni <- left \\B 11\n\\Expl{  The i pointer scans left to right with a preincrement and\nis set to left (A[left] is known to be less than or equal to the\npivot).\n\\Expl}\nj <- right - 1 \\B 12\n\\Expl{  The j pointer scans right to left with a predecrement and\nis set to right-1. A[right] is known to be greater than or equal to the\npivot and the pivot, in A[right-1], is skipped in the\nscanning it is swapped into its correct position at the end).\n\\Expl}\n\\Code}\n    \n'),wo=ho("\n\\Note{  REAL specification of brute-force string search\n    \\Note}\n    \\Code{\n    Main\n    BruteForceStringSearch(T, n, P, m)  \\B 1\n      // Look for pattern P (of length m) in text T (of length n).\n      // If found, return the index of P's first occurrence in T.\n      // Otherwise return -1.\n    \\Expl{  The pattern is P[0]..P[m-1] and the text is T[0]..T[n-1]. \n    \\Expl}\n    \\In{\n        i <- 0 \n        while i+m <= n \n        \\Expl{  If i plus the length of the pattern exceeds \n                the length of the text, no match is possible.\n        \\Expl}\n        \\In{\n                Look for a match starting from T[i]   \\Ref LookForMatch\n                i <- i+1 \\B 2\n                \\Expl{  We got here if there was no match starting at T[i],\n                        so we try starting from the next position, i+1, in T.\n                \\Expl}\n        \\In}\n        return (-1)  \\B 6\n        \\Expl{  We use -1 to indicate that there was no match.\n        \\Expl}\n    \\In}\n    \\Code}\n    \\Code{\n    LookForMatch\n    j <- 0 \n    while j < m and P[j] = T[i+j] \\B 3\n    \\Expl{  We keep progressing the search as long as we have not \n            exhausted the pattern (that is, j<m) and the pattern \n            checked so far matches the string starting from T[i].\n    \\Expl}\n    \\In{\n            j <- j+1 \\B 4\n    \\In}\n    if j = m \n    \\Expl{  If we have reached the end of the pattern, that means\n            we have matched T[i]..T[i+m-1].\n    \\Expl}\n    \\In{\n            return i \\B 5\n    \\In}\n    \\Code}\n    \\Note{  The following is an implementation in C:\n    #include<stdio.h>\n    #include<stdlib.h>\n    #include<string.h>\n    int\n    brute_force_string_search(char T[], int n, char P[], int m) {\n        int i, j;\n        i = 0;\n        while (i+m <= n) { // If i+m > n, no match is possible\n            j = 0;\n            while (j < m && P[j] == T[i+j]) // Until exhaustion or mismatch,\n                j = j+1;                    //   continue the matching\n            if (j == m)   // If we reached the end of the pattern\n                return i; //   we had a match T[i]..T[i+m-1]\n            i = i+1;\n        }\n        return (-1);  \n    }\n    int\n    main() {\n        int i, n, m;\n        char Text[TEXT_SIZE + 1];\n        char Pattern[PATTERN_SIZE + 1];\n        printf(\"String to search in:\n\");\n        fgets(Text, TEXT_SIZE, stdin);\n        printf(\"String to search for:\n\");\n        fgets(Pattern, PATTERN_SIZE, stdin);\n        n = strlen(Text);\n        m = strlen(Pattern);\n        if (Text[n-1] == '\n') {\n            n = n-1;\n            Text[n] = '\0';\n        }\n        if (Pattern[m-1] == '\n') {\n            m = m-1;\n            Pattern[m] = '\0';\n        }\n        i = brute_force_string_search(Text, n, Pattern, m);\n        if (i == -1)\n            printf(\"No match\n\");\n        else\n            printf(\"Match from position %d\n\", i);\n    }\n    \\Note}\n"),Eo=ho("\n\\Note{  REAL specification of Horspool's algorithm\nDraft Harald 15 Aug 2021\nEdited Linda 31 Aug 2021\nLinda added AlphabetSize explanation 1 Sept 2021\n\\Note}\n\n\\Note{  Provide a visualisation in which a \"shift table\" is first\n        constructed, and then the search is shown as the pattern P\n        being slid across the text T.\n\\Note}\n\n\\Overview{\n    Horspool's algorithm uses a preprocessing of the pattern P to limit\n    the number of partial matches attempted, compared to the brute-force\n    method. As with the brute-force method, we can think of P as \n    \"sliding along\" the text T. Horspool's method, however, matches the\n    pattern P from right to left. Its preprocessing generates a Shift\n    Table which gives, for each character, the number of places to shift\n    the pattern along, in case of a failed partial match. The shift table has a value\n    for every character in the alphabet, including characters that are not in pattern P, \n   but could be in text T. The alphabet contains all characters that might possibly be in the \n   text and pattern.  In this visualization, the alphabet contains all letters in the \n   Roman alphabet (A-Z) plus the Space character.  Alphabets might be smaller, e.g. for DNA \n   sequences the alphabet would be the four bases, or they might be larger, e.g. the characters\n   found in English literature, which would include both upper and lower case letters, space,\n   punctuation, numbers, etc.\n\n     As an example of how the Shift Table is used:\n    if the pattern is \"wally\" and matching fails (immediately) because the\n    'y' gets compared against an 'x' in the text, a character not found in the pattern,\n    the pattern can be slid 5 characters forward because there is not chance of a match.  So the value for \n   character 'x' in the shift table is 5.\n\t \n    If the failure was due to comparing 'y' against an 'a', a character\n    that does appear in the pattern, the pattern can be slid \n    forward by 3 characters, to where the 'a' in the text is aligned with the last 'a' in the pattern. At this point \n    we need to start another attempted match from the rightmost end of the pattern. Where a\n    character appears repeatedly in the pattern, as 'l' does in the \"wally\"\n    example, it is the last occurrence that counts, so in this example\n    the shift therefore will be 1, not 2.\t \n\\Overview}\n\n\\Code{\nMain\nHorspool(T, n, P, m)  \\B 1\n  // Look for pattern P (of length m) in text T (of length n).\n  // If found, return the index of P's first occurrence in T.\n\\Expl{  The pattern is P[1]..P[m] and the text is T[1]..T[n].\n\\Expl}\n\\In{\n    CreateShiftTable          \t\t\t\t \\Ref CreateShiftTable\n    Search \t\t                              \\Ref Search\n\\In}\n\\Code}\n\n\\Code{\nCreateShiftTable\nInitialize ShiftTable   \\Ref InitializeShiftTable\n\n//Put in values for characters in pattern P\nfor j <- 1 to m-1  \\B 4\n\\In{\n    Shift[P[j]] <- m - j  \\B 5\n    \\Expl{ For characters that are in pattern P, overwrite the default shift to something smaller.\n    \\Expl}\t \t\n\\In}\n\\Code}\n\n\\Code{\nSearch\ni <- m  \\B 6\nwhile i <= n  \\B 11\n\\Expl{ Until matching has gone beyond the length n of text T, start another attempted match. \n\\Expl}\n\\In{\n    j <- 0  \\B 13\n    while j < m and P[m-j] = T[i-j] \\B 8\n    \\Expl{ These characters match.\n    \\Expl} \t\t\n    \\In{\n        j <= j + 1 \\B 9\n    \\In}\n    \\Expl{  So move back one character and keep trying to match.\n    \\Expl} \n    if j = m  \\B 14\n    \\In{\n        // we have a match\n        return i - m + 1  // start of the match \\B 10\n    \\In}\n    else  \\B 15\n    \\In{\n    i <- i + Shift[T[i]] \\B 7\n    \\Expl{  Advance the pattern, consulting the shift table to see how\n            far, given the attempted match starting with T[i] failed.\n    \\Expl}\n    \\In}\n\\In}  \nreturn NOT FOUND  // Signal that there was no match   \\B 12\n\\Code}\n\\Code{\nInitializeShiftTable\nfor k <- 1 to AlphabetSize \\B 2\n\\Expl{  The Alphabet contains all characters from which the\ntext or pattern may be drawn, and AlphabetSize is the\nnumber of characters in the Alphabet.  \n\\Expl}        \n\\In{\n    Shift[k] <- m  \\B 3\n    \\Expl{  Set the default shift to be length m of pattern P.  That is, whenever\n     the current character in the text is not in the pattern at all, we do not have\n     to try any more possible matches that contain this character, so we make a large skip. \n    \\Expl}\n\\In}\n\\Code}\n\\Note{  The following is an implementation in C:\n\n// Horspool's string matching algorithm\n\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n\n#define ALPHABET_SIZE 128\n#define TEXT_SIZE 41    // Allow for strings with up to 40 characters\n#define PATTERN_SIZE 21 // Allow for search strings with up to 20 characters\n\nint horspool_string_search(char T[], int n, char P[], int m);\nvoid findshifts(char P[], int m);\n\nchar Shift[ALPHABET_SIZE];\n\nint\nmain() {\n    int i, n, m;\n    char Text[TEXT_SIZE + 2];\n    char Pattern[PATTERN_SIZE + 2];\n\n    printf(\"String to search in:\\n\");\n    fgets(Text+1, TEXT_SIZE, stdin);        // Leave Text[0] unused\n    Text[0] = '\\0';\n\n    printf(\"String to search for:\\n\");\n    fgets(Pattern+1, PATTERN_SIZE, stdin);  // Leave Pattern[0] unused\n    Pattern[0] = '\\0';\n\n    n = strlen(Text+1);\n    m = strlen(Pattern+1);\n\n    // Remove a possible terminating newline character from Text\n    if (Text[n] == '\\n') {\n        Text[n] = '\\0';\n        n = n-1;\n    }\n\n    // Remove a possible terminating newline character from Pattern\n    if (Pattern[m] == '\\n') {\n        Pattern[m] = '\\0';\n        m = m-1;\n    }\n\n    i = horspool_string_search(Text, n, Pattern, m);\n    if (i == -1)\n        printf(\"No match\\n\");\n    else\n        printf(\"Match from position %d\\n\", i);\n}\n\nint\nhorspool_string_search(char T[], int n, char P[], int m) {\n    // Assume the strings of interest are T[1]..T[n] and P[1]..P[m]\n    int i, j;\n\n    findshifts(P, m);\n    i = m;\n    while (i <= n) {          // If i > n, no match is possible\n        j = 0;\n        while (j < m && P[m-j] == T[i-j]) // Until possible mismatch,\n            j = j+1;                      //   continue the matching\n        if (j == m)           // If we reached the end of the pattern\n            return i-m+1;     //   then we had a match T[i-m+1]..T[i]\n        i = i + Shift[(int) T[i]];\n    }\n    return (-1);              // There was no match\n}\n\nvoid\nfindshifts(char P[], int m) {\n    // Assume the pattern of interest is P[1]..P[m]\n    int j, k;\n    for (k = 0; k < ALPHABET_SIZE; k++)\n        Shift[k] = m;           // m is the default shift\n    for (j = 1; j < m; j++)\n        Shift[(int) P[j]] = m-j;\n    return;\n}\n\n\\Note}\n"),ko=ho('\n\\Note{  REAL specification Union Find\n\\Note}\n\n\\Note{\nCurrent version uses Union by rank and path halving for Find due to\nsimple coding + its easy to separate path compression\n\nPlan is to provide button to disable path compression so\nstudents can explore what can happen without it.\n\nTentative idea for visualisation is to have array view, with rows for\nn, parent[n] and rank[n] (rank[n] can be blank for non-roots) plus\nforest view.  The forest could have fixed width columns with one number\nper column (plus rank for root nodes?). Union operation could shuffle\nrightmost tree to the left until its next to the tree to be merged with,\nthen one tree could be moved downwards one row and new edge added.\nRank information could be elided for some levels of abstraction.\n\\Note}\n\n\\Overview{\n\nUnion Find algorithms allow us to maintain and manipulate the partitioning\nof a set into (disjoint) subsets. There are two main operations supported:\nUnion and Find. Union takes two subsets and merges them together to form\na single subset.  Find takes and element and returns a representative\nelement of the subset it occurs in. It must be the case that Find(n) =\nFind(m) if and only if n and m are in the same subset, but which element\nis returned is left to the implementation (this flexibility allows for\nsimple, efficient solutions). There may also be an operation to add\nan additional element in a singleton subset; here we simply initialise\nthe data structure with a fixed number of elements, each in a singleton\nsubset. It is often convenient to number the elements 1, 2, 3,... allowing\nthe array-based solution we present here.\n\nUnion-Find has many and varied applications.  For example, to determine\nconnected components of an undirected graph, we can simply call Union(a,b)\nfor each edge a-b in the graph, then any two nodes in the same connected\ncomponent will have have the same result returned by Find.  Kruskal\'s\nalgorithm for finding minimum spanning trees is similar.\n\nTo represent a partitioning with N subsets we use N trees, each containing\nthe elements of the subset. Each tree node has a "parent" pointer and a\nnode can have many children pointing to it (there are no pointers from\nparents to children).  The root node points to itself (a bit of a trick\nthat makes code simpler).  Find returns the root node and Union joins two\ntrees together.  There are some subtle aspects to ensure the height of\nthe trees is kept small, so that finding the root can be done very quickly.\nExtra information is maintained for each subset so Union can reduce the\nheight and when Find traverses a path from a node to the root, we take\nthe opportunity to reduce the length of the path for future calls to Find\n(the tree height is reduced and the "width" is increased by having more\nchildren for some nodes).\n\nInterestingly, the extra information used to reduce the height is only\napproximate and the method used to reduce path lengths is not as thorough\nas some obvious alternatives. These shortcuts make the code quite short,\nbut it is still extremely effective at reducing the tree height - most\nnodes point directly to the root. It has been shown that no matter how\nlarge the set is, Find has takes very close to constant time on average\n(the inverse of the Ackerman function to be precise).  In this animation\nwe allow path compression to be disabled so you can experiment to see\nhow much this aspect of the algorithm reduces tree height.\n\n\\Overview}\n\n\\Note{n changed to k in pseudocode to reduce confusion but bookmarks\nstill use n\n\\Note}\n\\Code{\nShorten_path\n    parent[k] <- parent[parent[k]] (if enabled) // point to grandparent, not parent \\B parent[n] <- parent[parent[n]]\n    \\Expl{ By replacing the parent pointer by a pointer to the\n        grandparent at each step up the tree, the path length is\n        halved. This turns out to be sufficient to keep paths very\n        short. Note that the root node is its own parent.\n        The animation allows this path compression to be disabled so\n        you can compare the relative heights of the trees produced.\n    \\Expl} \n\\Code} \n\n\\Code{\nMain\nUnion(n, m) // merge/union the subsets containing n and m, respectively \\B Union(n, m)\n\\In{\n    n <- Find(n) \\B n <- Find(n)\n    m <- Find(m) \\B m <- Find(m)\n    if n == m // in same subset already - nothing to do \\B if n == m\n        \\In{\n        return \\B return\n        \\In}\n    swap n and m if needed to ensure m is the "taller" subtree \\Ref Maybe_swap\n    parent[n] = m // add the shorter subtree (n) to the taller one (m) \\B parent[n] = m\n    \\Expl{ This sometimes increases the height of the resulting tree but\n            if we added the taller to the shorter the height would always\n            increase.\n    \\Expl} \n    adjust the "height" measure of the taller subtree (m) \\Ref Adjust_rank\n    \\Expl{ The shorter subtree remains the same but the taller one\n            may have grown because it had had an extra subtree added.\n    \\Expl} \n\\In} \n\n//=======================================================\n\\Note{n changed to k in pseudocode to reduce confusion but bookmarks\nstill use n\n\\Note}\nFind(k) // return the root of tree containing k \\Ref Find(n)\n\\Code}\n\n\\Code{\nMaybe_swap\n    if rank[n] > rank[m] \\B if rank[n] > rank[m]\n        \\Expl{ We maintain a "rank" for each subset, which is an upper\n                bound on the height. The actual height may be less due\n                to paths being shortened in Find.\n        \\Expl} \n        \\In{\n        swap(n, m) \\B swap(n, m)\n        \\In}\n\\Code}\n\n\\Note{n changed to k in pseudocode to reduce confusion but bookmarks\nstill use n\n\\Note}\n\\Code{\n    Find(n)\n    \\In{\n        while k != parent[k]  // while we are not at the root \\B while n != parent[n]\n        \\In{\n            shorten path from k to root \\Ref Shorten_path\n            \\Expl{ There are several ways of shortening the path back to the\n                    root. The most obvious is to follow the path to the root\n                    then follow it again, making each element point to the\n                    root. The version here doesn\'t shorten the path as much\n                    but is simpler and overall it works e xtremely well.\n                    The animation allows path compression to be disabled so\n                    you can compare the relative heights of the trees produced.\n            \\Expl} \n            k <- parent[k]  // go up the tree one step \\B n <- parent[n]\n        \\In}\n        return k // return root \\B return n\n    \\In} \n    \\Code}\n\n\\Code{\n    Adjust_rank\n        if rank[n] == rank[m] \\B if rank[n] == rank[m]\n            \\Expl{  If we are adding a strictly shorter subtree to m the height\n                    doesn\'t change, but if the heights were equal the new height\n            \\Expl}\n            \\In{\n                rank[m] <- rank[m] + 1 \\B rank[m] <- rank[m] + 1\n                \\In}\n            \\Note{ Should we use ++ or "increment"???\n            \\Note}\n    \\Code}\n\n\\Code{\nInitialise\n    \\Note{ No need to animate this?? We just have this as the initial\n        state of the animation.\n    \\Note}\n      parent[i] = i and rank[i] = 0 for all elements i in the set \\B parent[i] = i and rank[i] = 0 for all elements i in the set\n    \\Expl{ Initially, each element i is in its own singleton subset. If\n            the array has free space, extra elements can be added and\n            initialised in the same way.\n    \\Expl} \n\\Code}\n\n\\Note{\n// Union Find: simple implementation for testing animation specification\n// Sample test:\n/*\n% cat << END > test1\nf 2\nu 2 3\nf 2\nu 1 3\np\nu 5 4\nu 3 4\nf 2\np\nu 1 0\np\nEND\n% ./a.out < test1\nFound 2 from 2\nMerged 2 and 3\nFound 3 from 2\nMerged 1 and 3\nn           0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19\nparent[n]   0  3  3  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19\nrank[n]     0  0  0  1  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\nMerged 5 and 4\nMerged 3 and 4\nFound 4 from 2\nn           0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19\nparent[n]   0  3  4  4  4  4  6  7  8  9 10 11 12 13 14 15 16 17 18 19\nrank[n]     0  0  0  1  2  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\nMerged 1 and 0\nn           0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19\nparent[n]   4  4  4  4  4  4  6  7  8  9 10 11 12 13 14 15 16 17 18 19\nrank[n]     0  0  0  1  2  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n\n*/\n#include<stdio.h>\n#include<stdlib.h>\n\n#define demand(fact, remark)    {   if (!(fact))        {   fprintf(stderr, "%s\n", remark); exit(1);   }    }\n\n#define SIZE 20    // (max) size of set we are partitioning\nint parent[SIZE];  // parent for each node\nint rank[SIZE];    // rank for each node\n#ifdef NOCOMPRESS       \nint compresspaths = 0;\n#else\nint compresspaths = 1;\n#endif\n\n// add operation; here we add all the elements in the array\n// at the start, don\'t keep track whats in the set and don\'t\n// expand the array\n// Might be better to store max, and have int add(void)\nvoid\nadd(int n) {\n    demand(n < SIZE, "too big!");\n    parent[n] = n;\n    rank[n] = 0;\n}\n\n// find operation\nint\nfind(int n) {\n    while (parent[n] != n){\n        // we want to compress paths in some way, eg path halving as\n        // done here but might want the option of avoiding it so\n        // students can see what happens without it\n        if (compresspaths)\n                parent[n] = parent[parent[n]];\n        n = parent[n];\n    }\n    return n;\n}\n\n// union operation, called merge since union is a C keyword\nvoid\nmerge(int n, int m) {\n    n = find(n);\n    m = find(m);\n    if (n == m) // in same set - nothing to do\n        return;\n    if (rank[n] > rank[m]) { // if n a larger tree, swap n and m\n        int tmp = m;\n        m = n;\n        n = tmp;\n    }\n    parent[n] = m; // make smaller tree (n) a subtree of larger (m)\n    if (rank[n] == rank[m]) // adjust size (rank) of new root\n        rank[m]++;\n    return;\n}\n\nint\nmain() {\n    int c, n1, n2;\n    for (n1 = 0; n1 < SIZE; n1++)\n        add(n1);\n    // we have find, union + print commands\n    // could have add + toggle path compression\n    while ((c = getchar()) != EOF) {\n        if (c == \'f\') {    // find element; print root\n            scanf("%d", &n1);\n            demand(n1 < SIZE, "too big!");\n            n2 = find(n1);\n            printf("Found %d from %d\n", n2, n1);\n        } else if (c == \'u\') { // union/merge two sets\n            scanf("%d %d", &n1, &n2);\n            demand(n1 < SIZE, "too big!");\n            demand(n2 < SIZE, "too big!");\n            merge(n1, n2);\n            printf("Merged %d and %d\n", n1, n2);\n        } else if (c == \'p\') { // print current state\n            printf("n         ");\n            for (n1 = 0; n1 < SIZE; n1++)\n                printf("%3d", n1);\n            printf("\n");\n            printf("parent[n] ");\n            for (n1 = 0; n1 < SIZE; n1++)\n                printf("%3d", parent[n1]);\n            printf("\n");\n            printf("rank[n]   ");\n            for (n1 = 0; n1 < SIZE; n1++)\n                printf("%3d", rank[n1]);\n            printf("\n");\n        }\n    }\n    return 0;\n}\n\n/* Example of test\n\n\n*/\n\\Note} \n\n\\Note{\nHandy things to copy/paste in vim for editing this file:\n(mostly in my .exrc now)\n:set ts=4 et\n\n\\In{\n\\In}\n\n\\Note}\n'),No=ho("\n\\Code{\n    Shorten_path\n        parent[n] <- parent[parent[n]] (if enabled) // point to grandparent, not parent \\B parent[n] <- parent[parent[n]]\n        \\Expl{ By replacing the parent pointer by a pointer to the\n            grandparent at each step up the tree, the path length is\n            halved. This turns out to be sufficient to keep paths very\n            short. Note that the root node is its own parent.\n            The animation allows this path compression to be disabled so\n            you can compare the relative heights of the trees produced.\n        \\Expl} \n\\Code} \n    \n\\Code{\n    Main\n    Find(n) // return root of tree containing n \\B Find(n)\n    \\In{\n        while n != parent[n]  // while we are not at the root \\B while n != parent[n]\n        \\In{\n            shorten path from n to root \\Ref Shorten_path\n            \\Expl{ There are several ways of shortening the path back to the\n                    root. The most obvious is to follow the path to the root\n                    then follow it again, making each element point to the\n                    root. The version here doesn't shorten the path as much\n                    but is simpler and overall it works extremely well.\n                    The animation allows path compression to be disabled so\n                    you can compare the relative heights of the trees produced.\n            \\Expl} \n            n <- parent[n]  // go up the tree one step \\B n <- parent[n]\n        \\In}\n        return n // return root \\B return n\n    \\In} \n    \\Code}\n"),Oo=ho('\n\\Note{  REAL specification of 234 tree insertion and search\n\\Note}\n    \n\\Note{  We would like the AIA representation of data structures for \n        search applications to share a certain format, allowing the \n        student to develop and use a structure (such as a BST) \n        through these operations: create a structure, search, insert, \n        and remove elements. This specification only covers \n        construction (using insertion) and search.\n\\Note}\n    \n\\Overview{\n\n\\Note{ Linda\'s changes 7/2023\npar 1 line 4 "named for..."\npar 2 line 3 "made for a given tree"\nMore later I didn\'t keep track of them\n  more explanation of why splitting, top down, bottom up\nLast paragraph end with B-trees\n\\Note}\n\nA 234 tree is a form of balanced search tree (and a simple instance\nof a B-tree).  All leaves are at the same level of the tree. The\ntree is made up of three kinds of nodes: two-nodes, three-nodes\nand four-nodes, named for the number of childred the node has.\nTwo-nodes are the same as binary search tree nodes,\ncontaining a left subtree (child1), a key (key1) and a right subtree\n(child2). Ordinarily they would also hold a data field, which the user\nwould like to find by searching for the key. Since this field has no\nimpact on how insertion and search take place, we disregard it here.\n\nThe tree is ordered so the keys in child1 are less than key1, which is\nless than the keys in child2.\nThree-nodes have two keys and three subtrees, named and\nordered child1, key1, child2, key2, child3.  Four-nodes have three keys\nand four subtrees, named and ordered child1, key1, child2, key2, child3,\nkey3, child4.  \n\nFor simplicity, equal keys have been ignored in this module. One way of handling duplicate\nkeys would be to have a linked list of records originating in the node. Alternatively an\napplication might not support records with equal keys, sending an error message if there\nis an attempt to insert a record whose key is already in the tree.  Another alternative might be\nto make an arbitrary choice beween storing equal keys in the left or the right subtree, and implement\na search function that finds all matching keys.\n\nNew items are always inserted in the leaves of the tree. Insertion into\ntwo-nodes and three-nodes is straightforward - just add the key and another pointer\nto the leaf node. However, if the search for the correct insertion point leads to a four-node,\nthe four-node\nmust be  split into two two-nodes, so as to make space for the insertion.\nBecause splitting,\nmight propagate up the tree, if the parent of the newly split four-node was also a four-node,\nit is simplest to implement the\n"top down" 234 tree insertion algorithm shown in this animation, which always splits four-nodes\nencountered as we traverse down the tree. There is a more complicated\n"bottom up" version that waits to split four-nodes until the split is actually needed.  The\n"bottom-up" version can slightly reduce the number of nodes in the\ntree in some cases, potentially improving efficiency.  \n\n---\n\nAlthough 234 trees\nare a bit cumbersome to code directly in many programming languages due\nto the multiple kind of nodes, they provide the idea behind red-black\ntrees.  Red-black trees can be seen as a representation of 234-trees\nusing a simpler data structure but a more complicated algorithm. Another\nvariation of 234-trees is to ensure all nodes as compact as possible,\nfor example, omitting child pointers from leaf nodes. This results in\nmore node types and more re-allocation of memory when node types change\nbut can be very space-efficient. Other variations of the 234-trees are the B-tree\nand the B+ tree, where each node has between M and M/2 children. The B- and B+-tree\nminimize memory accesses by setting M so that the node size is equal\nto the page of the file-system.\n\n\\Overview}\n  \n    \n\\Note{\n    Visualisation can use one, two or three boxes for nodes, with arrows for\n    subtrees originating from the bottom corner of the boxes. Ideally,\n    animation should be consistent with binary search tree animation where\n    possible.\n\\Note}\n    \n\\Code{\n    Main\n    T234_Insert(t, k) // Insert key k into 234 tree t \\B T234_Insert(t, k)\n    \\In{\n        if t = Empty \\B if t = Empty\n        \\In{\n            t <- a new two-node containing k and empty subtrees \\B t <- a new two-node containing k and empty subtrees\n        \\In}\n        else \\B else: T234_Insert(t, k)\n        \\In{\n            Traverse down to a leaf node p, transforming any four-nodes \\Ref Traverse \n            \\Expl{  Any four-node encountered is split into two two-nodes and the\n                    middle key (key2) is inserted into the parent node. Once this\n                    is done, we can be sure the leaf will have enough room for an\n                    extra key. The tree grows in height when the root node is\n                    split.\n            \\Expl}\n            Insert k into leaf p (changing the kind of node) \\Ref Insert \n            \\Expl{  A two-node will change to a three-node and a three-node\n                    will change to a four-node.\n            \\Expl}\n        \\In}\n    \\In}\n\\Code}\n    \n\\Code{\n    Insert\n    if p is a two-node \\B if p is a two-node\n    \\In{\n        Change p to a three-node, containing the old p.key1 and k \\B Change p to a three-node, containing the old p.key1 and k\n        \\Note{ Expand this????\n        \\Note}\n        \\Expl{ We must compare the keys and ensure they are in the right\n               order in the new node.  All subtrees are empty.\n        \\Expl}\n    \\In}\n    else // p is three-node (four-nodes have been split) \\B else: Insert\n        \\In{\n        Change p to a four-node, containing the old p.key1 and p.key2 and k \\B Change p to a four-node, containing the old p.key1 and p.key2 and k\n        \\Note{ Expand this????\n        \\Note}\n        \\Expl{ We must compare the keys and ensure they are in the right\n               order in the new node.  All subtrees are empty.\n        \\Expl}\n    \\In}\n\\Code}\n    \n\\Code{\n    Traverse\n    // Traverse down to a leaf where k gets inserted, splitting four-nodes\n    \\Note{\n    The code here stops when c becomes Empty.  This results in more\n    comparisons but slightly simpler code structure. We could break out of\n    the loop when c is a leaf instead. The low level details of the code and\n    its efficiency are not so important so I have gone for simple structure.\n    It\'s also more similar to the BST code to iterate until we fall off the\n    tree then repeat some comparison.\n    \\Note}\n    p <- Empty        // We keep track of the parent node, initially Empty \\B p <- Empty\n    c <- t            // c traverses the path from the root down to a leaf \\B c <- t\n    \\Expl{  c (and parent node p) will follow a path down to a leaf where new key\n            is to be inserted. We start from the root (t) and stop when p\n            reaches a leaf.\n    \\Expl}\n    repeat \\B repeat\n    \\In{\n        if c is a four-node \\B if c is a four-node\n        \\In{\n        Split c into two two-nodes and insert c.key2 into parent (p) \\Ref Split\n           \\Expl{  c is assigned the left or right node depending on comparison\n                   with k. If p is empty a new two-node is added as the root\n                   and the height of the tree increases by one.\n            \\Expl}\n        \\In} \n        p <- c \\B p <- c\n        \\Expl{  c will move down one level so the old c is the new p.\n        \\Expl}\n        c <- a child of c, dependent on key comparisons \\Ref MoveToChild\n    \\In}\n    until c is Empty (and p is a leaf node) \\B until c is Empty (and p is a leaf node)\n\\Code}\n    \n\\Code{\n    Split \n    c1 <- new two-node with c.child1, c.key1 and c.child2 \\B c1 <- new two-node with c.child1, c.key1 and c.child2\n    c2 <- new two-node with c.child3, c.key3 and c.child4 \\B c2 <- new two-node with c.child3, c.key3 and c.child4\n    Insert c1, c.key2 and c2 into parent node p, replacing c \\Ref InsertParent\n    \\Expl{\n        c1 and c2 will be children of p instead of c. p must be a two-node\n        or three-node so there will be room for expansion, because\n        four-nodes were split as we traversed down.\n    \\Expl}\n    if k < c.key2 \\B if k < c.key2: Split\n    \\In{\n        c <- c1 \\B c <- c1\n        \\Expl{ c is the new subtree that k belongs in\n        \\Expl}\n    \\In}\n    else \\B else: Split\n    \\In{\n        c <- c2 \\B c <- c2\n        \\Expl{ c is the new subtree that k belongs in\n        \\Expl}\n    \\In}\n    \\Code}\n    \n    \\Code{\n    InsertParent\n    if p = Empty \\B if p = Empty\n    \\In{\n        t <- new two-node with c1, c.key2 and c2 \\B t <- new two-node with c1, c.key2 and c2\n        \\Expl{  This is where the tree t grows by one level\n        \\Expl}\n        p <- t \\B p <- t\n    \\In}\n    else if p is a two-node \\B else if p is a two-node\n    \\In{\n        Change p to a three-node, with c1, c.key2 and c2 replacing c \\B Change p to a three-node, with c1, c.key2 and c2 replacing c\n        \\Note{ Expand this????\n        \\Note}\n        \\Expl{  If the old p.child1 = c the new node contains c1, c.key2, c2,\n                p.key1 and p.child2. If the old p.child2 = c the new node\n                contains p.child1, p.key1, c1, c.key2 and c2.\n        \\Expl}\n    \\In}\n    else // p is three-node (four-nodes have been split) \\B else: InsertParent\n    \\In{\n        Change p to a four-node, with c1, c.key2 and c2 replacing c \\B Change p to a four-node, with c1, c.key2 and c2 replacing c\n        \\Note{ Expand this????\n        \\Note}\n        \\Expl{  If the old p.child1 = c the new node contains c1, c.key2, c2,\n                p.key1, p.child2, p.key2 and p.child3. If the old p.child2 = c\n                the new node contains p.child1, p.key1, c1, c.key2, c2, p.key2\n                and p.child3. If the old p.child3 = c the new node contains\n                p.child1, p.key1, p.child2, p.key2, c1, c.key2 and c2.\n        \\Expl}\n    \\In}\n\\Code}\n    \n\\Code{\n    MoveToChild\n    if c is a two-node \\B if t is a two-node\n    \\In{\n        if k < c.key1 \\B if k < t.key1: if t is a two-node\n        \\In{\n            c <- c.child1 \\B c <- t.child1: if t is a two-node\n        \\In}\n        else \\B else: if t is a two-node\n        \\In{\n            c <- c.child2 \\B c <- t.child2: if t is a two-node\n        \\In}\n    \\In}\n    else // c is a three-node \\B else if t is a three-node\n    \\In{\n        if k < c.key1 \\B if k < t.key1: else if t is a three-node\n        \\In{\n            c <- c.child1 \\B c <- t.child1: else if t is a three-node\n        \\In}\n        else if k < c.key2 \\B else if k < t.key2: else if t is a three-node\n        \\In{\n            c <- c.child2 \\B c <- t.child2: else if t is a three-node\n        \\In}\n        else \\B else: else if t is a three-node\n        \\In{\n            c <- c.child3 \\B c <- t.child3: else if t is a three-node\n        \\In}\n    \\In}\n\\Code}\n\n\\Note{  This is an implementation in C:\n    // 234-tree implementation and simple testing based on two34tree.real\n    /*\n    echo 15 4 6 18 5 13 2 7 17 9 8 19 11 10 15 16    11 5 16 6 2 3 12 22 1 0 | ./a.out\n    \n    Inorder traversal yields:\n      (4.1)2\n      (4.2)4\n      (4.3)5\n     (2.1)6\n      (2.1)7\n    (2.1)8\n      (4.1)9\n      (4.2)10\n      (4.3)11\n     (3.1)13\n      (4.1)15\n      (4.2)16\n      (4.3)17\n     (3.2)18\n      (2.1)19\n    \n    Found  11\n    Found  5\n    Found  16\n    Found  6\n    Found  2\n    Missed 3\n    Missed 12\n    Missed 22\n    Missed 1\n    */\n    \n    #include<stdio.h>\n    #include<stdlib.h>\n    \n    typedef int k234;\n    typedef struct node234 {\n        int node_kind; // 2, 3 or 4\n        struct node234 *child1;\n        k234 key1;\n        struct node234 *child2;\n        k234 key2;\n        struct node234 *child3;\n        k234 key3;\n        struct node234 *child4;\n        } n234, *t234;\n    \n    #define NEW(type) (type *) malloc(sizeof(type))\n    #define demand(fact, remark)        {   if (!(fact))            {   fprintf(stderr, "%s\n", remark); exit(1);   }        }\n    \n    #define SIZE 30      /* Allow for a tree with up to 30 keys */\n    \n    // list (and other) code from bst.c\n    typedef struct lnode {\n        int elt;\n        struct lnode *next;\n    } ELT;\n    \n    // change node to particular kind with given fields\n    // Braces used to avoid potential bugs with use in "else" so\n    // no ";" needed/wanted.  Temp vars used in case arguments are fields of\n    // struct being updated (its a macro so call by name, not value)\n    #define mkThree(c, c1, k1, c2, k2, c3)         {t234 c1t=c1, c2t=c2, c3t=c3; k234 k1t=k1, k2t=k2;         c->node_kind = 3; c->child1 = c1t; c->key1 = k1t; c->child2 = c2t;         c->key2 = k2t; c->child3 = c3t;}\n    #define mkFour(c, c1, k1, c2, k2, c3, k3, c4)         {t234 c1t=c1, c2t=c2, c3t=c3, c4t=c4; k234 k1t=k1, k2t=k2, k3t=k3;         c->node_kind = 4; c->child1 = c1t; c->key1 = k1t; c->child2 = c2t;         c->key2 = k2t; c->child3 = c3t; c->key3 = k3t; c->child4 = c4t;}\n    \n    void build_t234(ELT *lst, t234 *tp);\n    t234 find_child(t234 c, k234 k);\n    t234 Two(t234 c1, k234 k1, t234 c2);\n    void t234_insert(t234 *tp, k234 k);\n    void inorder(t234 t, int indent);\n    \n    // create new two-node with given contents\n    t234\n    Two(t234 c1, k234 k1, t234 c2) {\n        t234 c;\n    \n        c = NEW(n234);\n        c->node_kind = 2;\n        c->child1 = c1;\n        c->key1 = k1;\n        c->child2 = c2;\n        return c;\n    }\n    \n    // 234-tree insertion.  We pass in pointer to tree so it can be modified\n    // and return void\n    void\n    t234_insert(t234 *tp, k234 k) {\n            // p is the parent of c and follows c down the tree to a leaf\n        t234 c, p;\n    \n        if (*tp == NULL) {  \n            c = Two(NULL, k, NULL);\n            *tp = c;\n        } else {\n            // Traverse\n            p = NULL;\n            c = *tp;\n            do {\n                if (c->node_kind == 4) {\n                    // Split\n                    t234 c1, c2;\n                    c1 = Two(c->child1, c->key1, c->child2);\n                    c2 = Two(c->child3, c->key3, c->child4);\n                    // InsertParent\n                    if (p == NULL)\n                        *tp = Two(c1, c->key2, c2); // add new root to tree\n                    else if (p->node_kind == 2)\n                        if (p->child1 == c)\n                            mkThree(p, c1, c->key2, c2, p->key1, p->child2)\n                        else\n                            mkThree(p, p->child1, p->key1, c1, c->key2, c2)\n                    else { // p->node_kind == 3\n                        if (p->child1 == c)\n                            mkFour(p, c1, c->key2, c2, p->key1, p->child2, p->key2, p->child3)\n                        else if (p->child2 == c)\n                            mkFour(p, p->child1, p->key1, c1, c->key2, c2, p->key2, p->child3)\n                        else\n                            mkFour(p, p->child1, p->key1, p->child2, p->key2, c1, c->key2, c2)\n                    }\n                    if (k < c->key2) {\n                        c = c1;\n                    } else {\n                        c = c2;\n                    }\n                }\n                p = c;\n                c = find_child(c, k);\n            } while (c);\n            // Insert\n            if (p->node_kind == 2)\n                if (k < p->key1)\n                    mkThree(p, NULL, k, NULL, p->key1, NULL)\n                else\n                    mkThree(p, NULL, p->key1, NULL, k, NULL)\n            else // p->node_kind == 3\n                if (k < p->key1)\n                    mkFour(p, NULL, k, NULL, p->key1, NULL, p->key2, NULL)\n                else if (k < p->key2)\n                    mkFour(p, NULL, p->key1, NULL, k, NULL, p->key2, NULL)\n                else\n                    mkFour(p, NULL, p->key1, NULL, p->key2, NULL, k, NULL)\n        }\n    }\n    \n    // return child of node that might contain k\n    t234\n    find_child(t234 c, k234 k) {\n        if (c->node_kind == 2)\n            if (k < c->key1)\n                return c->child1;\n            else\n                return c->child2;\n        else if (c->node_kind == 3)\n            if (k < c->key1)\n                return c->child1;\n            else if (k < c->key2)\n                return c->child2;\n            else\n                return c->child3;\n        else // c->node_kind == 4\n            if (k < c->key1)\n                return c->child1;\n            else if (k < c->key2)\n                return c->child2;\n            else if (k < c->key3)\n                return c->child3;\n            else\n                return c->child4;\n    }\n    \n    // insert list elements into tree\n    void\n    build_t234(ELT *lst, t234 *tp) {\n        while (lst) { \n            t234_insert(tp, lst->elt);\n            lst = lst->next;\n        }\n    } \n    \n    void search_t234(t234 t, k234 k) {\n        while (t) {\n            if (k == t->key1 || t->node_kind>1 && \n                    (k == t->key2 || t->node_kind>2 && k == t->key3)) {\n                printf("Found  %d\n", k);\n                return;\n            }\n            t = find_child(t, k);\n        }\n        printf("Missed %d\n", k);\n        return;\n    }\n    \n    void inorder(t234 t, int indent) {\n        int i;\n    \n        if (t) {\n            inorder(t->child1, indent+1);\n            for (i=0; i<indent; i++) printf(" ");\n            printf("(%d.1)", t->node_kind);\n            printf("%d\n", t->key1);\n            inorder(t->child2, indent+1);\n            if (t->node_kind>2) {\n                for (i=0; i<indent; i++) printf(" ");\n                printf("(%d.2)", t->node_kind);\n                printf("%d\n", t->key2);\n                inorder(t->child3, indent+1);\n                if (t->node_kind>3) {\n                    for (i=0; i<indent; i++) printf(" ");\n                    printf("(%d.3)", t->node_kind);\n                    printf("%d\n", t->key3);\n                    inorder(t->child4, indent+1);\n                }\n            }\n        }\n    }\n    \n    int main() {\n        t234 t=NULL;\n        int i, n, x;\n        ELT *e;\n        ELT *first;\n        ELT *last;\n        scanf("%d", &n);\n        demand(n>0, "n must be positive");\n        first = NEW(ELT);\n        first->next = NULL;\n        scanf("%d", &(first->elt));\n        last = first;\n        \n        for (i=1; i<n; i++) {\n            e = NEW(ELT);\n            e->next = NULL;\n            scanf("%d", &(e->elt));\n            last->next = e;\n            last = e;\n        }\n        \n        build_t234(first, &t);\n    \n     /* For testing only : */\n        printf("\nInorder traversal yields:\n");\n        inorder(t, 0);   \n        printf("\n");                         \n    /*  */\n        scanf("%d", &x);\n        while (x > 0) {\n            search_t234(t, x);\n            scanf("%d", &x);\n        } \n    \n        return 0;\n    }\n     \n    /* Example of test input with 15 keys (must be no more than 20):\n    \n    15\n    77  13  10  46  94  49  91  88  25  62  54  59  19  44  16\n    62\n    63\n    94\n    0\n    \n    This yields the following output:\n    \n    Found  62\n    Missed 63\n    Found  94\n    \n    */\n    \n    \\Note}\n    \\Note{\n    Handy things to copy/paste in vim for editing this file:\n    (mostly in my .exrc now)\n    :set ts=4 et\n    \n    \\In{\n    \\In}\n    \n    \\Note}\n'),Io=ho("\n\\Code{\n    Main\n    T234_Search(t, k) \\B T234_Search(t, k)\n    // return either a node containing key k or \n    // NotFound, if no such node is present\n    \\Note{  We separate comparison for equality with comparison for finding\n    the subtree to traverse down to next to simplify refinement\n    \\Note}\n    \\In{\n        while t not Empty \\B while t not Empty\n        \\In{\n            if the root of t contains k, return t \\Ref Return_if_key_in_node\n            \\Expl{  There can be different kinds of node and multiple keys per node.\n            \\Expl}\n            \\Note{  Refinement is messy due to different kinds of node so we\n                    include return here and avoid else\n            \\Note}\n            t <- the child of t that may contain k \\Ref Find_child\n            \\Expl{  There can be different kinds of node and multiple children.\n            \\Expl}\n        \\In}\n        return NotFound \\B return NotFound\n    \\In}\n    \\Code}\n    \n    \\Code{\n    Return_if_key_in_node \n    // Return node t if it contains key k\n    if t is a two-node \\B if t is a two-node: Return_if_key_in_node\n    \\In{\n        if t.key1 == k return t \\B if t.key1 == k return t\n    \\In}\n    else if t is a three-node \\B if t is a three-node: Return_if_key_in_node\n    \\In{\n        if t.key1 == k or t.key2 == k return t \\B if t.key1 == k or t.key2 == k return t\n    \\In}\n    else // t is a four-node \\B else: Return_if_key_in_node\n    \\In{\n        if t.key1 == k or t.key2 == k or t.key3 == k return t \\B if t.key1 == k or t.key2 == k or t.key3 == k return t\n    \\In}\n    \\Code}\n    \n    \\Code{\n    Find_child \n    // Find child c of root node t that may contain key k\n    if t is a two-node \\B if t is a two-node\n    \\In{\n        if k < t.key1 \\B if k < t.key1: if t is a two-node\n        \\In{\n            c <- t.child1 \\B c <- t.child1: if t is a two-node\n        \\In}\n        else \\B else: if t is a two-node\n        \\In{\n            c <- t.child2 \\B c <- t.child2: if t is a two-node\n        \\In}\n    \\In}\n    else if t is a three-node \\B else if t is a three-node\n    \\In{\n        if k < t.key1 \\B if k < t.key1: else if t is a three-node\n        \\In{\n            c <- t.child1 \\B c <- t.child1: else if t is a three-node\n        \\In}\n        else if k < t.key2 \\B else if k < t.key2: else if t is a three-node\n        \\In{\n            c <- t.child2 \\B c <- t.child2: else if t is a three-node\n        \\In}\n        else \\B else: else if t is a three-node\n        \\In{\n            c <- t.child3 \\B c <- t.child3: else if t is a three-node\n        \\In}\n    \\In}\n    else // t is a four-node \\B else: Find_child\n    \\Expl{ We could use nested if-then-else here so we always have two\n    key comparisons\n    \\Expl}\n    \\In{\n        if k < t.key1 \\B if k < t.key1: else: Find_child\n        \\In{\n            c <- t.child1 \\B c <- t.child1: else: Find_child\n        \\In}\n        else if k < t.key2 \\B else if k < t.key2: else: Find_child\n        \\In{\n            c <- t.child2 \\B c <- t.child2: else: Find_child\n        \\In}\n        else if k < t.key3 \\B else if k < t.key3\n        \\In{\n            c <- t.child3 \\B c <- t.child3: else: Find_child\n        \\In}\n        else \\B else: else: Find_child\n        \\In{\n            c <- t.child4 \\B c <- t.child4\n        \\In}\n    \\In}\n    \\Code}\n    \n"),Co=ho("\n\\Code{\nMain\nShortest(G, s) // Find shortest path(s) from start node s in graph G \\B 1\n    \\Expl{ Given a graph G, find a shortest path from start node s\n        to an end node.  It is assumed the end node(s) are defined\n        separately; with no end nodes, shortest paths to all connected\n        nodes are found. Nodes are numbered 1..nmax. Returns the Parent\n        array, which gives the previous node in the path from s to the\n        node i (if one has been found; Parent[i] = 0 otherwise). \n    \\Expl}\n\n        \\In{\n                initialise, with fontier={s}, stored in Nodes \\Ref Init\n                while Nodes is not empty \\B 2\n            \\Expl{ Nodes is the data structure used to represent the frontier.\n                For Dijkstra's algorithm, Nodes is a priority queue, ordered on\n                Cost (the minumum path length found so far). Here we highlight the Min\n                value. The priority queue also contains nodes that have not been\n                seen, which have infinite Cost. The frontier nodes are those\n                shown with a finite Cost. Nodes with no Cost shown\n                have been finalised. The frontier and finalised nodes are also\n                highlighted in the graph display.\n            \\Expl}\n                \\In{\n                    remove next node n from Nodes and finalise it \\Ref Next_node\n                    // The Parent of n has now been determined\n                    if task_completed(n) \\Ref Completed\n                    \\Expl{ Have we found an end node or explored the\n                            whole graph component connected to s? \n                    \\Expl} \n                    \\In{\n                        return \\B 3\n                        \\Expl{ If there may be several end nodes we may want to\n                            return which one was found as well as the Parent\n                            array, and if we have explored the whole graph\n                            component that should be indicated. Here we\n                            highlight the path found in the Parent array,\n                            if successful, and the explored component otherwise.\n                        \\Expl} \n                    \\In} \n                    for each node m neighbouring n // G has edge from n to m \\B 4\n                    \\In{\n                        update Nodes, Parent etc with n & m \\Ref UpdateNodes\n                    \\In}\n                \\In}\n                return \\B 99\n                \\Expl{ The shortest path to every node connected to s has been found.\n                        If we were searching for an end node we have failed\n                        and some indication of this should be returned.\n                \\Expl}\n            \\In}\n            \n\\Code}\n\n\\Code{\n        Init\n            initialise each element of array Parent to zero \\B 5\n            initialise each element of array Cost to infinity \\B 6\n            Cost[s] <- 0 \\B 7\n            Nodes <- PQ containing all nodes  // only s has finite cost \\B 8\n            //  Nodes in the PQ with finite cost are in the frontier; others are yet to be seen. \n\\Code}  \n\n\\Code{\n        Next_node\n            n <- PQRemoveMin(Nodes) // remove lowest cost element of Nodes PQ \\B 9\n            \\Expl{ n is the node in the frontier with the shortest known path\n                    back to s (if it has infinite cost it must be in a component\n                    not connected to s; not actually in the frontier).\n            \\Expl}\n        \\Code}\n        \n\n\\Code{\n        Completed\n            if is_end_node(n) or Cost[n] = infinity \\B 10\n            \\Expl{ If the cost of n is infinite we have searched the whole component\n                (without finding an end node) and the Parent array has all shortest\n                paths.  Otherwise, n is an end node we have succeeded and\n                the Parent array has the shortest path.\n            \\Expl}\n\\Code}\n\n\\Code{\n        UpdateNodes\n            if m is in Nodes PQ and Cost[n] + weight(n,m) < Cost[m] \\B 11\n            \\Expl{ The path from s to n to m is shorter than the current\n                shortest known path from s to m. If Cost[m] = infinity\n                it will be replaced with a finite weight, implicitly moving\n                m from the unseen nodes to the frontier. If m has been\n                finalised, this test is guaranteed to fail.\n            \\Expl} \n            \\In{\n                Cost[m] <- Cost[n] + weight(n,m) // new cost is path length from s \\B 12\n                PQUpdateCost(Nodes, m, Cost[m]) // update cost in Nodes PQ \\B 13\n                Parent[m] <- n \\B 14\n                \\Expl{ The shortest known path to m now goes via n.\n                \\Expl}\n            \\In}\n\\Code}\n"),So=ho('\n\\Code{\n    Main\n    Astar(G, s, e) // Heuristic search for node e from node s in graph G \\B 1\n    \\Expl{ Given a graph G, find a path from start node s\n            to the end node e.  Nodes are numbered 1..nmax. Returns the\n            Parent array, which gives the previous node in the path from s\n            to the node i (if one has been found; Parent[i] = 0 otherwise).\n            A heuristic function is used to guide the search (here it is\n            a measure of the distance from each node to e, based on\n            the Euclidiean coordinates of each node). If the\n            heuristic is "admissible", the shortest path will be found.\n    \\Expl}\n\n     \\In{\n          initialise, with fontier={s}, stored in Nodes \\Ref Init\n            while Nodes is not empty \\B 2\n            \\Expl{ Nodes is the data structure used to represent the frontier.\n\t\tFor A*, Nodes is a priority queue, ordered on Length (the minumum\n                found so far) plus the heuristic value. Here we highlight the Min\n                value. The priority queue also contains nodes that have not been\n                seen, which have infinite Length. The frontier nodes are those\n                shown with a finite Length so far. Nodes with no Length shown\n                have been finalised. The frontier and finalised nodes are also\n                highlighted in the graph display.\n            \\Expl}\n            \\In{\n                remove next node n from Nodes and finalise it \\Ref Next_node\n                // The Parent of n has now been determined\n                if task_completed(n) \\Ref Completed\n                \\Expl{ Have we found the end node, or explored the\n                        whole connected component of the graph?\n                \\Expl}\n                \\In{\n                    return \\B 3\n                    \\Expl{ If we have explored the whole graph component without\n                        finding the end node that should be indicated, otherwise\n                        the Parent array has the desired path information.  Here we\n                        highlight the path found in the Parent array,\n                        if successful, and the explored component otherwise.\n                    \\Expl}\n                \\In}\n                for each node m neighbouring n // G has edge from n to m \\B 4\n                \\In{\n                    update Nodes, Parent etc with n & m \\Ref UpdateNodes\n                \\In}\n            \\In}\n            return \\B 99\n            \\Expl{ We have failed to find e and some indication of\n                    this should be returned. In this animation we\n                    restrict e to be some node in the graph so this\n                    line is never reached.\n            \\Expl}\n        \\In}\n\\Code}\n\n\\Code{\n    Init\n        initialise each element of array Parent to zero \\B 5\n        initialise each element of array Length to infinity \\B 6\n        Length[s] <- 0 \\B 7\n        Nodes <- PQ containing all nodes // only s has finite cost \\B 8\n        \\Note{ Nodes in the PQ with finite cost are in the frontier; others\n            are yet to be seen.\n        \\Note}\n\\Code}\n\n\\Code{\n    Next_node \n        n <- PQRemoveMin(Nodes) // remove lowest cost element of Nodes PQ \\B 9\n        \\Expl{ n is the node in the frontier with the shortest known path\n                length back to s plus heuristic value (if it has infinite\n                cost it must be in a component not connected to s; not\n                actually in the frontier).\n        \\Expl}\n    \n\\Code}\n\n\\Code{\n    Completed\n        if n = e or Length[n] = infinity \\B 10\n        \\Expl{ If the Length of n is infinite we have searched the whole\n                component (without finding the end node) and we should\n                return a failure indication.\n                Otherwise, if n is the end node we have succeeded and\n                the Parent array has the path.\n        \\Expl}\n\\Code}\n    \n    \n\\Code{\n    UpdateNodes\n        if m is in Nodes PQ and Length[n] + weight(n,m) < Length[m] \\B 11\n        \\Expl{ The path from s to n to m is shorter than the current\n            shortest known path from s to m. If Length[m] == infinity\n            it will be replaced with a finite weight, implicitly moving\n            m from the unseen nodes to the frontier.\n        \\Expl} \n        \\In{\n            Length[m] <- Length[n] + weight(n,m) // smaller path length from s \\B 12\n            PQUpdateCost(Nodes, m, Length[m]+heur(m)) // update cost in Nodes PQ \\B 13\n            Parent[m] <- n \\B 14\n            \\Expl{ The shortest known path to m now goes via n.\n            \\Expl}\n        \\In}\n\\Code}\n'),Mo=ho('\n\\Code{\n    Main\n    BFS(G, s) // Breadth first search of graph G from start node s \\B 1\n    \\Expl{ Given a graph G, find a path from the start node s to an\n            end node.  It is assumed the end node(s) are defined\n            separately; if there are no end nodes, paths to all connected\n            nodes are found. Nodes are numbered 1..nmax. Returns the Parent\n            array, which gives the previous node in the path from s to the\n            node i (if one has been found; Parent[i] = 0 otherwise).\n    \\Expl}\n    \\In{\n        initialise, with fontier={s}, stored in Nodes \\Ref Init\n        while Nodes is not empty \\B 2\n            \\Expl{ Nodes is the data structure used to represent the frontier.\n                For BFS, Nodes is a queue, shown below the arrays.  The frontier\n                nodes are simply those in the queue (they are also marked as\n                Seen). The Seen nodes that are no longer in the queue are\n                finalised.  The frontier and finalised nodes are also highlighted\n                in the graph display.\n            \\Expl}\n        \\In{\n            remove next node n from Nodes and finalise it \\Ref Next_node \n            // The Parent of n has now been determined\n            if task_completed(n) \\Ref Completed \n            \\Expl{ If there are no end nodes the whole connected component\n                   of G will be explored and we can skip this "if".\n            \\Expl}\n            \\In{\n                return \\B 3\n                \\Expl{ If there can be several end nodes we may want to\n                       return which one is found as well as the Parent array.\n                       Here we highlight the path found in the Parent array.\n                \\Expl}\n            \\In}\n            for each node m neighbouring n // G has edge from n to m \\B 4\n            \\In{\n                update Nodes, Parent etc with n & m \\Ref UpdateNodes \n            \\In}\n        \\In}\n        return \\B 5\n        \\Expl{ A path to every node connected to s has been found.\n                If we were searching for an end node we have failed\n                and some indication of this should be returned.\n        \\Expl}\n    \\In}\n    \\Code}\n    \n    \\Code{\n    Init\n        initialise each element of array Parent to zero \\B 6\n        initialise each element of array Seen to False \\B 7\n        Seen[s] <- True      // Initially we have seen only the start node \\B 8\n        Nodes <- queue containing just s \\B 9\n    \\Code}\n    \n    \\Code{\n    Next_node\n        n <- dequeue(Nodes) // remove the front element of the Nodes queue \\B 10\n        \\Expl{ Finalised nodes are implicit: they are nodes that are in\n                Seen but not in the Nodes queue. Frontier nodes are\n                those than are in Seen and in Nodes. By removing n from\n                Nodes we remove it from the frontier and finalise it.\n        \\Expl}\n    \\Code}\n    \n    \\Code{\n    Completed\n        if is_end_node(n) \\B 11\n        \\Expl{ If we were searching for an end node we have succeeded!\n            If we just want to traverse the whole graph component connected\n            to s, we can skip this "if".\n        \\Expl}\n    \\Code}\n    \n    \\Code{\n    UpdateNodes\n        if not Seen[m] \\B 12\n        \\In{\n            Seen[m] <- True \\B 13\n            Parent[m] <- n \\B 14\n            enqueue(Nodes, m) // add m to back of Nodes queue \\B 15\n        \\In}\n    \\Code}\n'),Bo=ho('\n\\Code{\n    Main\n    DFS(G, s) // Depth first search of graph G from start node s \\B 1\n    \\Expl{ Given a graph G, find a path from the start node s to an\n            end node.  It is assumed the end node(s) are defined\n            separately; if there are no end nodes, paths to all connected\n            nodes are found. Nodes are numbered 1..nmax. Returns the Parent\n            array, which gives the previous node in the path from s to the\n            node i (if one has been found; Parent[i] = 0 otherwise).\n    \\Expl}\n    \\In{\n        initialise, with fontier={s}, stored in Nodes \\Ref Init\n        while Nodes is not empty \\B 2\n            \\Expl{ Nodes is the data structure used to represent the frontier.\n                For DFS, Nodes is a stack, shown below the arrays.\n                The stack can have repeated elements and when we pop a node off\n                the stack it is ignored if it has already been finalised.\n                The frontier nodes are those in the stack that are not finalised.\n                The frontier and finalised nodes are also highlighted in the\n                graph display.\n            \\Expl}\n        \\In{\n            remove next node n from Nodes and finalise it \\Ref Next_node\n            // The Parent of n has now been determined\n            if task_completed(n) \\Ref Completed\n            \\Expl{ If there are no end nodes the whole connected component\n                   of G will be explored and we can skip this "if".\n            \\Expl}\n            \\In{\n                return \\B 3\n                \\Expl{ If there can be several end nodes we may want to\n                       return which one is found as well as the Parent array.\n                       Here we highlight the path found in the Parent array.\n                \\Expl}\n            \\In}\n            for each node m neighbouring n // G has edge from n to m \\B 4\n            \\In{\n                update Nodes, Parent etc with n & m \\Ref UpdateNodes\n            \\In}\n        \\In}\n        return \\B 5\n        \\Expl{ A path to every node connected to s has been found.\n                If we were searching for an end node we have failed\n                and some indication of this should be returned.\n        \\Expl}\n    \\In}\n    \\Code}\n    \n    \\Code{\n    Init\n        initialise each element of array Parent to zero \\B 6\n        initialise each element of Finalised to False \\B 7\n        Nodes <- stack containing just s \\B 8\n    \\Code}\n    \n    \\Code{\n    Next_node\n\\Note{ XXX could re-code this as follows (not sure if its and more\nclear but worth considering). Current coding emphasises we pop a node\nthen have to deal with "special" cases.\n        repeat\n            n <- pop(Nodes)\n        until !Finalised[n] || Nodes is empty\n        if Nodes is empty\n            return\n\\Note}\n        n <- pop(Nodes) // pop n from the top of the Nodes stack \\B 9\n        while Finalised[n] // ignore finalised nodes \\B 10\n        \\Expl{ The Nodes stack can have finalised nodes, which must be\n            ignored to avoid repeated search. The frontier is implicit:\n            it is everything in the Nodes stack that is not in Finalised.\n        \\Expl}\n        \\In{\n            if Nodes is empty // need to check this before popping a node \\B 11\n            \\In{\n                return \\B 12\n                \\Expl{ A path to every node connected to s has been found.\n                    If we were searching for an end node we have failed\n                    and some indication of this should be returned.\n                \\Expl}\n            \\In}\n            n <- pop(Nodes) // pop n from the top of the Nodes stack \\B 13\n        \\In}\n        Finalised[n] <- True  // n is now finalised \\B 14\n    \\Code}\n    \n    \\Code{\n    Completed\n        if is_end_node(n) \\B 15\n        \\Expl{ If we were searching for an end node we have succeeded!\n            If we just want to traverse the whole graph component connected\n            to s, we can skip this "if".\n        \\Expl}\n    \\Code}\n    \n    \n    \\Code{\n    UpdateNodes\n        if not Finalised[m] \\B 16\n        \\Expl{ This is not strictly necessary but it saves pushing finalised\n            nodes onto the Nodes stack and ignoring them later.\n        \\Expl}\n        \\In{\n            Parent[m] <- n \\B 17\n            push(Nodes, m) // add m to top of Nodes stack \\B 18\n        \\In}\n    \\Code}\n'),To=ho('\n\\Note{  REAL specification of depth first search of graphs, recursive\nversion\n\\Note}\n\n\\Note{ There are several graph search algorithms that lead up to A*\nand we present them in a consistent way to show their similarities.\nIt includes an iterative DFS coding; this recursive coding is somewhat\nsimpler but visualisation should emphasise similarities with the\niterative version as much as possible.\n\\Note}\n\n\\Note{\nVisualisation: same as iterative version without Finalised + call stack\nmade explicit\n\n    i            1      2      3      ...\n    Parent[i]\n\n    Call stack (n,p):\n\n\\Note}\n\n\n\\Code{\nMain\nDFS(G, n) // Depth first search of graph G from start node n \\B start\n    \\Expl{ Given a graph G, find a path from the start node n to an\n            end node.  It is assumed the end node(s) are defined\n            separately; if there are no end nodes, paths to all connected\n            nodes are found. Nodes are numbered 1..nmax. Returns the Parent\n            array, which gives the previous node in the path from s to the\n            node i (if one has been found; Parent[i] = 0 otherwise).\n    \\Expl}\n\n\\In{\n    initialise all parents to null \\B init\n    \\Expl{ We initialise to some special value so we can later check if a\n        parent has been assigned (we display null as an empty cell).\n        The start node is the implicit "frontier" for the top level DFS1\n        call. It is not\n        necessary to understand the frontier.  We mention it just for\n        comparison with the iterative version of DFS and related graph\n        search algorithms.\n    \\Expl}\n    result <- DFS1(G, n, 0) // recursive DFS with zero as parent node \\B top_call\n    return result \\B finish\n    \\Expl{ If there can be several end nodes we may want to\n        return which one is found as well as the Parent array for\n        successful searches (it defines a path from the end node back to\n        the start node).  Here we highlight the path found in\n        the Parent array.\n    \\Expl}\n\\In}\n//======================================================================\n\\Note{\n    Whenever DFS1 is called, we should push (n,p) onto the stack displayed\n    in the animation; pop stack on return.\n\\Note}\nDFS1(G, n, p) // Search from node n using parent node p. This visits all \\B dfs1\n        // nodes connected to n, ignoring nodes with parents already\n        // assigned (as if these nodes have been removed from G).\n\\In{\n    if Parent[n] == null // Ignore n if Parent[n] has been assigned \\B check_parent\n    \\In{\n        Parent[n] <- p \\B assign_parent\n        \\Expl{ Node n is now finalised.\n        \\Expl}\n        if is_end_node(n) \\B check_end\n        \\In{\n            return FOUND // Success! \\B found\n            \\Expl{ If there can be several end nodes we may want to\n                return which one is found as well as the Parent array,\n                which defined the path from the end node back to the start.\n            \\Expl}\n        \\In}\n        // The neighbouring nodes are now part of the (implicit) frontier \\B frontier\n        \\Expl{ It is not necessary to understand the frontier.\n            We mention it just for comparison with the iterative version\n            of DFS and related graph search algorithms. The neighbouring nodes\n            will be checked via a recursive call in the loop below (finalised\n            nodes will be ignored).\n        \\Expl}\n        for each node m neighbouring n // G has edge from n to m \\B neighbours\n        \\Note{ When this is first reached, all neighbouring nodes\n            should change to the "frontier" colour (see iterative DFS)\n            unless they are already finalised (have parent assigned)\n            and whenever this line is reached the n-m edge should be\n            highlighted. For iterative DFS, the m nodes are all pushed onto\n            the stack then the last one is popped off and visited if\n            required. For this recursive version we don\'t have an\n            explicit stack but have an implicit stack that has a\n            "continuation" that will look at the subsequent m nodes.\n        \\Note}\n        \\Expl{ Any order of considering the nodes is ok.  Here we\n            consider the largest node numbers first, which gives the\n            same traversal order as the iterative coding.\n        \\Expl}\n        \\In{\n            search G starting from m, with n as the parent \\Ref RECDFS\n        \\In}\n    \\In}\n    return NOTFOUND  // no end node found \\B not_found\n\\In}\n\\Code}\n\\Code{\nRECDFS\n    // *recursively* call DFS1 and return if successful \\B rec_dfs1\n    if DFS1(G, m, n) = FOUND \\B rec_dfs1_done\n    \\In{\n        return FOUND // return if end node found, otherwise continue \\B rec_found\n    \\In}\n\\Code}\n\n\n\n');let Ro='\n\n        \\Code{\n            NullTable\n                i <- 0\n                while i<TableSize \\B 2\n                \\In{\n                    T[i] <- Empty     // Table must start with all slots empty\n                    i <- i+1\n                \\In}\n        \\Code}\n\n        \\Code{\n            Main\n            HashInit(T)    // TableSize is prime \\B 1\n                \\In{\n                    Initialize Hash Table Slots to Empty   \\Ref NullTable\n                    Insertions <- 0    // Keep track of how full table is \\B 3\n                \\In}\n\n            //=======================================================\n\n            HashInsert(T, k)  // Insert key k into table T\n                \\In{\n                    Check how full the table is\n                    \\Expl{ One empty slot must always be maintained, to prevent to potential for infinite looping.\n                    Even before this point performance degrades if the table gets too full, say over 80% full.\n                    See Overview for more details.\n                    \\Expl}\n                    Insertions <- Insertions + 1 \\B 4\n                    \\Expl{ To check how full the table is we can maintain a simple\n                        counter.\n                    \\Expl}\n                    \\Note{The following has a choose increment value -- assumes we can make a choice\n                    \there between linear probing and double hashing. NOTE TO DEVELOPERS: We are planning to\n                    \tmake linear probing and double hashing as two separate modules.\n                    \tSo -- in the linear probing pseudocode there is no "Choose increment",\n                    \tincrement is just 1, and further on in the pseudocode Increment will be replaced\n                    \tby 1.  For the double hashing, we need to calculate the second hash function.\n                    \\Note}\n                    i <- hash(k) \\Ref Hash1\n                    Choose Increment value in case of collisions \\Ref SetIncrement\n                    Search for unoccupied slot \\Ref InsertionLoop\n                    \\Expl{ Check slots in steps of the chosen increment value, wrapping around at the end of the table\n                    \\Expl}\n                    T[i] <- k // unoccupied slot found so we put k in it \\B 9\n                    // Done \\B 10\n                \\In}\n        \\Code}\n\n        \\Code{\n            InsertionLoop\n                \\Expl{ If T[i] = k then k already exists in the table.  We could explicitly check\n                    for this but the code here simply over-writes the previous\n                    ocurrence of k, as if the slot was empty.\n                \\Expl}\n                while T[i] is occupied by another element // search for unoccupied slot \\B 7\n                \\Expl{ If T[i] = k then k already exists in the table.  We could explicitly check\n                        for this but the code here simply over-writes the previous\n                        ocurrence of k, as if the slot was empty.\n                \\Expl}\n                \\In{\n                    i <- (i + Increment) mod TableSize \\B 8\n                    \\Expl{ T[i] is occupied so we jump ahead Increment steps.\n                        We use modulo TableSize to "wrap around" if we reach the end.\n                    \\Expl}\n                \\In}\n        \\Code}\n\n        \\Code{\n            HashDelete(T, i)    // mark T[i] as Deleted\n                                // To delete a key we need to search for it first\n                T[i] <- Deleted \\B 12\n                \\Expl{ T[i] is no longer considered occupied, so a key may be\n                        inserted here, but searching does not stop at Deleted slots,\n                        only Empty ones (or if we find the key).\n                \\Expl}\n                Check how many Deleted slots there are in the table\n                \\Expl{ Deleted slots slow down searching and limit table capacity as\n                        there must be at least one Empty slot for searching. If\n                        some threshold is reached a new table can be allocated with\n                        all slots Empty then all keys in the old table can be\n                        inserted into the new table and the old table discarded.\n                \\Expl}\n        \\Code}\n\n\n        \\Code{\n            Hash1\n                i <- (k * BIGPRIME) mod TableSize \\B 5\n                \\Expl{ BIGPRIME much bigger than TableSize (which is also prime).\n                The object is to spread the values across the hash table as widely as possible.\n                    Here we use BIGPRIME = 3457\n                \\Expl}\n        \\Code}\n';const Lo=ho(Ro+"\n\n\n        \\Code{\n            SetIncrement\n                Increment <- (k * BIGPRIME2) mod SMALLISHPRIME + 1 \\B 6\n                \\Expl{Double hashing resolves collisions by hashing the key k a second time to set the increment\n                    to find the next empty slot in the table R. The value given by the function must be non-zero\n                    and must also be relatively prime to the table size.\n                    Here BIGPRIME2 is 1429 and SMALLISHPRIME is 3 or 23, depending on the table size selected.\n                \\Expl}\n        \\Code}\n"),Do=ho(Ro+"\n\n\n        \\Code{\n            SetIncrement\n            Increment <- 1 \\B 6\n            \\Expl{ For linear probing, if we have a collision we successively look at the\n                    next table entry.\n            \\Expl}\n        \\Code}\n\n");let Po='\n    \\Code{\n        Main\n        HashSearch(T, k)  // Search for key k in table T \\B 1\n        \\In{\n            i <- hash(k) \\Ref Hash1\n            Choose Increment value for stepping through T \\Ref SetIncrement\n            while not (T[i] = k or T[i] = Empty) // search for T or Empty \\B 4\n                \\In{\n                    i <- (i + Increment) mod TableSize \\B 5\n                    \\Expl{ T[i] is not k or Empty so we jump ahead Increment\n                        steps and "wrapping around" if we reach the end, mirroring\n                        the insertion code.\n                    \\Expl}\n                 \\In}\n            if T[i] = k \\B 6\n                \\{In\n                return i // return the table index where the key has been found \\B 7\n                \\In}\n            else\n                \\{In\n                return NOTFOUND \\B 8\n                \\In}\n        \\In}\n    \\Code}\n\n    \\Code{\n        Hash1\n            i <- (k * BIGPRIME) mod TableSize \\B 2\n            \\Expl{ BIGPRIME much bigger than TableSize (which is also prime).\n                The object is to spread the values across the hash table as widely as possible.\n                    Here we use BIGPRIME = 3457\n            \\Expl}\n    \\Code}\n';const Fo=ho(Po+"\n\n\n        \\Code{\n            SetIncrement\n                Increment <- (k * BIGPRIME2) mod SMALLISHPRIME + 1 \\B 3\n                \\Expl{Double hashing resolves collisions by hashing the key k a second time to set the increment\n                    to find the next empty slot in the table R. The value given by the function must be non-zero\n                    and must also be relatively prime to the table size.\n                    Here BIGPRIME2 is 1429 and SMALLISHPRIME is 3 or 23, depending on the table size selected.\n                \\Expl}\n        \\Code}\n"),Ho=ho(Po+"\n\n\n    \\Code{\n        SetIncrement\n            Increment <- 1 \\B 3\n            \\Expl{ For linear probing, if we have a collision we successively look at the\n                    next table entry.\n            \\Expl}\n    \\Code}\n"),_o="CODE",Go="INSERT",Vo="PLAY",zo="FORWARD",Qo="SEARCH",Uo="SORT",Wo="START",qo=[{title:"Insert Mode",content:["Click on ".concat(_o," on the right panel"),"Enter a list of nodes in the insert parameter.","Click on ".concat(Go," to enter insert mode and load the algorithm."),"Click on ".concat(Vo," to watch the algorithm run.")]},{title:"Search Mode",content:["Click on ".concat(_o," on the right panel"),"Enter a node in the search parameter.","Click on ".concat(Qo," to enter search mode and load the algorithm."),"Click on ".concat(Vo," to watch the algorithm run.")]}],Xo=[{title:"Searching Strings",content:["Click on ".concat(_o," on the right panel"),"Enter a string to search followed by a string to search for, seperated by a comma","Click on ".concat("FIND STRING"," to load the algorithm."),"Click on ".concat(Vo," to watch the algorithm run.")]}],Yo=[{title:"Insert Mode",content:["Click on ".concat(_o," on the right panel."),"Enter a list of Integers in the Insert parameter.","Click on ".concat(Go," to enter Insert mode and load the algorithm."),"Click on ".concat(Vo," to watch the algorithm run.")]},{title:"Search Mode",content:["Make sure table has inserted values before searching.","Click on ".concat(_o," on the right panel."),"Enter an Integer in the Search parameter.","Click on ".concat(Qo," to enter Search mode and load the algorithm."),"Click on ".concat(Vo," to watch the algorithm run.")]}],Ko=[{title:"Sorting Numbers",content:["Click on ".concat(_o," on the right panel"),"Enter a list of numbers in the sort parameter.","Click on ".concat(Uo," to load the algorithm."),"Click on ".concat(Vo," to watch the algorithm run.")]}],Zo=[{title:"To Run Animation",content:["Click on ".concat(_o," at the top of the right-hand panel"),"Either step through the algorithm (click on ".concat(zo,") or play continuously (click on ").concat(Vo,"). Code and animation will follow in lockstep."),"The graph can be chosen (see below; default Graph 1 is shown initially)","Athoer algorithm parameters can be chosen below the\n".concat("PROGRESS"," bar; this will reset the animation to the start"),'Screen layout can be altered (depending on your browser/platform):\nthe left panel can be rendered invisible by clicking\non the arrow in its middle, the right and bottom panels can be enlarged or shrunk by dragging the ellipsis ("..."), and you can zoom in/out and drag elements in the animation panel']},{title:"To Choose Graph",content:['The graph input panel is at the bottom and may need to be revealed\nby dragging the "..." up temporarily',"Under the ".concat(Vo," button, toggle between sample graphs (eg Graph 1) and random graphs, or"),"edit text for X-Y node coordinates (this can change the graph size) and edges/weights (weights are ignored for unweighted graph algorithms), or","enter X-Y node coordinates and edges/weights in tables below, or","change X-Y node coordinates by selecting a node with the mouse and dragging it.","The graph size can also be explicitly increased/decreased - this generates a new random graph.","Edge weights (for weighted graph algorithms) can be toggled between Euclidean, Manhattan and as defined explicitly in the input."]}],Jo=qo,$o=Ko,el=Ko,tl=Ko,nl=Ko,al=[{title:"Create Graph ",content:["Click on ".concat(_o," on the right panel"),"Enter a graph in the transition matrix","Click on ".concat(Wo," to load the algorithm."),"Click on ".concat(Vo," to watch the algorithm run."),"All nodes are SELF-REACHABLE => All diagonal elements are ones and NOT allowed to be edited."]}],rl=Zo,il=Zo,sl=Zo,ol=Xo,ll=Xo,dl=[{title:" ",content:["Open the right ".concat(_o," panel to view the algorithm code as it runs."),"Use the panel in the lower centre of the screen to control the algorithm visualisation:","Select nodes to union by entering a list of union operations in the left input box and click ".concat("UNION","."),"Click ".concat("ON"," or ").concat("OFF"," to toggle path compression."),"Click on ".concat(Vo,", ").concat("PAUSE",", or the ").concat("BACK"," and ").concat(zo," arrows to watch the algorithm run."),"Enter a node in the right input box and click ".concat("FIND"," and then ").concat(Vo," to search for the node's set representative.")]}],cl=qo,hl=Zo,ul=Zo,pl=Zo,gl=Zo,ml=Zo,fl=Yo,bl={heapSort:{name:"Heapsort",category:"Sort",explanation:x,param:Object(c.jsx)(Te,{}),instructions:$o,extraInfo:zn,pseudocode:{sort:go},controller:{sort:vr}},quickSort:{name:"Quicksort",category:"Sort",explanation:j,param:Object(c.jsx)(Xe,{}),instructions:el,extraInfo:Un,pseudocode:{sort:mo},controller:{sort:gi}},quickSortM3:{name:"Quicksort (Median of 3)",category:"Sort",explanation:S,param:Object(c.jsx)(Vt,{}),instructions:el,extraInfo:$n,pseudocode:{sort:jo},controller:{sort:mi}},msort_arr_td:{name:"Merge Sort",noDeploy:!1,category:"Sort",explanation:w,param:Object(c.jsx)($e,{}),instructions:tl,extraInfo:Wn,pseudocode:{sort:fo},controller:{sort:fi}},msort_lista_td:{name:"Merge Sort (lists)",category:"Sort",explanation:E,param:Object(c.jsx)(rt,{}),instructions:nl,extraInfo:qn,pseudocode:{sort:bo},controller:{sort:Ei}},binarySearchTree:{noDeploy:!1,name:"Binary Search Tree",category:"Insert/Search",param:Object(c.jsx)(ze,{}),instructions:Jo,explanation:v,extraInfo:Qn,pseudocode:{insertion:po,search:uo},controller:{insertion:yr,search:ca}},TTFTree:{name:"2-3-4 Tree",category:"Insert/Search",param:Object(c.jsx)(tn,{}),instructions:cl,explanation:T,extraInfo:na,pseudocode:{insertion:Oo,search:Io},controller:{insertion:Es,search:ws}},HashingLP:{name:"Hashing (Linear probing)",category:"Insert/Search",param:Object(c.jsx)(Dn,{}),instructions:fl,explanation:H,extraInfo:la,pseudocode:{insertion:Do,search:Ho},controller:{insertion:$s,search:oo}},HashingDH:{name:"Hashing (Double hashing)",category:"Insert/Search",param:Object(c.jsx)(Vn,{}),instructions:fl,explanation:H,extraInfo:da,pseudocode:{insertion:Lo,search:Fo},controller:{insertion:$s,search:oo}},DFSrec:{name:"Depth First Search",category:"Graph",param:Object(c.jsx)(bn,{}),instructions:ml,explanation:F,extraInfo:oa,pseudocode:{find:To},controller:{find:Hs}},DFS:{name:"DFS (iterative)",category:"Graph",param:Object(c.jsx)(gn,{}),instructions:gl,explanation:P,extraInfo:sa,pseudocode:{find:Bo},controller:{find:Fs}},BFS:{name:"Breadth First Search",category:"Graph",param:Object(c.jsx)(hn,{}),instructions:pl,explanation:D,extraInfo:ia,pseudocode:{find:Mo},controller:{find:Ps}},dijkstra:{name:"Dijkstra's (shortest path)",category:"Graph",param:Object(c.jsx)(rn,{}),instructions:hl,explanation:R,extraInfo:aa,pseudocode:{find:Co},controller:{find:Ls}},aStar:{name:"A* (heuristic search)",category:"Graph",param:Object(c.jsx)(ln,{}),instructions:ul,explanation:L,extraInfo:ra,pseudocode:{find:So},controller:{find:Ds}},prim:{noDeploy:!1,name:"Prim's (min. spanning tree)",category:"Graph",explanation:N,param:Object(c.jsx)(It,{}),instructions:il,extraInfo:Yn,pseudocode:{find:xo},controller:{find:Gs}},prim_old:{noDeploy:!1,name:"Prim's (simpler code)",category:"Graph",explanation:k,param:Object(c.jsx)(Nt,{}),instructions:rl,extraInfo:Xn,pseudocode:{find:Ao},controller:{find:_s}},kruskal:{noDeploy:!1,name:"Kruskal's (min. spanning tree)",category:"Graph",explanation:O,param:Object(c.jsx)(St,{}),instructions:sl,extraInfo:Kn,pseudocode:{find:vo},controller:{find:Vs}},transitiveClosure:{name:"Warshall's (transitive closure)",category:"Graph",explanation:I,param:Object(c.jsx)(Tt,{}),instructions:al,extraInfo:Zn,pseudocode:{tc:yo},controller:{tc:zi}},unionFind:{name:"Union Find",category:"Set",param:Object(c.jsx)(Kt,{}),instructions:dl,explanation:B,extraInfo:ta,pseudocode:{union:ko,find:No},controller:{union:js,find:ms}},bruteForceStringSearch:{noDeploy:!1,name:"Brute Force",category:"String Search",explanation:C,param:Object(c.jsx)(Pt,{}),instructions:ol,extraInfo:Jn,pseudocode:{search:wo},controller:{search:Ji}},horspoolStringSearch:{noDeploy:!1,name:"Horspool's",category:"String Search",explanation:M,param:Object(c.jsx)(zt,{}),instructions:ll,extraInfo:ea,pseudocode:{search:Eo},controller:{search:ss}}},yl=Object.fromEntries(Object.entries(bl).filter((e=>!e[1].noDeploy))),Al=e=>Object.keys(yl[e].pseudocode)[0],xl=()=>{const e=[];let t=0;for(const[n,a]of Object.entries(yl))e.push({name:a.name,shorthand:n,id:t,mode:Al(n)}),t+=1;return e};var vl=yl;const jl=(()=>{const e=[];let t=0;for(const[n,a]of Object.entries(yl))e.some((e=>e.category===a.category))||(e.push({category:a.category,id:t,algorithms:[]}),t+=1);for(const[n,a]of Object.entries(yl)){e.find((e=>e.category===a.category)).algorithms.push({name:a.name,shorthand:n,mode:Al(n)})}return e})(),wl=xl(),El=xl().length,kl=n(238)();function Nl(e,t){const n=t||[];return e?t=>e(t,...n):()=>{}}function Ol(e,t){for(const n of Object.keys(t))for(let a=0;a<t[n].length;a+=1)if(t[n][a].bookmark===e)return n;throw new Error("Cannot find bookmark ".concat(e))}function Il(e,t){if("Main"===e)return["Main"];for(const n of Object.keys(t))for(let a=0;a<t[n].length;a+=1)if(void 0!==Object.prototype.hasOwnProperty.call(t[n][a],"ref")&&t[n][a].ref===e)return Il(n,t).concat([e]);return[e]}function Cl(e){const t={};for(const n of Object.keys(e))t[n]="Main"===n;return t}function Sl(e){const t={};for(const n of Object.keys(e)){const a={};for(const t of Object.keys(e[n].pseudocode))a[t]=Cl(e[n].pseudocode[t]);t[n]=a}return t}function Ml(e){let t=0;for(const n of Object.keys(e))for(const a of e[n])a.explanation.length>0&&(a.lineExplanButton={id:t,state:!1},t+=1)}const Bl={LOAD_ALGORITHM:(e,t)=>{const n=vl[t.name],{param:a,name:r,explanation:i,extraInfo:s,pseudocode:o,instructions:l}=n,d=o[t.mode];return Ml(d),{id:t,name:r,explanation:i,instructions:l,extraInfo:s,param:a,pseudocode:d,collapse:void 0===e||void 0===e.collapse?Sl(vl):e.collapse,lineExplanation:""}},RUN_ALGORITHM:(e,t)=>{const n=vl[t.name],{param:a,controller:r,name:i,explanation:s,extraInfo:o,pseudocode:l,instructions:d}=n,c=l[t.mode];Ml(c);const h=new class{constructor(e){this.chunks=[],this.visualisers={},this.init=e,this.currentChunk=null}add(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,r="",i=!1;"object"===typeof e?(r=e.bookmark,i=e.pauseInCollapse):r=e,this.chunks.push({bookmark:String(r),mutator:Nl(t,kl(n)),pauseInCollapse:i,recursionLevel:a})}isValidChunk(e){return e>=0&&e<=this.chunks.length}getVisualisers(){return Object.values(this.visualisers).sort(((e,t)=>e.order-t.order)).map((e=>e.instance))}doChunk(e){this.chunks[e].mutator(Object.fromEntries(Object.entries(this.visualisers).map((e=>{let[t,n]=e;return[t,n.instance]}))))}checkChunkPause(){let e=-1;return null===this.currentChunk?e=0:(this.currentChunk>=0&&this.currentChunk<=this.chunks.length-2||this.currentChunk===this.chunks.length-1)&&(e=this.currentChunk+1),-1!==e&&!!this.chunks[e]&&this.chunks[e].pauseInCollapse}next(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const t=this.checkChunkPause();return t?e||(this.doChunk(this.currentChunk+1),this.currentChunk+=1):null===this.currentChunk?(this.visualisers=this.init(),this.doChunk(0),this.currentChunk=0):this.currentChunk>=0&&this.currentChunk<=this.chunks.length-2?(this.doChunk(this.currentChunk+1),this.currentChunk+=1):this.currentChunk===this.chunks.length-1&&(this.currentChunk+=1),this.currentChunk<this.chunks.length?{bookmark:this.chunks[this.currentChunk].bookmark,finished:!1,pauseInCollapse:t}:{bookmark:this.chunks[this.currentChunk-1].bookmark,finished:!0,pauseInCollapse:t}}prevChunk(e){const t=e>0?e-1:0;return{bookmark:this.chunks[t].bookmark,chunk:t}}goBackTo(e){this._inPrevState=!0,this.visualisers=this.init();for(let t=0;t<=e;t+=1)this.doChunk(t);return this.currentChunk=e,this._inPrevState=!1,{bookmark:this.chunks[this.currentChunk].bookmark,finished:!1}}refresh(){this.currentChunk>=this.chunks.length-1&&(this.currentChunk=this.chunks.length-1),this.visualisers=this.init();for(let e=0;e<=this.currentChunk;e+=1)this.doChunk(e)}}((()=>r[t.mode].initVisualisers(t)));r[t.mode].run(h,t);const u=h.next();return{...e,id:t,name:i,explanation:s,extraInfo:o,instructions:d,param:a,pseudocode:c,...u,chunker:h,visualisers:h.visualisers,collapse:void 0===e||void 0===e.collapse?Sl(vl):e.collapse,playing:!1,lineExplanation:null}},NEXT_LINE:(e,t)=>{let n,a=!1;"object"===typeof t&&(a=t.triggerPauseInCollapse,t=t.playing);let r=function(e,t,n,a){if(t>=e.length-1)return t;let r=e[t+=1].bookmark,i=Ol(r,n);if(a[i])return t;let s=e[t].recursionLevel,o=Il(i,n),l=o.findIndex(((e,t,n)=>!a[e])),d=o[l];do{if(t>=e.length-1)return e.length-1;r=e[t+=1].bookmark,i=Ol(r,n),o=Il(i,n)}while(e[t].recursionLevel>s||o.includes(d));return t-1}(e.chunker.chunks,e.chunker.currentChunk,e.pseudocode,e.collapse[e.id.name][e.id.mode]);do{n=e.chunker.next(a),a||(n.pauseInCollapse=!1)}while(!n.pauseInCollapse&&!n.finished&&e.chunker.currentChunk<r);return e.chunker.currentChunk===e.chunker.chunks.length-1&&(e.chunker.currentChunk+=1,n.finished=!0),{...e,...n,playing:t}},PREV_LINE:(e,t)=>{e.chunker.currentChunk>e.chunker.chunks.length&&(e.chunker.currentChunk=e.chunker.chunks.length-1);let n=function(e,t,n,a){if(t<=0)return 0;t>=e.length&&(t=e.length-1);let r=e[t].recursionLevel,i=e[t].bookmark,s=Ol(i,n);if(a[s])return t-1;let o=Il(s,n),l=o.findIndex(((e,t,n)=>!a[e])),d=o[l];do{if(t<=0)return 0;i=e[t-=1].bookmark,s=Ol(i,n),o=Il(s,n)}while(e[t].recursionLevel>r||o.includes(d));return t}(e.chunker.chunks,e.chunker.currentChunk,e.pseudocode,e.collapse[e.id.name][e.id.mode]);e.chunker.currentChunk;const a=e.chunker.goBackTo(n);return{...e,...a,playing:t}},TOGGLE_PLAY:(e,t)=>({...e,playing:t}),COLLAPSE:(e,t)=>{let{codeblockname:n,expandOrCollapase:a}=t;const r=e.collapse;return r[e.id.name][e.id.mode][n]=void 0===a?!r[e.id.name][e.id.mode][n]:!!a,function(e){const t=Ll().id.name;if(!Tl.includes(t))return;e.refresh()}(e.chunker),function(){if(!Ti())return!1;Fi(!Ri()),Bi().chunker.refresh()}(),function(e){if(!e||"unionFind"!=e.id.name)return;let t=e.chunker.visualisers,n=e.collapse.unionFind.union.Maybe_swap||e.collapse.unionFind.union.Adjust_rank;t.array.instance.hideArrayAtIndex(n?null:2),vs=n}(e),{...e,collapse:r}},LineExplan:(e,t)=>({...e,lineExplanation:t})};const Tl=["quickSort","quickSortM3","msort_arr_td","transitiveClosure","heapSort","msort_lista_td"];let Rl=()=>null;function Ll(){return Rl()}function Dl(e){const t=Ll(),n=t.id.name,{bookmark:a,pseudocode:r,collapse:i}=t;return e.reduce(((e,t)=>e&&i[n].sort[t]),!0)}window.getGlobalAlgorithm=Ll;const Pl=Object(a.createContext)(),Fl=function(){const e=new URL(window.location.href).search.substring(1).split(";").map((e=>e.split("="))),t=e.find((e=>"alg"===e[0])),n=t?t[1]:void 0,a=e.find((e=>"mode"===e[0])),r=a?a[1]:void 0;return n&&r&&n in vl&&r in vl[n].pseudocode?Bl.LOAD_ALGORITHM(void 0,{name:n,mode:r}):Bl.LOAD_ALGORITHM(void 0,{name:"heapSort",mode:"sort"})}(),Hl=e=>{let{children:t}=e;const[n,r]=Object(a.useState)(Fl),i=function(e,t){return(n,a)=>{t(n(e,a))}}(n,r),s={algorithm:n,dispatch:i};return Rl=()=>s.algorithm,function(e,t){Si=e,Mi=t}((()=>s.algorithm)),Object(c.jsx)(Pl.Provider,{value:s,children:t})};n(169);var _l=n(395),Gl=n(386),Vl=n(398),zl=n(207),Ql=n(392),Ul=n(384);var Wl=function(e){let{value:t,onChange:n}=e;const[r,i]=Object(a.useState)(0),s=Object(zl.a)({palette:{primary:{main:"#027AFF"}}}),o="42px",l=Object(Ul.a)((()=>({tabsRoot:{minHeight:o,height:o,width:"100%"},tabRoot:{minHeight:o,height:o,width:"30px"}})))();return Object(c.jsx)(c.Fragment,{children:Object(c.jsx)(Ql.a,{theme:s,children:Object(c.jsx)(_l.a,{square:!0,elevation:0,className:"rightPanelButtons",children:Object(c.jsx)(Gl.a,{value:r,onChange:(e,t)=>{i(t),n(t)},variant:"scrollable",scrollButtons:"auto",indicatorColor:"primary",textColor:"primary","aria-label":"tabs button",classes:{root:l.tabsRoot},children:t.map((e=>Object(c.jsx)(Vl.a,{label:e.label,disableRipple:!0,value:e.id,classes:{root:l.tabRoot}},e.id)))})})})})},ql=n(56),Xl=n.n(ql),Yl=n(57),Kl=n.n(Yl);const Zl=n(1),Jl=window.hljs;class $l extends Zl.PureComponent{constructor(e){super(e),this.setRef=this.setRef.bind(this)}componentDidMount(){this.highlightCode()}componentDidUpdate(){this.highlightCode()}setRef(e){this.codeEl=e}highlightCode(){Jl.highlightBlock(this.codeEl)}render(){return Object(c.jsx)("pre",{children:Object(c.jsx)("code",{ref:this.setRef,className:"language-".concat(this.props.language),children:this.props.value})})}}$l.defaultProps={language:""};var ed=$l;var td,nd,ad,rd,id,sd,od,ld,dd,cd,hd,ud,pd,gd,md,fd,bd=function(e){let{fontSize:t,fontSizeIncrement:n}=e;const{algorithm:r}=Object(a.useContext)(Pl),[i,s]=Object(a.useState)(""),o="textAreaExplanation";return Object(a.useEffect)((()=>{fetch(r.explanation).then((e=>e.text())).then((e=>s(e))),Ta(o,t),Ba(o,n)}),[r.explanation,n,t]),Object(c.jsx)("div",{className:"textArea",id:o,children:Object(c.jsx)(Xl.a,{source:i,escapeHtml:!1,renderers:{code:ed},plugins:[Kl.a]})})},yd=n(204),Ad=n.n(yd),xd=n(203),vd=n.n(xd),jd=n(137),wd=n.n(jd);n(330);function Ed(){return Ed=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e},Ed.apply(this,arguments)}function kd(e,t){let{title:n,titleId:r,...i}=e;return a.createElement("svg",Ed({id:"Capa_1",xmlns:"http://www.w3.org/2000/svg",xmlnsXlink:"http://www.w3.org/1999/xlink",x:"0px",y:"0px",viewBox:"0 0 512.001 512.001",style:{enableBackground:"new 0 0 512.001 512.001"},xmlSpace:"preserve",ref:t,"aria-labelledby":r},i),n?a.createElement("title",{id:r},n):null,td||(td=a.createElement("g",null,a.createElement("g",null,a.createElement("path",{d:"M284.286,256.002L506.143,34.144c7.811-7.811,7.811-20.475,0-28.285c-7.811-7.81-20.475-7.811-28.285,0L256,227.717 L34.143,5.859c-7.811-7.811-20.475-7.811-28.285,0c-7.81,7.811-7.811,20.475,0,28.285l221.857,221.857L5.858,477.859 c-7.811,7.811-7.811,20.475,0,28.285c3.905,3.905,9.024,5.857,14.143,5.857c5.119,0,10.237-1.952,14.143-5.857L256,284.287 l221.857,221.857c3.905,3.905,9.024,5.857,14.143,5.857s10.237-1.952,14.143-5.857c7.811-7.811,7.811-20.475,0-28.285 L284.286,256.002z"})))),nd||(nd=a.createElement("g",null)),ad||(ad=a.createElement("g",null)),rd||(rd=a.createElement("g",null)),id||(id=a.createElement("g",null)),sd||(sd=a.createElement("g",null)),od||(od=a.createElement("g",null)),ld||(ld=a.createElement("g",null)),dd||(dd=a.createElement("g",null)),cd||(cd=a.createElement("g",null)),hd||(hd=a.createElement("g",null)),ud||(ud=a.createElement("g",null)),pd||(pd=a.createElement("g",null)),gd||(gd=a.createElement("g",null)),md||(md=a.createElement("g",null)),fd||(fd=a.createElement("g",null)))}const Nd=a.forwardRef(kd);n.p;var Od=function(e){let{explanation:t,fontSize:n,fontSizeIncrement:r}=e;const{dispatch:i}=Object(a.useContext)(Pl),s="lineExplanation";return Object(a.useEffect)((()=>{Ta(s,n),Ba(s,r)}),[r,n]),Object(c.jsxs)("div",{className:"lineExplanation",id:s,children:[Object(c.jsxs)("div",{className:"lEHeader",children:[Object(c.jsx)("div",{className:"lEtitle",children:"Explanation"}),Object(c.jsx)(ve,{icon:Object(c.jsx)(Nd,{}),className:"greyRoundBtn",id:"cancelLineExplainBtn",onClick:()=>{i(Bl.LineExplan,"")}})]}),Object(c.jsx)("div",{className:"lEDesc",children:t})]})};const Id={keyword:["for","while","if","else","in","each","do","repeat","until","Empty","Locate","of","not","downto","and","or","return","NotFound"],operator:["<",">","+","-"],arrow:["<-"]};function Cd(e,t){for(const n of e.pseudocode[t]){if(void 0!==n.bookmark&&n.bookmark===e.bookmark||n.ref&&Cd(e,n.ref,e.bookmark))return"Quicksort"===e.name&&n.bookmark&&5===parseInt(n.bookmark,10)&&(sessionStorage.setItem("isPivot",!0),sessionStorage.setItem("quicksortPlay",!0)),!0;if(void 0!==n.bookmark&&"Quicksort"===e.name&&"5"===e.bookmark&&"13"===n.bookmark)return sessionStorage.setItem("isPivot",!0),sessionStorage.setItem("quicksortPlay",!0),!1}return!1}function Sd(e){let t,n;const a=[];let r=0;for(n of e){let i=!0,s=0;r++;const o=e.length;for(const e of Object.keys(Id))if(Id[e].includes(n.trim())){s<o-1&&(n+="\xa0"),t=Object(c.jsx)("span",{className:e,children:n},r),a.push(t),i=!1;break}if(i)if(-1!==n.indexOf("(")){let e=n;for(;-1!==e.indexOf("(");){r++;const n=e.substring(0,e.indexOf("("));t=Object(c.jsx)("span",{className:"function",children:n},r),a.push(t),r++,t=Object(c.jsx)("span",{children:"("},r),a.push(t);const i=e.substring(e.indexOf("(")+1);e=i}s<o-1&&(e+="\xa0"),r++,t=Object(c.jsx)("span",{children:e},r),a.push(t)}else s<o-1&&(n+="\xa0"),r++,t=Object(c.jsx)("span",{children:n},r),a.push(t);s+=1}return a}function Md(e,t){if(t){let n=[t];const a=e.pseudocode[t];for(let t=0;t<a.length;t++){const r=Md(e,a[t].ref);r&&(n=n.concat(r))}return n}return null}function Bd(e,t,n,a){let r=a,i=[];for(const s of e.pseudocode[n]){r+=1;const a=s.code.indexOf("//");let o=[];if(-1===a)if(s.ref&&e.collapse[e.id.name][e.id.mode][s.ref]){const e=Object(c.jsx)("span",{className:"explanation",children:"//".concat(s.code)},0);o.push(e)}else{o=[...Sd(s.code.split(" "))]}else if(0===a){const e=Object(c.jsx)("span",{className:"explanation",children:s.code},0);o.push(e)}else{o=[...Sd(s.code.substring(0,a).split(" "))];const e=s.code.substring(a),t=Object(c.jsx)("span",{className:"explanation",children:e},0);o.push(t)}let l=null;if(e.collapse[e.id.name][e.id.mode][n]&&void 0!==s.lineExplanButton&&(l=Object(c.jsx)("button",{id:"buttonexpl"+r,className:s.explanation===e.lineExplanation?"line-explanation-button-active":"line-explanation-button-negative",onClick:()=>{t(Bl.LineExplan,s.explanation)},children:Object(c.jsx)(wd.a,{style:{color:"#f7c679",fontSize:"small"}})})),s.ref){if(i.push(Object(c.jsxs)("p",{className:!e.collapse[e.id.name][e.id.mode][s.ref]&&Cd(e,s.ref)?"active":"",role:"presentation",children:[Object(c.jsx)("span",{children:r}),Object(c.jsx)("span",{children:Object(c.jsx)("button",{className:e.collapse[e.id.name][e.id.mode][s.ref]?"expand-collapse-button-active":"expand-collopse-button",onClick:()=>{if(e.collapse[e.id.name][e.id.mode][s.ref]){const n=Md(e,s.ref);for(let e=0;e<n.length;e++)t(Bl.COLLAPSE,{codeblockname:n[e],expandOrCollapase:!1})}else t(Bl.COLLAPSE,{codeblockname:s.ref})},children:e.collapse[e.id.name][e.id.mode][s.ref]?Object(c.jsx)(vd.a,{style:{fontSize:12}}):Object(c.jsx)(Ad.a,{style:{fontSize:12}})})}),Object(c.jsx)("span",{id:void 0!==s.bookmark&&e.bookmark===s.bookmark?"activebtn":"",children:l}),o]},r)),e.collapse[e.id.name][e.id.mode][s.ref]){const n=Bd(e,t,s.ref,r);r=n.index,i=i.concat(n.cl)}}else i.push(Object(c.jsxs)("p",{className:void 0!==s.bookmark&&e.bookmark===s.bookmark?"active":"",role:"presentation",children:[Object(c.jsx)("span",{children:r}),Object(c.jsx)("span",{children:null}),Object(c.jsx)("span",{id:void 0!==s.bookmark&&e.bookmark===s.bookmark?"activebtn":"",children:l}),o]},r))}return{index:r,cl:i}}var Td=e=>{let{fontSize:t,fontSizeIncrement:n}=e;const{algorithm:r,dispatch:i}=Object(a.useContext)(Pl),s="code-container";Object(a.useEffect)((()=>{Ta(s,t),Ba(s,n)}),[n,t]);const{index:o,cl:l}=Bd(r,i,"Main",0),d=((e,t)=>{const n=[];for(let a=e;a<e+t;a++)n.push(Object(c.jsx)("p",{role:"presentation",children:Object(c.jsx)("span",{children:a})},a));return n})(o+1,2);return Object(c.jsxs)("div",{className:"line-light",children:[Object(c.jsx)("link",{href:"https://fonts.googleapis.com/css2?family=Inter:wght@300&display=swap",rel:"stylesheet"}),Object(c.jsxs)("div",{className:"code-container",id:s,children:[l,d]}),r.lineExplanation?Object(c.jsx)(Od,{explanation:r.lineExplanation,fontSize:t,fontSizeIncrement:n}):""]})};var Rd=function(e){let{onClick:t,name:n}=e;return Object(c.jsx)("button",{className:"bottomBtn",type:"button",onClick:t,children:n})};var Ld=function(e){let{fontSize:t,fontSizeIncrement:n}=e;const{algorithm:r,dispatch:i}=Object(a.useContext)(Pl);return!!r.hasOwnProperty("pseudocode")?Object(c.jsxs)(c.Fragment,{children:[Object(c.jsx)(Td,{fontSize:t,fontSizeIncrement:n}),Object(c.jsxs)("div",{className:"btnPanel",children:[Object(c.jsx)(Rd,{onClick:()=>{Object.keys(r.pseudocode).forEach((e=>{i(Bl.COLLAPSE,{codeblockname:e,expandOrCollapase:!0})}))},name:"Expand All"}),Object(c.jsx)(Rd,{onClick:()=>{Object.keys(r.pseudocode).forEach((e=>{"Main"!==e&&i(Bl.COLLAPSE,{codeblockname:e,expandOrCollapase:!1})}))},name:"Collapse All"})]}),""]}):null};var Dd=function(e){let{fontSize:t,fontSizeIncrement:n}=e;const{algorithm:r}=Object(a.useContext)(Pl),[i,s]=Object(a.useState)(""),o="textAreaExtra";return Object(a.useEffect)((()=>{fetch(r.extraInfo).then((e=>e.text())).then((e=>s(e))),Ta(o,t),Ba(o,n)}),[r.extraInfo,t,n]),Object(c.jsx)("div",{className:"textArea",id:o,children:Object(c.jsx)(Xl.a,{source:i,escapeHtml:!1,renderers:{code:ed},plugins:[Kl.a]})})};var Pd=function(e){let{fontSize:t,fontSizeIncrement:n}=e;const{algorithm:r}=Object(a.useContext)(Pl),[i,s]=Object(a.useState)(""),o="textAreaExplanation";return Object(a.useEffect)((()=>{for(var e="# Instructions \n\n\n",a=0;a<r.instructions.length;a++){e=e+"## "+r.instructions[a].title+"\n\n\n";for(var i=0;i<r.instructions[a].content.length;i++)e=e+(i+1)+".\t"+r.instructions[a].content[i]+"\n\n"}s(e),Ta(o,t),Ba(o,n)}),[r.instructions,n,t]),Object(c.jsx)("div",{className:"textArea",id:o,children:Object(c.jsx)(Xl.a,{source:i,escapeHtml:!1,renderers:{code:ed},plugins:[Kl.a]})})};var Fd=function(e){let{fontSize:t,fontSizeIncrement:n}=e;const a=[{id:0,label:"Code",display:Object(c.jsx)(Ld,{fontSize:t,fontSizeIncrement:n})},{id:1,label:"Background",display:Object(c.jsx)(bd,{fontSize:t,fontSizeIncrement:n})},{id:2,label:"More",display:Object(c.jsx)(Dd,{fontSize:t,fontSizeIncrement:n})},{id:3,label:"Instructions",display:Object(c.jsx)(Pd,{fontSize:t,fontSizeIncrement:n})}],[i,s]=r.a.useState(0);return Object(c.jsxs)(c.Fragment,{children:[Object(c.jsx)(Wl,{value:a,onChange:e=>{s(e)}}),a[i].display]})};n(331);var Hd=function(e){let{fontSize:t,fontSizeIncrement:n}=e;const{dispatch:r,algorithm:i}=Object(a.useContext)(Pl),[s,o]=Object(a.useState)(null),l=Object(a.useRef)();Object(a.useEffect)((()=>{l.current||(jl.forEach(((e,t)=>{document.getElementById("category-".concat(t)).click()})),l.current=!0)}));const d="itemList",h="catList";Object(a.useEffect)((()=>{Ta(h,t),Ta(d,t)}),[t,n]);const u=["mousedown","click","mouseup"];let p=null;return Object(a.useEffect)((()=>{p()}),[p]),p=()=>{const e=document.getElementById("startBtnGrp");null!==e&&u.forEach((t=>e.dispatchEvent(new MouseEvent(t,{view:window,bubbles:!0,cancelable:!0,buttons:1}))))},Object(c.jsxs)("div",{className:"container",children:[Object(c.jsx)("span",{children:Object(c.jsx)("input",{className:"searchInput",placeholder:"Search...","data-testid":"searchInput",onChange:e=>{const t=e.target.value.trim().toLowerCase();let n=null;t.length>0&&(n=wl.filter((e=>e.name.toLowerCase().match(t)))),o(n)}})}),Object(c.jsx)("div",{className:"algorithmList",id:h,children:null===s?jl.map(((e,t)=>Object(c.jsxs)("div",{children:[Object(c.jsx)("button",{id:"category-".concat(t),className:"algoCat",type:"button",onClick:e=>{(e=>{const t=e.target.nextElementSibling;t.style.maxHeight?t.style.maxHeight=null:t.style.maxHeight="".concat(t.scrollHeight,"px")})(e)},children:e.category},e.id),Object(c.jsx)("div",{className:"algoItemContainer content",id:d,children:e.algorithms.map(((e,t)=>Object(c.jsx)("button",{className:i.name===e.name?"algoItem active":"algoItem",type:"button",id:"algo-".concat(e.name),onClick:i.name===e.name?()=>{document.getElementById("startBtnGrp")}:()=>{Ne(),r(Bl.LOAD_ALGORITHM,{name:e.shorthand,mode:e.mode})},children:Object(c.jsx)("div",{className:"algoItemContent",children:e.name},e.id)},t)))})]},e.id))):s.map((e=>Object(c.jsx)("button",{type:"button",className:i.name===e.name?"algoItem active":"algoItem",onClick:()=>{r(Bl.LOAD_ALGORITHM,{name:e.shorthand,mode:e.mode})},children:Object(c.jsx)("div",{className:"algoItemContent",children:e.name})},e.id)))})]})},_d=(n(332),n(138));var Gd=function(e){let{fontSize:t,fontSizeIncrement:n}=e;const{algorithm:r}=Object(a.useContext)(Pl),i="algorithmTitle",[s,o]=Object(a.useState)(!1),l=()=>o(!1),[d,h]=Object(a.useState)("");return Object(a.useEffect)((()=>{Ta(i,t),Ba(i,n)}),[t,n]),Object(a.useEffect)((()=>{let e="# Instructions \n\n\n";for(let t=0;t<r.instructions.length;t++){e="".concat(e,"## ").concat(r.instructions[t].title,"\n\n\n");for(let n=0;n<r.instructions[t].content.length;n++)e="".concat(e+(n+1),".\t").concat(r.instructions[t].content[n],"\n\n")}h(e)}),[r.instructions]),Object(c.jsxs)("div",{className:"midPanelContainer",children:[Object(c.jsxs)("div",{className:"midPanelHeader",children:[Object(c.jsxs)("div",{children:[Object(c.jsx)(ve,{icon:Object(c.jsx)(wd.a,{}),onClick:()=>o((e=>!e))}),Object(c.jsx)(_d.a,{open:s,closeOnDocumentClick:!0,onClose:l,children:Object(c.jsxs)("div",{className:"textArea",children:[Object(c.jsx)("a",{className:"close",onClick:l,children:"\xd7"}),Object(c.jsx)(Xl.a,{source:d,escapeHtml:!1,renderers:{code:ed},plugins:[Kl.a]})]})})]}),Object(c.jsx)("div",{className:"algorithmTitle",id:i,children:r.name})]}),Object(c.jsx)("div",{className:"midPanelBody",children:r.chunker&&r.chunker.getVisualisers().map((e=>e.render()))})]})},Vd=n(388),zd=n(393);n(333);var Qd=function(e){let{current:t,max:n}=e;const r={rectPrimary:document.querySelector(".mux-lpi-rect--primary"),buffer:document.querySelector(".mux-lpi-buffer")};function i(e,t){if(null!==e){const{style:n}=e;n.transform=t,n.WebkitTransform=t,n.MozTransform=t,n.OTransform=t,n.MSTransform=t}}return Object(a.useEffect)((()=>{var e,a;e=r.rectPrimary,a=parseFloat(t/n,10),i(e,"scaleX(".concat(a,")")),function(e,t){i(e,"scaleX(".concat(t,")"))}(r.buffer,1)}),[r,t,n]),Object(c.jsxs)("div",{role:"progressbar",className:"mux-lpi",children:[Object(c.jsx)("div",{className:"progressLable",id:"progressLabel",children:Object(c.jsx)("div",{className:"innerText",children:"Progress: ".concat(Math.round(t/n*100,2)," %")})}),Object(c.jsx)("div",{className:"mux-lpi-buffer"}),Object(c.jsx)("div",{className:"mux-lpi-rect mux-lpi-rect--primary",children:Object(c.jsx)("span",{className:"mux-lpi-rect-inner"})})]})};var Ud,Wd,qd,Xd,Yd,Kd,Zd,Jd,$d,ec,tc,nc,ac,rc,ic,sc,oc=function(e,t){const n=Object(a.useRef)();Object(a.useEffect)((()=>{n.current=e}),[e]),Object(a.useEffect)((()=>{if(null!==t){const e=setInterval((function(){n.current()}),t);return()=>clearInterval(e)}}),[t])};function lc(){return lc=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e},lc.apply(this,arguments)}function dc(e,t){let{title:n,titleId:r,...i}=e;return a.createElement("svg",lc({id:"Capa_1",xmlns:"http://www.w3.org/2000/svg",xmlnsXlink:"http://www.w3.org/1999/xlink",x:"0px",y:"0px",viewBox:"0 0 320.001 320.001",style:{enableBackground:"new 0 0 320.001 320.001"},xmlSpace:"preserve",ref:t,"aria-labelledby":r},i),n?a.createElement("title",{id:r},n):null,Ud||(Ud=a.createElement("path",{d:"M295.84,146.049l-256-144c-4.96-2.784-11.008-2.72-15.904,0.128C19.008,5.057,16,10.305,16,16.001v288 c0,5.696,3.008,10.944,7.936,13.824c2.496,1.44,5.28,2.176,8.064,2.176c2.688,0,5.408-0.672,7.84-2.048l256-144 c5.024-2.848,8.16-8.16,8.16-13.952S300.864,148.897,295.84,146.049z"})),Wd||(Wd=a.createElement("g",null)),qd||(qd=a.createElement("g",null)),Xd||(Xd=a.createElement("g",null)),Yd||(Yd=a.createElement("g",null)),Kd||(Kd=a.createElement("g",null)),Zd||(Zd=a.createElement("g",null)),Jd||(Jd=a.createElement("g",null)),$d||($d=a.createElement("g",null)),ec||(ec=a.createElement("g",null)),tc||(tc=a.createElement("g",null)),nc||(nc=a.createElement("g",null)),ac||(ac=a.createElement("g",null)),rc||(rc=a.createElement("g",null)),ic||(ic=a.createElement("g",null)),sc||(sc=a.createElement("g",null)))}const cc=a.forwardRef(dc);var hc,uc,pc,gc,mc,fc,bc,yc,Ac,xc,vc,jc,wc,Ec,kc,Nc,Oc;n.p;function Ic(){return Ic=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e},Ic.apply(this,arguments)}function Cc(e,t){let{title:n,titleId:r,...i}=e;return a.createElement("svg",Ic({id:"Capa_1",xmlns:"http://www.w3.org/2000/svg",xmlnsXlink:"http://www.w3.org/1999/xlink",x:"0px",y:"0px",viewBox:"0 0 477.867 477.867",style:{enableBackground:"new 0 0 477.867 477.867"},xmlSpace:"preserve",ref:t,"aria-labelledby":r},i),n?a.createElement("title",{id:r},n):null,hc||(hc=a.createElement("g",null,a.createElement("g",null,a.createElement("path",{d:"M187.733,0H51.2c-9.426,0-17.067,7.641-17.067,17.067V460.8c0,9.426,7.641,17.067,17.067,17.067h136.533 c9.426,0,17.067-7.641,17.067-17.067V17.067C204.8,7.641,197.159,0,187.733,0z"})))),uc||(uc=a.createElement("g",null,a.createElement("g",null,a.createElement("path",{d:"M426.667,0H290.133c-9.426,0-17.067,7.641-17.067,17.067V460.8c0,9.426,7.641,17.067,17.067,17.067h136.533 c9.426,0,17.067-7.641,17.067-17.067V17.067C443.733,7.641,436.092,0,426.667,0z"})))),pc||(pc=a.createElement("g",null)),gc||(gc=a.createElement("g",null)),mc||(mc=a.createElement("g",null)),fc||(fc=a.createElement("g",null)),bc||(bc=a.createElement("g",null)),yc||(yc=a.createElement("g",null)),Ac||(Ac=a.createElement("g",null)),xc||(xc=a.createElement("g",null)),vc||(vc=a.createElement("g",null)),jc||(jc=a.createElement("g",null)),wc||(wc=a.createElement("g",null)),Ec||(Ec=a.createElement("g",null)),kc||(kc=a.createElement("g",null)),Nc||(Nc=a.createElement("g",null)),Oc||(Oc=a.createElement("g",null)))}const Sc=a.forwardRef(Cc);var Mc,Bc,Tc,Rc,Lc,Dc,Pc,Fc,Hc,_c,Gc,Vc,zc,Qc,Uc,Wc;n.p;function qc(){return qc=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e},qc.apply(this,arguments)}function Xc(e,t){let{title:n,titleId:r,...i}=e;return a.createElement("svg",qc({id:"Capa_1",xmlns:"http://www.w3.org/2000/svg",xmlnsXlink:"http://www.w3.org/1999/xlink",x:"0px",y:"0px",viewBox:"0 0 512.171 512.171",style:{enableBackground:"new 0 0 512.171 512.171"},xmlSpace:"preserve",ref:t,"aria-labelledby":r},i),n?a.createElement("title",{id:r},n):null,Mc||(Mc=a.createElement("g",null,a.createElement("g",null,a.createElement("path",{d:"M479.046,283.925c-1.664-3.989-5.547-6.592-9.856-6.592H352.305V10.667C352.305,4.779,347.526,0,341.638,0H170.971 c-5.888,0-10.667,4.779-10.667,10.667v266.667H42.971c-4.309,0-8.192,2.603-9.856,6.571c-1.643,3.989-0.747,8.576,2.304,11.627 l212.8,213.504c2.005,2.005,4.715,3.136,7.552,3.136s5.547-1.131,7.552-3.115l213.419-213.504 C479.793,292.501,480.71,287.915,479.046,283.925z"})))),Bc||(Bc=a.createElement("g",null)),Tc||(Tc=a.createElement("g",null)),Rc||(Rc=a.createElement("g",null)),Lc||(Lc=a.createElement("g",null)),Dc||(Dc=a.createElement("g",null)),Pc||(Pc=a.createElement("g",null)),Fc||(Fc=a.createElement("g",null)),Hc||(Hc=a.createElement("g",null)),_c||(_c=a.createElement("g",null)),Gc||(Gc=a.createElement("g",null)),Vc||(Vc=a.createElement("g",null)),zc||(zc=a.createElement("g",null)),Qc||(Qc=a.createElement("g",null)),Uc||(Uc=a.createElement("g",null)),Wc||(Wc=a.createElement("g",null)))}const Yc=a.forwardRef(Xc);n.p,n(334),n(335);const Kc=Object(zl.a)({overrides:{MuiSlider:{thumb:{color:"#027AFF"},track:{color:"#3392FF"},rail:{color:"#B5B5B5"},mark:{color:"#F7F7F7"},markActive:{color:"#F7F7F7"}}}});var Zc=function(){const{algorithm:e,dispatch:t}=Object(a.useContext)(Pl),{chunker:n}=e,r=n?n.currentChunk:-1,i=n?n.chunks.length:-1,[s,o]=Object(a.useState)(50),[l,d]=Object(a.useState)(!1),[h,u]=Object(a.useState)(""),[p,g]=Object(a.useState)(!1),m=()=>g(!1),f=function(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];t(Bl.PREV_LINE,e)},b=function(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];t(Bl.NEXT_LINE,e)},y=()=>{t(Bl.TOGGLE_PLAY,!1),d(!1)},A=()=>{n&&n.isValidChunk(r+1)?(b(!0),d(!0)):y()},x=()=>{A(),"Quicksort"===e.name&&sessionStorage.setItem("quicksortPlay",!0)};Object(a.useEffect)((()=>{let t="# Instructions \n\n\n";for(let n=0;n<e.instructions.length;n++){t="".concat(t,"## ").concat(e.instructions[n].title,"\n\n\n");for(let a=0;a<e.instructions[n].content.length;a++)t="".concat(t+(a+1),".\t").concat(e.instructions[n].content[a],"\n\n")}u(t)}),[e.explanation,e.instructions]),oc((()=>{A()}),l?2e3-19*s:null);const v=(e,t)=>{o(t)};return Object(c.jsxs)("div",{className:"controlContainer",children:[Object(c.jsxs)("div",{className:"controlPanel",children:[Object(c.jsx)("div",{className:"rightControl",children:Object(c.jsxs)("div",{className:"controlButtons",children:[Object(c.jsx)(ve,{icon:Object(c.jsx)(Yc,{}),type:"prev",disabled:!(n&&n.isValidChunk(r-1)),onClick:()=>f()}),l?Object(c.jsx)(ve,{icon:Object(c.jsx)(Sc,{}),type:"pause",onClick:()=>y()}):Object(c.jsx)(ve,{icon:Object(c.jsx)(cc,{}),type:"play",disabled:!(n&&n.isValidChunk(r+1)),onClick:x}),Object(c.jsx)(ve,{icon:Object(c.jsx)(Yc,{}),type:"next",disabled:!(n&&n.isValidChunk(r+1)),onClick:()=>b()})]})}),Object(c.jsx)("div",{className:"speed",children:Object(c.jsx)("div",{className:"innerSpeed",children:"SPEED"})}),Object(c.jsx)("div",{className:"sliderContainer",children:Object(c.jsx)("div",{className:"slider",children:Object(c.jsx)(Ql.a,{theme:Kc,children:Object(c.jsx)(zd.a,{container:!0,spacing:2,children:Object(c.jsx)(zd.a,{item:!0,xs:!0,children:Object(c.jsx)(Vd.a,{value:s,onChange:v,"aria-labelledby":"continuous-slider"})})})})})}),Object(c.jsx)("div",{className:"prcessbar",children:Object(c.jsx)(Qd,{current:r,max:i})})]}),Object(c.jsx)("div",{className:"parameterPanel",children:e.param}),Object(c.jsx)("div",{className:"InstructionPanel",children:Object(c.jsx)(_d.a,{open:p,closeOnDocumentClick:!0,onClose:m,children:Object(c.jsxs)("div",{className:"modal",children:[Object(c.jsx)("a",{className:"close",onClick:m,children:"\xd7"}),Object(c.jsx)(Xl.a,{source:h,escapeHtml:!1,renderers:{code:ed},plugins:[Kl.a]})]})})})]})};let Jc=!1,$c=!1,eh=!1;const th=e=>{document.getElementById("page").style.cursor=e},nh=()=>{$c=!0,th("col-resize")},ah=()=>{eh=!0,th("row-resize")},rh=()=>{Jc=!1,$c=!1,eh=!1,th("auto")},ih=(e,t)=>e.map((e=>"".concat(e.toString()).concat(t))).join(" "),sh=(e,t)=>"".concat(e.toString()).concat(t),oh=(e,t,n)=>{let a=ih(t,"px");const r=document.getElementById("leftdraghandle");switch(n){case 0:case 1:default:break;case 2:a=ih([sh(t[0],"px"),sh([t[1]/(t[1]+t[3])],"fr"),sh(t[2],"px"),sh([t[3]/(t[1]+t[3])],"fr")],"");break;case 3:a=ih([sh(t[0]/(t[0]+t[2]+t[4]),"fr"),sh(t[1],"px"),sh(t[2]/(t[0]+t[2]+t[4]),"fr"),sh(t[3],"px"),sh(t[4]/(t[0]+t[2]+t[4]),"fr")],"");break;case 4:a=ih([sh(0,"px"),sh(t[1],"px"),sh(t[2]/(t[2]+t[4]),"fr"),sh(t[3],"px"),sh(t[4]/(t[2]+t[4]),"fr")],""),r.style.transform="rotate(180deg)";break;case 5:a=ih([sh(t[0]/(t[0]+t[2]),"fr"),sh(t[1],"px"),sh(t[2]/(t[0]+t[2]),"fr"),sh(t[3],"px"),sh(0,"px")],"");break;case 6:a=ih([sh(t[0],"px"),sh(t[1]/t[1],"fr"),sh(t[2],"px"),sh(0,"px")],"");break;case 7:a=ih([sh(190,"px"),sh(t[1],"px"),sh(t[2]/(t[2]+t[4]),"fr"),sh(t[3],"px"),sh(t[4]/(t[2]+t[4]),"fr")],""),r.style.transform="rotate(0deg)";break;case 8:a=ih([sh(t[0]/(t[0]+t[2]),"fr"),sh(t[1],"px"),sh(t[2]/(t[0]+t[2]),"fr"),sh(t[3],"px"),sh(360,"px")],"");break;case 9:a=ih([sh(t[0],"px"),sh(t[1]/t[1],"fr"),sh(t[2],"px"),sh(190,"px")],"")}return a},lh=(e,t,n)=>{const a=document.getElementById("leftcol"),r=document.getElementById("rightcol"),i=document.getElementById("leftdragbar"),s=document.getElementById("rightdragbar"),o=Jc?t.clientX:a.offsetWidth,l=$c?e.clientWidth-t.clientX:r.offsetWidth,d=[o,i.offsetWidth,e.clientWidth-(i.offsetWidth+s.offsetWidth)-o-l,s.offsetWidth,l];return oh(0,d,n)},dh=(e,t,n)=>{const a=document.getElementById("footer"),r=document.getElementById("header"),i=document.getElementById("bottomdragbar"),s=eh?e.clientHeight-t.clientY:a.offsetHeight,o=[r.offsetHeight,e.clientHeight-i.offsetHeight-s-r.offsetHeight,i.offsetHeight,s];return oh(0,o,n)},ch=()=>{const e=document.getElementById("page");let t;t=document.getElementById("leftcol").clientWidth<100?lh(e,null,7):lh(e,null,4),e.style.gridTemplateColumns=t},hh=()=>{const e=document.getElementById("page");let t;t=document.getElementById("rightcol").clientWidth<100?lh(e,null,8):lh(e,null,5),e.style.gridTemplateColumns=t},uh=()=>{const e=document.getElementById("page");let t;t=document.getElementById("footer").clientHeight<125?dh(e,null,9):dh(e,null,6),e.style.gridTemplateRows=t},ph=e=>{const t=document.getElementById("page");if(null!==t){const n=lh(t,e,3),a=dh(t,e,2);t.style.gridTemplateColumns=n,t.style.gridTemplateRows=a}};var gh=function(){Object(a.useEffect)((()=>(window.addEventListener("resize",(e=>{ph(e)})),e=>{window.removeEventListener("resize",ph)}))),Object(a.useEffect)((()=>{const e=e=>{const t=e.relatedTarget||e.toElement;t&&"HTML"!==t.nodeName||rh()};var t,n,a;return t=document,n="mouseout",a=e,t.addEventListener?t.addEventListener(n,a,!1):t.attachEvent&&t.attachEvent("on".concat(n),a),()=>{document.removeEventListener("mouseout",e)}}),[]);const[e,t]=Object(a.useState)(!1),n=()=>{t(!e)},[r,i]=Object(a.useState)(0),[s,o]=Object(a.useState)((()=>{const e=Qa(Ra);return null===e?(Xa(La),La):e})()),[l,d]=Object(a.useState)((()=>{const e=Qa(Ha);return null===e?(Wa(qa()),qa()):e})());return Object(a.useEffect)((()=>{Wa(Qa(Ha)),Xa(Qa(Ra))})),Object(c.jsxs)(Hl,{children:[e?Object(c.jsx)(Ya,{onFontIncrease:e=>{i(r+e)},onSetting:n,colorMode:s,handleColorModeChange:e=>{o(e),Xa(e)},systemColor:l,handleSystemColorChange:e=>{d(e),Wa(e)}}):"",Object(c.jsxs)("div",{id:"page",onMouseUp:rh,role:"button",tabIndex:"-1",onMouseMove:e=>(e=>{const t=document.getElementById("page");if(Jc||$c){const n=lh(t,e,1);t.style.gridTemplateColumns=n}else if(eh){const n=dh(t,e,0);t.style.gridTemplateRows=n}e.preventDefault()})(e),children:[Object(c.jsx)("div",{id:"header",children:Object(c.jsx)(u,{onSetting:n})}),Object(c.jsx)("div",{id:"leftcol",children:Object(c.jsx)(Hd,{fontSize:13,fontSizeIncrement:r})}),Object(c.jsx)("div",{id:"leftdragbar",tabIndex:"-1","aria-label":"Move left drag bar",onClick:ch,role:"button",className:"dragbar",children:Object(c.jsx)("div",{id:"draghandle",className:"handle",children:Object(c.jsx)(A,{id:"leftdraghandle"})})}),Object(c.jsx)("div",{id:"tabpages",children:Object(c.jsx)(Gd,{fontSize:15,fontSizeIncrement:r})}),Object(c.jsx)("div",{id:"rightdragbar",tabIndex:"-1","aria-label":"Move right drag bar",onDoubleClick:hh,onMouseDown:nh,role:"button",className:"dragbar",children:Object(c.jsxs)("div",{id:"draghandle",className:"handle",children:[Object(c.jsx)(m,{}),Object(c.jsx)(m,{}),Object(c.jsx)(m,{})]})}),Object(c.jsx)("div",{id:"rightcol",children:Object(c.jsx)(Fd,{fontSize:15,fontSizeIncrement:r})}),Object(c.jsx)("div",{id:"bottomdragbar",tabIndex:"-1","aria-label":"Move bottom drag bar",onDoubleClick:uh,onMouseDown:ah,role:"button",className:"dragbar",children:Object(c.jsxs)("div",{id:"draghandle",className:"handle bottomHandle",children:[Object(c.jsx)(m,{}),Object(c.jsx)(m,{}),Object(c.jsx)(m,{})]})}),Object(c.jsx)("div",{id:"footer",children:Object(c.jsx)(Zc,{})})]})]})};n(89);var mh=function(){return Object(c.jsx)(c.Fragment,{children:Object(c.jsxs)("div",{className:"abHeader",children:[Object(c.jsxs)("div",{className:"logo",children:[Object(c.jsx)("img",{src:d,alt:"logo"}),Object(c.jsx)("h1",{children:"Algorithms in Action"})]}),Object(c.jsx)("div",{className:"title",children:"An All New Algorithm Visualiser"}),Object(c.jsx)("div",{className:"subtitle",children:"Designed by students, for students."}),Object(c.jsx)(o.b,{className:"start",to:"/",children:"Start Now"})]})})},fh=n(394),bh=n(205),yh=n.n(bh),Ah=n(206),xh=n.n(Ah);var vh=e=>{let{name:t,photo:n,github:r,linkedIn:i,desc:s,title:o}=e;const[l,d]=Object(a.useState)(!1),[h,u]=Object(a.useState)(!1);return Object(c.jsxs)("div",{className:"teamCard",href:i,children:[Object(c.jsx)("img",{className:"photo",src:n,alt:t}),Object(c.jsxs)("div",{className:"memberDescription",children:[Object(c.jsx)("div",{className:"title",children:o}),Object(c.jsx)("a",{href:i,target:"_blank",rel:"noopener noreferrer",children:Object(c.jsx)("div",{className:"name",children:t})}),Object(c.jsx)("div",{className:"desc",children:s})]}),Object(c.jsxs)("div",{className:"icons",children:[r&&Object(c.jsx)(fh.a,{href:r,target:"_blank",rel:"noopener",color:"inherit",onMouseEnter:()=>d(!0),onMouseLeave:()=>d(!1),children:Object(c.jsx)(yh.a,{fontSize:"small",color:l?"primary":"inherit"})}),i&&Object(c.jsx)(fh.a,{href:i,target:"_blank",rel:"noopener",color:"inherit",onMouseEnter:()=>u(!0),onMouseLeave:()=>u(!1),children:Object(c.jsx)(xh.a,{color:h?"primary":"inherit"})})]})]})};var jh=e=>{let{teammembers:t}=e;return Object(c.jsxs)("div",{className:"projectContainer",children:[Object(c.jsx)("div",{className:"heading",variant:"h4",display:"block",children:"Team 2021s1"}),Object(c.jsx)("div",{className:"teamMembers",children:t.map((e=>Object(c.jsx)(vh,{name:e.name,photo:e.photo,github:e.github,linkedIn:e.linkedIn,desc:e.desc,title:e.title},e.name)))})]})};var wh=e=>{let{teammembers:t}=e;return Object(c.jsxs)("div",{className:"projectContainer",children:[Object(c.jsx)("div",{className:"heading",variant:"h4",display:"block",children:"Team 2021s2"}),Object(c.jsx)("div",{className:"teamMembers",children:t.map((e=>Object(c.jsx)(vh,{name:e.name,photo:e.photo,github:e.github,linkedIn:e.linkedIn,desc:e.desc,title:e.title},e.name)))})]})},Eh=n.p+"static/media/lee_naish.3f9e643c.png",kh=n.p+"static/media/boyu.06b0f954.JPG",Nh=n.p+"static/media/carina.b1d28001.jpg",Oh=n.p+"static/media/joao.9d1f22a6.jpg",Ih=n.p+"static/media/kenny.4508c9be.JPG",Ch=n.p+"static/media/tianyang.1eec752a.jpg",Sh=n.p+"static/media/linfan.298b2df1.jpeg",Mh=n.p+"static/media/yinsong.f39de5b2.jpg",Bh=n.p+"static/media/zihan.c88b2e2a.jpg",Th=n.p+"static/media/nir.5be60648.png",Rh=n.p+"static/media/ziyi.a6c42d3a.jpg",Lh=n.p+"static/media/jiajun.5fddd48a.jpg",Dh=n.p+"static/media/hantong.63b24722.jpeg";const Ph=[{id:0,name:"Harald Sondergaard",desc:"Professor",department:"University of Melbourne",link:"https://findanexpert.unimelb.edu.au/profile/13416-harald-sondergaard",img:"data:image/jpeg;base64,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"},{id:1,name:"Dr. Linda Stern",desc:"Honarary",department:"University of Melbourne",link:"https://findanexpert.unimelb.edu.au/profile/14535-linda-stern",img:"data:image/jpeg;base64,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"},{id:2,name:"Dr. Lee Naish",desc:"Honarary",department:"University of Melbourne",link:"https://people.eng.unimelb.edu.au/lee/",img:Eh}],Fh=[{name:"Zihan Zhang",photo:Bh,github:"https://github.com/ZhangzihanGit",linkedIn:"https://www.linkedin.com/in/zihan-zhang-a40855172/",desc:"University of Melbourne",title:"MEng (Software)"},{name:"Luke Ceddia",photo:"data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEASABIAAD/4QCYRXhpZgAATU0AKgAAAAgABAEaAAUAAAABAAAAPgEbAAUAAAABAAAARgEoAAMAAAABAAIAAIdpAAQAAAABAAAATgAAAAAAAABIAAAAAQAAAEgAAAABAAWQAAAHAAAABDAyMTCgAAAHAAAABDAxMDCgAQADAAAAAQABAACgAgAEAAAAAQAAAGSgAwAEAAAAAQAAAIUAAAAA/+ECz2h0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8APD94cGFja2V0IGJlZ2luPSfvu78nIGlkPSdXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQnPz4KPHg6eG1wbWV0YSB4bWxuczp4PSdhZG9iZTpuczptZXRhLyc+CjxyZGY6UkRGIHhtbG5zOnJkZj0naHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyc+CgogPHJkZjpEZXNjcmlwdGlvbiB4bWxuczpleGlmPSdodHRwOi8vbnMuYWRvYmUuY29tL2V4aWYvMS4wLyc+CiAgPGV4aWY6WFJlc29sdXRpb24+NzI8L2V4aWY6WFJlc29sdXRpb24+CiAgPGV4aWY6WVJlc29sdXRpb24+NzI8L2V4aWY6WVJlc29sdXRpb24+CiAgPGV4aWY6UmVzb2x1dGlvblVuaXQ+SW5jaDwvZXhpZjpSZXNvbHV0aW9uVW5pdD4KICA8ZXhpZjpFeGlmVmVyc2lvbj5FeGlmIFZlcnNpb24gMi4xPC9leGlmOkV4aWZWZXJzaW9uPgogIDxleGlmOkZsYXNoUGl4VmVyc2lvbj5GbGFzaFBpeCBWZXJzaW9uIDEuMDwvZXhpZjpGbGFzaFBpeFZlcnNpb24+CiAgPGV4aWY6Q29sb3JTcGFjZT5zUkdCPC9leGlmOkNvbG9yU3BhY2U+CiAgPGV4aWY6UGl4ZWxYRGltZW5zaW9uPjk2MDwvZXhpZjpQaXhlbFhEaW1lbnNpb24+CiAgPGV4aWY6UGl4ZWxZRGltZW5zaW9uPjEyODA8L2V4aWY6UGl4ZWxZRGltZW5zaW9uPgogPC9yZGY6RGVzY3JpcHRpb24+Cgo8L3JkZjpSREY+CjwveDp4bXBtZXRhPgo8P3hwYWNrZXQgZW5kPSdyJz8+Cv/bAEMA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",github:"https://github.com/flukiluke",linkedIn:"",desc:"University of Melbourne",title:"MEng (Software)"},{name:"Kenny Lee",photo:Ih,github:"https://github.com/kennylwx",linkedIn:"https://www.linkedin.com/in/kennylwx/",desc:"University of Melbourne",title:"MEng (Software)"},{name:"Yingsong Chen",photo:Mh,github:"https://github.com/icarusunimelb",linkedIn:"https://www.linkedin.com/in/yinsong-chen-62707b15b/",desc:"University of Melbourne",title:"MEng (Software)"},{name:"Bohao Liu",photo:Nh,github:"https://github.com/lbh-carina",linkedIn:"https://www.linkedin.com/in/bohao-liu-3218211ba/",desc:"University of Melbourne",title:"MEng (Software)"},{name:"Nir Palombo",photo:Th,github:"https://github.com/nirpalombo",linkedIn:"https://www.linkedin.com/in/nir-palombo-b513b449/",desc:"University of Melbourne",title:"MEng (Software)"},{name:"Boyu Zhou",photo:kh,github:"https://github.com/BOYU0926",linkedIn:"https://www.linkedin.com/in/boyu-zhou-05487b1a0/",desc:"University of Melbourne",title:"MEng (Software)"},{name:"Jo\xe3o Pereira",photo:Oh,github:"https://github.com/jofrancis1997",linkedIn:"https://www.linkedin.com/in/jo\xe3o-pereira-574972163/",desc:"University of Melbourne",title:"MEng (Software)"},{name:"Lin Fan",photo:Sh,github:"https://github.com/tututulillian",linkedIn:"",desc:"University of Melbourne",title:"MEng (Software)"},{name:"Tianyang Chen",photo:Ch,github:"https://github.com/Allen-Chen-7",linkedIn:"https://www.linkedin.com/in/tianyang-chen-8208261ba/",desc:"University of Melbourne",title:"MEng (Software)"}],Hh=[{name:"Tianjing Ruan",photo:"https://media-exp1.licdn.com/dms/image/C5603AQHYyAHvoTMVnA/profile-displayphoto-shrink_400_400/0/1634538882547?e=1640217600&v=beta&t=gnCJL7gD-PK3ERdfrXuVePdY2nfIIQErmlmeFX-zi9o",github:"https://github.com/TianjingRuan",linkedIn:"https://www.linkedin.com/in/tianjingruan/",desc:"University of Melbourne",title:"MIT (Artificial Intelligence)"},{name:"Wenkai Gong",photo:"https://ui-avatars.com/api/?name=Wenkai+Gong&background=0D8ABC&color=fff",github:"https://github.com/DanistyWuKids",linkedIn:"https://www.linkedin.com/in/wgong0001/",desc:"University of Melbourne",title:"MEng (Software)"},{name:"Xuan Yin",photo:"https://ui-avatars.com/api/?name=Xuan+Yin&background=0D8ABC&color=fff",github:"https://github.com/XuanYin2020",linkedIn:"https://www.linkedin.com/in/xuan-yin-b09a20224/",desc:"University of Melbourne",title:"MIT (Distributed Computing)"},{name:"Yuqi Song",photo:"https://ui-avatars.com/api/?name=Yuqi+Song&background=0D8ABC&color=fff",github:"https://github.com/irissong49",linkedIn:"#",desc:"University of Melbourne",title:"MIT (Artificial Intelligence)"},{name:"Yifei Yang",photo:"https://ui-avatars.com/api/?name=Yifei+Yang&background=0D8ABC&color=fff",github:"#",linkedIn:"#",desc:"University of Melbourne",title:"MEng (Software)"},{name:"Zhenhao Chen",photo:"https://ui-avatars.com/api/?name=Zhenhao+Chen&background=0D8ABC&color=fff",github:"https://github.com/xcorrnner",linkedIn:"#",desc:"University of Melbourne",title:"MIT (Artificial Intelligence)"},{name:"Ziyi Zhang",photo:Rh,github:"http://github.com/ZIYIZHANG2",linkedIn:"https://www.linkedin.com/in/stevie-cheung-84931818b/",desc:"University of Melbourne",title:"MIT (Artificial Intelligence)"},{name:"Jiajun Liu",photo:Lh,github:"https://github.com/jiajunliu0024",linkedIn:"https://www.linkedin.com/in/jiajun-liu-8a9b681b4/",desc:"University of Melbourne",title:"MIT (Artificial Intelligence)"},{name:"Hantong Xing",photo:Dh,github:"https://github.com/xinghantong",linkedIn:"https://www.linkedin.com/in/hantong/",desc:"University of Melbourne",title:"MIT (Artificial Intelligence)"},{name:"Zisong Liao",photo:"https://ui-avatars.com/api/?name=Zisong+Liao&background=0D8ABC&color=fff",github:"https://github.com/ZisongLiao",linkedIn:"#",desc:"University of Melbourne",title:"MIT (Artificial Intelligence)"},{name:"Huimin Huang",photo:"https://ui-avatars.com/api/?name=Huimin+Huang&background=0D8ABC&color=fff",github:"https://github.com/huimin5",linkedIn:"#",desc:"University of Melbourne",title:"MIT (Distributed Computing)"},{name:"Alexander Troup",photo:"https://ui-avatars.com/api/?name=Alexander+Troup&background=0D8ABC&color=fff",github:"#",linkedIn:"#",desc:"University of Melbourne",title:"M-IT (Computing)"},{name:"Madisyn Freeman",photo:"https://ui-avatars.com/api/?name=Madi+Freeman&background=0D8ABC&color=fff",github:"https://github.com/madifreeman",linkedIn:"#",desc:"University of Melbourne",title:"M-IT"},{name:"Conor Rogers",photo:"https://ui-avatars.com/api/?name=Conor+Rogers&background=0D8ABC&color=fff",github:"#",linkedIn:"#",desc:"University of Melbourne",title:"M-IT"},{name:"Deepthy Das Kalathil",photo:"https://ui-avatars.com/api/?name=Deepthy+Das+Kalathil&background=0D8ABC&color=fff",github:"#",linkedIn:"#",desc:"University of Melbourne",title:"M-IT"},{name:"Kaiquan Lin",photo:"https://ui-avatars.com/api/?name=Kaiquan+Lin&background=0D8ABC&color=fff",github:"#",linkedIn:"#",desc:"University of Melbourne",title:"M-IT"}];var _h;function Gh(){return Gh=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e},Gh.apply(this,arguments)}function Vh(e,t){let{title:n,titleId:r,...i}=e;return a.createElement("svg",Gh({xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 1440 320",ref:t,"aria-labelledby":r},i),n?a.createElement("title",{id:r},n):null,_h||(_h=a.createElement("path",{fill:"#273036",fillOpacity:1,d:"M0,32L1440,128L1440,0L0,0Z"})))}const zh=a.forwardRef(Vh);n.p;var Qh=function(e){let{id:t,link:n,img:a,name:r,desc:i,department:s}=e;return Object(c.jsx)(c.Fragment,{children:Object(c.jsxs)("a",{href:n,id:t,target:"_blank",rel:"noopener noreferrer",className:"profile",children:[Object(c.jsx)("img",{src:a,alt:r}),Object(c.jsxs)("div",{className:"info",children:[Object(c.jsx)("div",{className:"desc",children:i}),Object(c.jsx)("div",{className:"name",children:r}),Object(c.jsx)("div",{className:"department",children:s})]})]})})};var Uh=function(){return Object(c.jsxs)("div",{className:"section",children:[Object(c.jsx)("div",{className:"title",children:"Featuring"}),Object(c.jsx)("div",{className:"extraTitle",children:"Stepwise Refinement"}),Object(c.jsx)("div",{className:"subtitle",children:"a pioneering pedagogy techonology by"}),Object(c.jsx)("div",{className:"professors",children:Ph.map((e=>{let{name:t,desc:n,department:a,link:r,img:i,id:s}=e;return Object(c.jsx)(Qh,{name:t,desc:n,department:a,link:r,img:i,id:s},s)}))})]})};var Wh,qh=function(){return Object(c.jsx)(c.Fragment,{children:Object(c.jsx)("div",{className:"appSection",children:Object(c.jsxs)("div",{className:"innerContainer",children:[Object(c.jsx)("div",{className:"title",children:"Now Showing"}),Object(c.jsxs)("span",{className:"bigTitle",children:[El||5," ","New Algorithms!"]}),Object(c.jsx)("div",{className:"subtitle",children:"with more coming soon."}),Object(c.jsx)("div",{className:"dotdot"})]})})})};function Xh(){return Xh=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e},Xh.apply(this,arguments)}function Yh(e,t){let{title:n,titleId:r,...i}=e;return a.createElement("svg",Xh({xmlns:"http://www.w3.org/2000/svg",xmlnsXlink:"http://www.w3.org/1999/xlink",id:"Layer_1",x:"0px",y:"0px",width:"24px",height:"24px",viewBox:"0 0 24 24",xmlSpace:"preserve",ref:t,"aria-labelledby":r},i),n?a.createElement("title",{id:r},n):null,Wh||(Wh=a.createElement("path",{d:"M15.5 22.7h-.1l-.1-.1V22v-2.5c0-.7-.1-1.3-.4-1.8 2.3-.4 4.8-1.6 4.8-6.1 0-1.2-.4-2.3-1.1-3.2.2-.6.3-1.7-.2-3.1l-.3-.3s-.2-.1-.4-.1c-.6 0-1.5.2-3 1.2-.8-.1-1.7-.3-2.7-.3-1 0-1.9.1-2.8.3C7.8 5.2 6.8 5 6.2 5c-.2 0-.3.1-.4.1-.1 0-.3.2-.3.3-.5 1.4-.4 2.5-.2 3.1-.7.9-1.1 2-1.1 3.2 0 4.4 2.6 5.6 4.8 6.1-.1.2-.2.5-.3.8-.2.1-.5.2-.9.2s-.8-.1-1.1-.4l-.1-.1c-.1-.1-.1-.2-.2-.2l-.1-.1-.1-.1c0-.1-.8-1.3-2.2-1.4-.5 0-.9.2-1 .5-.2.5.4.9.7 1.1 0 0 .6.3 1 1.4.2.7 1.1 2 3.2 2h.7v1.4l-.1.1s-.1 0 0 0C4 21.2 1 17 1 12.3c0-6.1 4.9-11 11-11s11 4.9 11 11c0 4.7-3 8.9-7.5 10.4z"})))}const Kh=a.forwardRef(Yh);var Zh;n.p;function Jh(){return Jh=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e},Jh.apply(this,arguments)}function $h(e,t){let{title:n,titleId:r,...i}=e;return a.createElement("svg",Jh({enableBackground:"new 0 0 2447.6 2452.5",viewBox:"0 0 2447.6 2452.5",xmlns:"http://www.w3.org/2000/svg",ref:t,"aria-labelledby":r},i),n?a.createElement("title",{id:r},n):null,Zh||(Zh=a.createElement("g",{clipRule:"evenodd",fillRule:"evenodd"},a.createElement("path",{d:"m897.4 0c-135.3.1-244.8 109.9-244.7 245.2-.1 135.3 109.5 245.1 244.8 245.2h244.8v-245.1c.1-135.3-109.5-245.1-244.9-245.3.1 0 .1 0 0 0m0 654h-652.6c-135.3.1-244.9 109.9-244.8 245.2-.2 135.3 109.4 245.1 244.7 245.3h652.7c135.3-.1 244.9-109.9 244.8-245.2.1-135.4-109.5-245.2-244.8-245.3z",fill:"#36c5f0"}),a.createElement("path",{d:"m2447.6 899.2c.1-135.3-109.5-245.1-244.8-245.2-135.3.1-244.9 109.9-244.8 245.2v245.3h244.8c135.3-.1 244.9-109.9 244.8-245.3zm-652.7 0v-654c.1-135.2-109.4-245-244.7-245.2-135.3.1-244.9 109.9-244.8 245.2v654c-.2 135.3 109.4 245.1 244.7 245.3 135.3-.1 244.9-109.9 244.8-245.3z",fill:"#2eb67d"}),a.createElement("path",{d:"m1550.1 2452.5c135.3-.1 244.9-109.9 244.8-245.2.1-135.3-109.5-245.1-244.8-245.2h-244.8v245.2c-.1 135.2 109.5 245 244.8 245.2zm0-654.1h652.7c135.3-.1 244.9-109.9 244.8-245.2.2-135.3-109.4-245.1-244.7-245.3h-652.7c-135.3.1-244.9 109.9-244.8 245.2-.1 135.4 109.4 245.2 244.7 245.3z",fill:"#ecb22e"}),a.createElement("path",{d:"m0 1553.2c-.1 135.3 109.5 245.1 244.8 245.2 135.3-.1 244.9-109.9 244.8-245.2v-245.2h-244.8c-135.3.1-244.9 109.9-244.8 245.2zm652.7 0v654c-.2 135.3 109.4 245.1 244.7 245.3 135.3-.1 244.9-109.9 244.8-245.2v-653.9c.2-135.3-109.4-245.1-244.7-245.3-135.4 0-244.9 109.8-244.8 245.1 0 0 0 .1 0 0",fill:"#e01e5a"}))))}const eu=a.forwardRef($h);n.p;var tu=function(){return Object(c.jsxs)("div",{className:"contributeSection",children:[Object(c.jsx)("div",{className:"title",children:"Interested in getting involved?"}),Object(c.jsx)("div",{className:"subtitle",children:"Join our open-source project now."}),Object(c.jsxs)("div",{className:"btnContainer",children:[Object(c.jsxs)("a",{className:"slack btn",href:"https://algorithms-in-action.slack.com/",target:"_blank",rel:"noopener noreferrer",children:[Object(c.jsx)(eu,{}),"Slack"]}),Object(c.jsxs)("a",{className:"github btn",href:"https://github.com/algorithms-in-action/algorithms-in-action.github.io",target:"_blank",rel:"noopener noreferrer",children:[Object(c.jsx)(Kh,{}),"Github"]})]})]})};var nu=()=>Object(c.jsx)(c.Fragment,{children:Object(c.jsxs)("div",{className:"background",children:[Object(c.jsx)("div",{className:"top",children:Object(c.jsx)(mh,{})}),Object(c.jsx)("div",{className:"separator",children:Object(c.jsx)(zh,{})}),Object(c.jsx)(Uh,{}),Object(c.jsx)(qh,{}),Object(c.jsx)("div",{className:"aboutContainer",children:Object(c.jsx)(jh,{teammembers:Fh})}),Object(c.jsx)("div",{className:"aboutContainer",children:Object(c.jsx)(wh,{teammembers:Hh})}),Object(c.jsx)(tu,{})]})});var au=function(){return Object(c.jsx)(o.a,{children:Object(c.jsxs)(l.c,{children:[Object(c.jsx)(l.a,{exact:!0,path:"/",component:gh}),Object(c.jsx)(l.a,{path:"/about",component:nu}),Object(c.jsx)(l.a,{component:gh})]})})};s.a.render(Object(c.jsx)(au,{}),document.getElementById("root"))},35:function(e,t,n){e.exports={themeDark:"#242424",themeNormal:"#393939",themeLight:"#505050",colorFont:"#cecece",colorShadow:"rgba(0,0,0,.2)",colorOverlay:"rgba(255,255,255,.1)",colorAlert:"#f3bd58",colorSelected:"#067aff",colorPatched:"#c51162",colorHighlight:"#29d",colorActive:"#00e676",colorBlue:"#067aff",colorRed:"#d21010",colorPurple:"#c735da",colorGreen:"#4bb454",colorYellow:"#b3b605",colorLightGreen:"#2ec752",lineHeight:"32px",fontSizeNormal:"12px",fontSizeLarge:"14px",graph:"NAryTreeRenderer_graph__11j5Y",node:"NAryTreeRenderer_node__2MqTZ",circle:"NAryTreeRenderer_circle__1UjwY",rect:"NAryTreeRenderer_rect__3cHTG",id:"NAryTreeRenderer_id__36IDH",variableGreen:"NAryTreeRenderer_variableGreen__1799G",variableOrange:"NAryTreeRenderer_variableOrange__3K8KN",variableRed:"NAryTreeRenderer_variableRed__27VAU",edge:"NAryTreeRenderer_edge__3GfXI",line:"NAryTreeRenderer_line__1p0Wg",directed:"NAryTreeRenderer_directed__oSO2V",arrow:"NAryTreeRenderer_arrow__3th69",text:"NAryTreeRenderer_text__3Piod",pseudocode_function:"NAryTreeRenderer_pseudocode_function__3H8TN"}},5:function(e,t,n){e.exports={themeDark:"#242424",themeNormal:"#393939",themeLight:"#505050",colorFont:"#cecece",colorShadow:"rgba(0,0,0,.2)",colorOverlay:"rgba(255,255,255,.1)",colorAlert:"#f3bd58",colorSelected:"#067aff",colorPatched:"#c51162",colorHighlight:"#29d",colorActive:"#00e676",colorBlue:"#067aff",colorRed:"#d21010",colorPurple:"#c735da",colorGreen:"#4bb454",colorYellow:"#b3b605",colorLightGreen:"#2ec752",lineHeight:"32px",fontSizeNormal:"12px",fontSizeLarge:"14px",array_2d:"Array2DRenderer_array_2d__CQtO7",bottom_caption:"Array2DRenderer_bottom_caption__2UcRI",pseudocode_function:"Array2DRenderer_pseudocode_function__3tLmx",top_variable:"Array2DRenderer_top_variable__3TyYg",row:"Array2DRenderer_row__1AF4G",col:"Array2DRenderer_col__2SqHW",value:"Array2DRenderer_value__iOddC",variable:"Array2DRenderer_variable__3APFj",selected:"Array2DRenderer_selected__2-LjK",selected1:"Array2DRenderer_selected1__1leY4",selected2:"Array2DRenderer_selected2__1RFPz",selected3:"Array2DRenderer_selected3__1U4sT",variableGreen:"Array2DRenderer_variableGreen__11M4V",variableOrange:"Array2DRenderer_variableOrange__2LAOP",variableRed:"Array2DRenderer_variableRed__3RwXq",selected4:"Array2DRenderer_selected4__1dOeN",selected5:"Array2DRenderer_selected5__2gsHc",patched:"Array2DRenderer_patched__39sFU",sorted:"Array2DRenderer_sorted__JC_Ib",index:"Array2DRenderer_index__N6dL3",variables:"Array2DRenderer_variables__qG91t",faded:"Array2DRenderer_faded__1x5bI",array2d_container:"Array2DRenderer_array2d_container__AfF02",container:"Array2DRenderer_container__1QxTH",captionHashing:"Array2DRenderer_captionHashing__1xSN3",captionDFS:"Array2DRenderer_captionDFS__2TAff",captionBFS:"Array2DRenderer_captionBFS__31DhM",captionDFSrec:"Array2DRenderer_captionDFSrec__1PhEI",captionmsort_lista_td:"Array2DRenderer_captionmsort_lista_td__1tagB",captionmsort_arr_td:"Array2DRenderer_captionmsort_arr_td__3ivoL"}},89:function(e,t,n){},9:function(e,t,n){e.exports={themeDark:"#242424",themeNormal:"#393939",themeLight:"#505050",colorFont:"#cecece",colorShadow:"rgba(0,0,0,.2)",colorOverlay:"rgba(255,255,255,.1)",colorAlert:"#f3bd58",colorSelected:"#067aff",colorPatched:"#c51162",colorHighlight:"#29d",colorActive:"#00e676",colorBlue:"#067aff",colorRed:"#d21010",colorPurple:"#c735da",colorGreen:"#4bb454",colorYellow:"#b3b605",colorLightGreen:"#2ec752",lineHeight:"32px",fontSizeNormal:"12px",fontSizeLarge:"14px",graph:"GraphRenderer_graph__3RTuV",node:"GraphRenderer_node__3kLsG",circle:"GraphRenderer_circle__2eGYq",rect:"GraphRenderer_rect__1jJw_",id:"GraphRenderer_id__1ylea",weight:"GraphRenderer_weight__1nllC",selected:"GraphRenderer_selected__2vcx1",visited0:"GraphRenderer_visited0__3GEhf",visited:"GraphRenderer_visited__1xFvq",sorted:"GraphRenderer_sorted__wAll5",visited1:"GraphRenderer_visited1__29PKv",visited2:"GraphRenderer_visited2__1b5_e",visited3:"GraphRenderer_visited3__3cX8Q",visited4:"GraphRenderer_visited4__18P5k",edge:"GraphRenderer_edge__2ZlGZ",line:"GraphRenderer_line__2F5F3",directed:"GraphRenderer_directed__37x_P",arrow:"GraphRenderer_arrow__37Xlp",axis:"GraphRenderer_axis__2WHlE",axisLabel:"GraphRenderer_axisLabel__WTstn"}}},[[336,1,2]]]);
//# sourceMappingURL=main.eb24695e.chunk.js.map